// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: ethereum/v1/leaderboard/leaderboard.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Profile } from "../profile/profile";
import {
  GameMode,
  gameModeFromJSON,
  gameModeToJSON,
  gameModeToNumber,
  PlayMode,
  playModeFromJSON,
  playModeToJSON,
  playModeToNumber,
  Score,
} from "../score/score";

export interface GetTopRankerLeaderboardRequest {
  /**
   * The maximum number of scores to return. The service may return fewer than
   * this value.
   * If unspecified, at most 5 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `GetLeaderbaord` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding season of leaderboard.
   * The default value is 1
   */
  season: number;
  /**
   * The corresponding play_mode of leaderboard.
   * The default value is "TIME_ATTACK"
   */
  playMode: PlayMode;
  /**
   * The corresponding game_mode of leaderboard.
   * The default value is "SINGLE_PLAYER"
   */
  gameMode: GameMode;
}

export interface GetTopRankerLeaderboardResponse {
  topRankers: TopRanker[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
  deadline: string | undefined;
}

export interface GetTopRankerRequest {
  profileAddress: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding play_mode of leaderboard.
   * The default value is "TIME_ATTACK"
   */
  playMode: PlayMode;
  /**
   * The corresponding game_mode of leaderboard.
   * The default value is "SINGLE_PLAYER"
   */
  gameMode: GameMode;
}

export interface RenderTopRankerLeaderboardRequest {
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding season of leaderboard.
   * The default value is 1
   */
  season: number;
  /**
   * The corresponding play_mode of leaderboard.
   * The default value is "TIME_ATTACK"
   */
  playMode: PlayMode;
  /**
   * The corresponding game_mode of leaderboard.
   * The default value is "SINGLE_PLAYER"
   */
  gameMode: GameMode;
  me: string;
}

/**
 * GetWeeklyTopCollectorLeaderboardRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface GetWeeklyTopCollectorLeaderboardRequest {
  /**
   * The maximum number of scores to return. The service may return fewer than
   * this value.
   * If unspecified, at most 5 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListWeeklytimeTopCollectors` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding season of leaderboard.
   * The default value is 1
   */
  season: number;
}

export interface GetWeeklyTopCollectorLeaderboardResponse {
  topCollectors: StarHunter[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
  deadline: string | undefined;
}

export interface GetWeeklyTopCollectorRequest {
  profileAddress: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
}

/**
 * GetAllTimeTopCollectorsLeaderboardRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface GetAllTimeTopCollectorLeaderboardRequest {
  /**
   * The maximum number of scores to return. The service may return fewer than
   * this value.
   * If unspecified, at most 5 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `GetAllTimeTopCollectorLeaderboard` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface GetAllTimeTopCollectorLeaderboardResponse {
  topCollectors: StarHunter[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface RenderWeeklyStarHunterLeaderboardRequest {
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding season of leaderboard.
   * The default value is 1
   */
  season: number;
  me: string;
}

/**
 * GetWeeklyStarHunterLeaderboardRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface GetWeeklyStarHunterLeaderboardRequest {
  /**
   * The maximum number of scores to return. The service may return fewer than
   * this value.
   * If unspecified, at most 5 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListWeeklytimeTopCollectors` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding season of leaderboard.
   * The default value is 1
   */
  season: number;
}

export interface GetWeeklyStarHunterLeaderboardResponse {
  starHunters: StarHunter[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
  deadline: string | undefined;
}

export interface GetWeeklyStarHunterRequest {
  profileAddress: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
}

/**
 * GetAllTimeStarHuntersLeaderboardRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface GetAllTimeStarHunterLeaderboardRequest {
  /**
   * The maximum number of scores to return. The service may return fewer than
   * this value.
   * If unspecified, at most 5 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `GetAllTimeStarHunterLeaderboard` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface GetAllTimeStarHunterLeaderboardResponse {
  starHunters: StarHunter[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface ImageResponse {
  image: Uint8Array;
}

export interface TopRanker {
  rank: number;
  profile: Profile | undefined;
  score: Score | undefined;
}

export interface StarHunter {
  rank: number;
  profile: Profile | undefined;
  totalStars: number;
}

export interface RenderStarHuntersLeaderboardImageRequest {
  starHunters: StarHunterSlim[];
  me: StarHunterSlim | undefined;
}

export interface RenderTopRankerLeaderboardImageRequest {
  topRankers: TopRankerSlim[];
  me: TopRankerSlim | undefined;
}

export interface StarHunterSlim {
  rank: number;
  profile: string;
  totalStars: number;
}

export interface TopRankerSlim {
  rank: number;
  profile: string;
  scorePoint: number;
}

function createBaseGetTopRankerLeaderboardRequest(): GetTopRankerLeaderboardRequest {
  return {
    pageSize: 0,
    pageToken: "",
    week: 0,
    season: 0,
    playMode: PlayMode.PLAY_MODE_UNSPECIFIED,
    gameMode: GameMode.GAME_MODE_UNSPECIFIED,
  };
}

export const GetTopRankerLeaderboardRequest: MessageFns<GetTopRankerLeaderboardRequest> = {
  encode(message: GetTopRankerLeaderboardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.week !== 0) {
      writer.uint32(24).uint32(message.week);
    }
    if (message.season !== 0) {
      writer.uint32(32).uint32(message.season);
    }
    if (message.playMode !== PlayMode.PLAY_MODE_UNSPECIFIED) {
      writer.uint32(40).int32(playModeToNumber(message.playMode));
    }
    if (message.gameMode !== GameMode.GAME_MODE_UNSPECIFIED) {
      writer.uint32(48).int32(gameModeToNumber(message.gameMode));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopRankerLeaderboardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopRankerLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.week = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.season = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.playMode = playModeFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gameMode = gameModeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopRankerLeaderboardRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
      playMode: isSet(object.playMode) ? playModeFromJSON(object.playMode) : PlayMode.PLAY_MODE_UNSPECIFIED,
      gameMode: isSet(object.gameMode) ? gameModeFromJSON(object.gameMode) : GameMode.GAME_MODE_UNSPECIFIED,
    };
  },

  toJSON(message: GetTopRankerLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    if (message.playMode !== undefined) {
      obj.playMode = playModeToJSON(message.playMode);
    }
    if (message.gameMode !== undefined) {
      obj.gameMode = gameModeToJSON(message.gameMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTopRankerLeaderboardRequest>, I>>(base?: I): GetTopRankerLeaderboardRequest {
    return GetTopRankerLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTopRankerLeaderboardRequest>, I>>(
    object: I,
  ): GetTopRankerLeaderboardRequest {
    const message = createBaseGetTopRankerLeaderboardRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.week = object.week ?? 0;
    message.season = object.season ?? 0;
    message.playMode = object.playMode ?? PlayMode.PLAY_MODE_UNSPECIFIED;
    message.gameMode = object.gameMode ?? GameMode.GAME_MODE_UNSPECIFIED;
    return message;
  },
};

function createBaseGetTopRankerLeaderboardResponse(): GetTopRankerLeaderboardResponse {
  return { topRankers: [], nextPageToken: "", deadline: undefined };
}

export const GetTopRankerLeaderboardResponse: MessageFns<GetTopRankerLeaderboardResponse> = {
  encode(message: GetTopRankerLeaderboardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topRankers) {
      TopRanker.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.deadline !== undefined) {
      Timestamp.encode(toTimestamp(message.deadline), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopRankerLeaderboardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopRankerLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topRankers.push(TopRanker.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopRankerLeaderboardResponse {
    return {
      topRankers: globalThis.Array.isArray(object?.topRankers)
        ? object.topRankers.map((e: any) => TopRanker.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      deadline: isSet(object.deadline) ? globalThis.String(object.deadline) : undefined,
    };
  },

  toJSON(message: GetTopRankerLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.topRankers?.length) {
      obj.topRankers = message.topRankers.map((e) => TopRanker.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.deadline !== undefined) {
      obj.deadline = message.deadline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTopRankerLeaderboardResponse>, I>>(base?: I): GetTopRankerLeaderboardResponse {
    return GetTopRankerLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTopRankerLeaderboardResponse>, I>>(
    object: I,
  ): GetTopRankerLeaderboardResponse {
    const message = createBaseGetTopRankerLeaderboardResponse();
    message.topRankers = object.topRankers?.map((e) => TopRanker.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.deadline = object.deadline ?? undefined;
    return message;
  },
};

function createBaseGetTopRankerRequest(): GetTopRankerRequest {
  return {
    profileAddress: "",
    week: 0,
    playMode: PlayMode.PLAY_MODE_UNSPECIFIED,
    gameMode: GameMode.GAME_MODE_UNSPECIFIED,
  };
}

export const GetTopRankerRequest: MessageFns<GetTopRankerRequest> = {
  encode(message: GetTopRankerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileAddress !== "") {
      writer.uint32(10).string(message.profileAddress);
    }
    if (message.week !== 0) {
      writer.uint32(16).uint32(message.week);
    }
    if (message.playMode !== PlayMode.PLAY_MODE_UNSPECIFIED) {
      writer.uint32(24).int32(playModeToNumber(message.playMode));
    }
    if (message.gameMode !== GameMode.GAME_MODE_UNSPECIFIED) {
      writer.uint32(32).int32(gameModeToNumber(message.gameMode));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopRankerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopRankerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profileAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.week = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.playMode = playModeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gameMode = gameModeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopRankerRequest {
    return {
      profileAddress: isSet(object.profileAddress) ? globalThis.String(object.profileAddress) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      playMode: isSet(object.playMode) ? playModeFromJSON(object.playMode) : PlayMode.PLAY_MODE_UNSPECIFIED,
      gameMode: isSet(object.gameMode) ? gameModeFromJSON(object.gameMode) : GameMode.GAME_MODE_UNSPECIFIED,
    };
  },

  toJSON(message: GetTopRankerRequest): unknown {
    const obj: any = {};
    if (message.profileAddress !== undefined) {
      obj.profileAddress = message.profileAddress;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.playMode !== undefined) {
      obj.playMode = playModeToJSON(message.playMode);
    }
    if (message.gameMode !== undefined) {
      obj.gameMode = gameModeToJSON(message.gameMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTopRankerRequest>, I>>(base?: I): GetTopRankerRequest {
    return GetTopRankerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTopRankerRequest>, I>>(object: I): GetTopRankerRequest {
    const message = createBaseGetTopRankerRequest();
    message.profileAddress = object.profileAddress ?? "";
    message.week = object.week ?? 0;
    message.playMode = object.playMode ?? PlayMode.PLAY_MODE_UNSPECIFIED;
    message.gameMode = object.gameMode ?? GameMode.GAME_MODE_UNSPECIFIED;
    return message;
  },
};

function createBaseRenderTopRankerLeaderboardRequest(): RenderTopRankerLeaderboardRequest {
  return {
    week: 0,
    season: 0,
    playMode: PlayMode.PLAY_MODE_UNSPECIFIED,
    gameMode: GameMode.GAME_MODE_UNSPECIFIED,
    me: "",
  };
}

export const RenderTopRankerLeaderboardRequest: MessageFns<RenderTopRankerLeaderboardRequest> = {
  encode(message: RenderTopRankerLeaderboardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.week !== 0) {
      writer.uint32(8).uint32(message.week);
    }
    if (message.season !== 0) {
      writer.uint32(16).uint32(message.season);
    }
    if (message.playMode !== PlayMode.PLAY_MODE_UNSPECIFIED) {
      writer.uint32(24).int32(playModeToNumber(message.playMode));
    }
    if (message.gameMode !== GameMode.GAME_MODE_UNSPECIFIED) {
      writer.uint32(32).int32(gameModeToNumber(message.gameMode));
    }
    if (message.me !== "") {
      writer.uint32(42).string(message.me);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenderTopRankerLeaderboardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderTopRankerLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.week = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.season = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.playMode = playModeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gameMode = gameModeFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.me = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderTopRankerLeaderboardRequest {
    return {
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
      playMode: isSet(object.playMode) ? playModeFromJSON(object.playMode) : PlayMode.PLAY_MODE_UNSPECIFIED,
      gameMode: isSet(object.gameMode) ? gameModeFromJSON(object.gameMode) : GameMode.GAME_MODE_UNSPECIFIED,
      me: isSet(object.me) ? globalThis.String(object.me) : "",
    };
  },

  toJSON(message: RenderTopRankerLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    if (message.playMode !== undefined) {
      obj.playMode = playModeToJSON(message.playMode);
    }
    if (message.gameMode !== undefined) {
      obj.gameMode = gameModeToJSON(message.gameMode);
    }
    if (message.me !== undefined) {
      obj.me = message.me;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenderTopRankerLeaderboardRequest>, I>>(
    base?: I,
  ): RenderTopRankerLeaderboardRequest {
    return RenderTopRankerLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenderTopRankerLeaderboardRequest>, I>>(
    object: I,
  ): RenderTopRankerLeaderboardRequest {
    const message = createBaseRenderTopRankerLeaderboardRequest();
    message.week = object.week ?? 0;
    message.season = object.season ?? 0;
    message.playMode = object.playMode ?? PlayMode.PLAY_MODE_UNSPECIFIED;
    message.gameMode = object.gameMode ?? GameMode.GAME_MODE_UNSPECIFIED;
    message.me = object.me ?? "";
    return message;
  },
};

function createBaseGetWeeklyTopCollectorLeaderboardRequest(): GetWeeklyTopCollectorLeaderboardRequest {
  return { pageSize: 0, pageToken: "", week: 0, season: 0 };
}

export const GetWeeklyTopCollectorLeaderboardRequest: MessageFns<GetWeeklyTopCollectorLeaderboardRequest> = {
  encode(message: GetWeeklyTopCollectorLeaderboardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.week !== 0) {
      writer.uint32(24).uint32(message.week);
    }
    if (message.season !== 0) {
      writer.uint32(32).uint32(message.season);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWeeklyTopCollectorLeaderboardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyTopCollectorLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.week = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.season = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyTopCollectorLeaderboardRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
    };
  },

  toJSON(message: GetWeeklyTopCollectorLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyTopCollectorLeaderboardRequest>, I>>(
    base?: I,
  ): GetWeeklyTopCollectorLeaderboardRequest {
    return GetWeeklyTopCollectorLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyTopCollectorLeaderboardRequest>, I>>(
    object: I,
  ): GetWeeklyTopCollectorLeaderboardRequest {
    const message = createBaseGetWeeklyTopCollectorLeaderboardRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.week = object.week ?? 0;
    message.season = object.season ?? 0;
    return message;
  },
};

function createBaseGetWeeklyTopCollectorLeaderboardResponse(): GetWeeklyTopCollectorLeaderboardResponse {
  return { topCollectors: [], nextPageToken: "", deadline: undefined };
}

export const GetWeeklyTopCollectorLeaderboardResponse: MessageFns<GetWeeklyTopCollectorLeaderboardResponse> = {
  encode(message: GetWeeklyTopCollectorLeaderboardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topCollectors) {
      StarHunter.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.deadline !== undefined) {
      Timestamp.encode(toTimestamp(message.deadline), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWeeklyTopCollectorLeaderboardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyTopCollectorLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topCollectors.push(StarHunter.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyTopCollectorLeaderboardResponse {
    return {
      topCollectors: globalThis.Array.isArray(object?.topCollectors)
        ? object.topCollectors.map((e: any) => StarHunter.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      deadline: isSet(object.deadline) ? globalThis.String(object.deadline) : undefined,
    };
  },

  toJSON(message: GetWeeklyTopCollectorLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.topCollectors?.length) {
      obj.topCollectors = message.topCollectors.map((e) => StarHunter.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.deadline !== undefined) {
      obj.deadline = message.deadline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyTopCollectorLeaderboardResponse>, I>>(
    base?: I,
  ): GetWeeklyTopCollectorLeaderboardResponse {
    return GetWeeklyTopCollectorLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyTopCollectorLeaderboardResponse>, I>>(
    object: I,
  ): GetWeeklyTopCollectorLeaderboardResponse {
    const message = createBaseGetWeeklyTopCollectorLeaderboardResponse();
    message.topCollectors = object.topCollectors?.map((e) => StarHunter.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.deadline = object.deadline ?? undefined;
    return message;
  },
};

function createBaseGetWeeklyTopCollectorRequest(): GetWeeklyTopCollectorRequest {
  return { profileAddress: "", week: 0 };
}

export const GetWeeklyTopCollectorRequest: MessageFns<GetWeeklyTopCollectorRequest> = {
  encode(message: GetWeeklyTopCollectorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileAddress !== "") {
      writer.uint32(10).string(message.profileAddress);
    }
    if (message.week !== 0) {
      writer.uint32(16).uint32(message.week);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWeeklyTopCollectorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyTopCollectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profileAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.week = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyTopCollectorRequest {
    return {
      profileAddress: isSet(object.profileAddress) ? globalThis.String(object.profileAddress) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
    };
  },

  toJSON(message: GetWeeklyTopCollectorRequest): unknown {
    const obj: any = {};
    if (message.profileAddress !== undefined) {
      obj.profileAddress = message.profileAddress;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyTopCollectorRequest>, I>>(base?: I): GetWeeklyTopCollectorRequest {
    return GetWeeklyTopCollectorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyTopCollectorRequest>, I>>(object: I): GetWeeklyTopCollectorRequest {
    const message = createBaseGetWeeklyTopCollectorRequest();
    message.profileAddress = object.profileAddress ?? "";
    message.week = object.week ?? 0;
    return message;
  },
};

function createBaseGetAllTimeTopCollectorLeaderboardRequest(): GetAllTimeTopCollectorLeaderboardRequest {
  return { pageSize: 0, pageToken: "" };
}

export const GetAllTimeTopCollectorLeaderboardRequest: MessageFns<GetAllTimeTopCollectorLeaderboardRequest> = {
  encode(message: GetAllTimeTopCollectorLeaderboardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllTimeTopCollectorLeaderboardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllTimeTopCollectorLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllTimeTopCollectorLeaderboardRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: GetAllTimeTopCollectorLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllTimeTopCollectorLeaderboardRequest>, I>>(
    base?: I,
  ): GetAllTimeTopCollectorLeaderboardRequest {
    return GetAllTimeTopCollectorLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllTimeTopCollectorLeaderboardRequest>, I>>(
    object: I,
  ): GetAllTimeTopCollectorLeaderboardRequest {
    const message = createBaseGetAllTimeTopCollectorLeaderboardRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseGetAllTimeTopCollectorLeaderboardResponse(): GetAllTimeTopCollectorLeaderboardResponse {
  return { topCollectors: [], nextPageToken: "" };
}

export const GetAllTimeTopCollectorLeaderboardResponse: MessageFns<GetAllTimeTopCollectorLeaderboardResponse> = {
  encode(message: GetAllTimeTopCollectorLeaderboardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topCollectors) {
      StarHunter.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllTimeTopCollectorLeaderboardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllTimeTopCollectorLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topCollectors.push(StarHunter.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllTimeTopCollectorLeaderboardResponse {
    return {
      topCollectors: globalThis.Array.isArray(object?.topCollectors)
        ? object.topCollectors.map((e: any) => StarHunter.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: GetAllTimeTopCollectorLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.topCollectors?.length) {
      obj.topCollectors = message.topCollectors.map((e) => StarHunter.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllTimeTopCollectorLeaderboardResponse>, I>>(
    base?: I,
  ): GetAllTimeTopCollectorLeaderboardResponse {
    return GetAllTimeTopCollectorLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllTimeTopCollectorLeaderboardResponse>, I>>(
    object: I,
  ): GetAllTimeTopCollectorLeaderboardResponse {
    const message = createBaseGetAllTimeTopCollectorLeaderboardResponse();
    message.topCollectors = object.topCollectors?.map((e) => StarHunter.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseRenderWeeklyStarHunterLeaderboardRequest(): RenderWeeklyStarHunterLeaderboardRequest {
  return { week: 0, season: 0, me: "" };
}

export const RenderWeeklyStarHunterLeaderboardRequest: MessageFns<RenderWeeklyStarHunterLeaderboardRequest> = {
  encode(message: RenderWeeklyStarHunterLeaderboardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.week !== 0) {
      writer.uint32(8).uint32(message.week);
    }
    if (message.season !== 0) {
      writer.uint32(16).uint32(message.season);
    }
    if (message.me !== "") {
      writer.uint32(26).string(message.me);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenderWeeklyStarHunterLeaderboardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderWeeklyStarHunterLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.week = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.season = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.me = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderWeeklyStarHunterLeaderboardRequest {
    return {
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
      me: isSet(object.me) ? globalThis.String(object.me) : "",
    };
  },

  toJSON(message: RenderWeeklyStarHunterLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    if (message.me !== undefined) {
      obj.me = message.me;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenderWeeklyStarHunterLeaderboardRequest>, I>>(
    base?: I,
  ): RenderWeeklyStarHunterLeaderboardRequest {
    return RenderWeeklyStarHunterLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenderWeeklyStarHunterLeaderboardRequest>, I>>(
    object: I,
  ): RenderWeeklyStarHunterLeaderboardRequest {
    const message = createBaseRenderWeeklyStarHunterLeaderboardRequest();
    message.week = object.week ?? 0;
    message.season = object.season ?? 0;
    message.me = object.me ?? "";
    return message;
  },
};

function createBaseGetWeeklyStarHunterLeaderboardRequest(): GetWeeklyStarHunterLeaderboardRequest {
  return { pageSize: 0, pageToken: "", week: 0, season: 0 };
}

export const GetWeeklyStarHunterLeaderboardRequest: MessageFns<GetWeeklyStarHunterLeaderboardRequest> = {
  encode(message: GetWeeklyStarHunterLeaderboardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.week !== 0) {
      writer.uint32(24).uint32(message.week);
    }
    if (message.season !== 0) {
      writer.uint32(32).uint32(message.season);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWeeklyStarHunterLeaderboardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyStarHunterLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.week = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.season = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyStarHunterLeaderboardRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
    };
  },

  toJSON(message: GetWeeklyStarHunterLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyStarHunterLeaderboardRequest>, I>>(
    base?: I,
  ): GetWeeklyStarHunterLeaderboardRequest {
    return GetWeeklyStarHunterLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyStarHunterLeaderboardRequest>, I>>(
    object: I,
  ): GetWeeklyStarHunterLeaderboardRequest {
    const message = createBaseGetWeeklyStarHunterLeaderboardRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.week = object.week ?? 0;
    message.season = object.season ?? 0;
    return message;
  },
};

function createBaseGetWeeklyStarHunterLeaderboardResponse(): GetWeeklyStarHunterLeaderboardResponse {
  return { starHunters: [], nextPageToken: "", deadline: undefined };
}

export const GetWeeklyStarHunterLeaderboardResponse: MessageFns<GetWeeklyStarHunterLeaderboardResponse> = {
  encode(message: GetWeeklyStarHunterLeaderboardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.starHunters) {
      StarHunter.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.deadline !== undefined) {
      Timestamp.encode(toTimestamp(message.deadline), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWeeklyStarHunterLeaderboardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyStarHunterLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.starHunters.push(StarHunter.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyStarHunterLeaderboardResponse {
    return {
      starHunters: globalThis.Array.isArray(object?.starHunters)
        ? object.starHunters.map((e: any) => StarHunter.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      deadline: isSet(object.deadline) ? globalThis.String(object.deadline) : undefined,
    };
  },

  toJSON(message: GetWeeklyStarHunterLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.starHunters?.length) {
      obj.starHunters = message.starHunters.map((e) => StarHunter.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.deadline !== undefined) {
      obj.deadline = message.deadline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyStarHunterLeaderboardResponse>, I>>(
    base?: I,
  ): GetWeeklyStarHunterLeaderboardResponse {
    return GetWeeklyStarHunterLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyStarHunterLeaderboardResponse>, I>>(
    object: I,
  ): GetWeeklyStarHunterLeaderboardResponse {
    const message = createBaseGetWeeklyStarHunterLeaderboardResponse();
    message.starHunters = object.starHunters?.map((e) => StarHunter.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.deadline = object.deadline ?? undefined;
    return message;
  },
};

function createBaseGetWeeklyStarHunterRequest(): GetWeeklyStarHunterRequest {
  return { profileAddress: "", week: 0 };
}

export const GetWeeklyStarHunterRequest: MessageFns<GetWeeklyStarHunterRequest> = {
  encode(message: GetWeeklyStarHunterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileAddress !== "") {
      writer.uint32(10).string(message.profileAddress);
    }
    if (message.week !== 0) {
      writer.uint32(16).uint32(message.week);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWeeklyStarHunterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyStarHunterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profileAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.week = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyStarHunterRequest {
    return {
      profileAddress: isSet(object.profileAddress) ? globalThis.String(object.profileAddress) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
    };
  },

  toJSON(message: GetWeeklyStarHunterRequest): unknown {
    const obj: any = {};
    if (message.profileAddress !== undefined) {
      obj.profileAddress = message.profileAddress;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyStarHunterRequest>, I>>(base?: I): GetWeeklyStarHunterRequest {
    return GetWeeklyStarHunterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyStarHunterRequest>, I>>(object: I): GetWeeklyStarHunterRequest {
    const message = createBaseGetWeeklyStarHunterRequest();
    message.profileAddress = object.profileAddress ?? "";
    message.week = object.week ?? 0;
    return message;
  },
};

function createBaseGetAllTimeStarHunterLeaderboardRequest(): GetAllTimeStarHunterLeaderboardRequest {
  return { pageSize: 0, pageToken: "" };
}

export const GetAllTimeStarHunterLeaderboardRequest: MessageFns<GetAllTimeStarHunterLeaderboardRequest> = {
  encode(message: GetAllTimeStarHunterLeaderboardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllTimeStarHunterLeaderboardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllTimeStarHunterLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllTimeStarHunterLeaderboardRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: GetAllTimeStarHunterLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllTimeStarHunterLeaderboardRequest>, I>>(
    base?: I,
  ): GetAllTimeStarHunterLeaderboardRequest {
    return GetAllTimeStarHunterLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllTimeStarHunterLeaderboardRequest>, I>>(
    object: I,
  ): GetAllTimeStarHunterLeaderboardRequest {
    const message = createBaseGetAllTimeStarHunterLeaderboardRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseGetAllTimeStarHunterLeaderboardResponse(): GetAllTimeStarHunterLeaderboardResponse {
  return { starHunters: [], nextPageToken: "" };
}

export const GetAllTimeStarHunterLeaderboardResponse: MessageFns<GetAllTimeStarHunterLeaderboardResponse> = {
  encode(message: GetAllTimeStarHunterLeaderboardResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.starHunters) {
      StarHunter.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllTimeStarHunterLeaderboardResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllTimeStarHunterLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.starHunters.push(StarHunter.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllTimeStarHunterLeaderboardResponse {
    return {
      starHunters: globalThis.Array.isArray(object?.starHunters)
        ? object.starHunters.map((e: any) => StarHunter.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: GetAllTimeStarHunterLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.starHunters?.length) {
      obj.starHunters = message.starHunters.map((e) => StarHunter.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllTimeStarHunterLeaderboardResponse>, I>>(
    base?: I,
  ): GetAllTimeStarHunterLeaderboardResponse {
    return GetAllTimeStarHunterLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllTimeStarHunterLeaderboardResponse>, I>>(
    object: I,
  ): GetAllTimeStarHunterLeaderboardResponse {
    const message = createBaseGetAllTimeStarHunterLeaderboardResponse();
    message.starHunters = object.starHunters?.map((e) => StarHunter.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseImageResponse(): ImageResponse {
  return { image: new Uint8Array(0) };
}

export const ImageResponse: MessageFns<ImageResponse> = {
  encode(message: ImageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image.length !== 0) {
      writer.uint32(10).bytes(message.image);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.image = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageResponse {
    return { image: isSet(object.image) ? bytesFromBase64(object.image) : new Uint8Array(0) };
  },

  toJSON(message: ImageResponse): unknown {
    const obj: any = {};
    if (message.image !== undefined) {
      obj.image = base64FromBytes(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageResponse>, I>>(base?: I): ImageResponse {
    return ImageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageResponse>, I>>(object: I): ImageResponse {
    const message = createBaseImageResponse();
    message.image = object.image ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTopRanker(): TopRanker {
  return { rank: 0, profile: undefined, score: undefined };
}

export const TopRanker: MessageFns<TopRanker> = {
  encode(message: TopRanker, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.profile !== undefined) {
      Profile.encode(message.profile, writer.uint32(18).fork()).join();
    }
    if (message.score !== undefined) {
      Score.encode(message.score, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopRanker {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopRanker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profile = Profile.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.score = Score.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopRanker {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      profile: isSet(object.profile) ? Profile.fromJSON(object.profile) : undefined,
      score: isSet(object.score) ? Score.fromJSON(object.score) : undefined,
    };
  },

  toJSON(message: TopRanker): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.profile !== undefined) {
      obj.profile = Profile.toJSON(message.profile);
    }
    if (message.score !== undefined) {
      obj.score = Score.toJSON(message.score);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopRanker>, I>>(base?: I): TopRanker {
    return TopRanker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopRanker>, I>>(object: I): TopRanker {
    const message = createBaseTopRanker();
    message.rank = object.rank ?? 0;
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? Profile.fromPartial(object.profile)
      : undefined;
    message.score = (object.score !== undefined && object.score !== null) ? Score.fromPartial(object.score) : undefined;
    return message;
  },
};

function createBaseStarHunter(): StarHunter {
  return { rank: 0, profile: undefined, totalStars: 0 };
}

export const StarHunter: MessageFns<StarHunter> = {
  encode(message: StarHunter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.profile !== undefined) {
      Profile.encode(message.profile, writer.uint32(18).fork()).join();
    }
    if (message.totalStars !== 0) {
      writer.uint32(24).uint32(message.totalStars);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StarHunter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStarHunter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profile = Profile.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalStars = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StarHunter {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      profile: isSet(object.profile) ? Profile.fromJSON(object.profile) : undefined,
      totalStars: isSet(object.totalStars) ? globalThis.Number(object.totalStars) : 0,
    };
  },

  toJSON(message: StarHunter): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.profile !== undefined) {
      obj.profile = Profile.toJSON(message.profile);
    }
    if (message.totalStars !== undefined) {
      obj.totalStars = Math.round(message.totalStars);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StarHunter>, I>>(base?: I): StarHunter {
    return StarHunter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StarHunter>, I>>(object: I): StarHunter {
    const message = createBaseStarHunter();
    message.rank = object.rank ?? 0;
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? Profile.fromPartial(object.profile)
      : undefined;
    message.totalStars = object.totalStars ?? 0;
    return message;
  },
};

function createBaseRenderStarHuntersLeaderboardImageRequest(): RenderStarHuntersLeaderboardImageRequest {
  return { starHunters: [], me: undefined };
}

export const RenderStarHuntersLeaderboardImageRequest: MessageFns<RenderStarHuntersLeaderboardImageRequest> = {
  encode(message: RenderStarHuntersLeaderboardImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.starHunters) {
      StarHunterSlim.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.me !== undefined) {
      StarHunterSlim.encode(message.me, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenderStarHuntersLeaderboardImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderStarHuntersLeaderboardImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.starHunters.push(StarHunterSlim.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.me = StarHunterSlim.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderStarHuntersLeaderboardImageRequest {
    return {
      starHunters: globalThis.Array.isArray(object?.starHunters)
        ? object.starHunters.map((e: any) => StarHunterSlim.fromJSON(e))
        : [],
      me: isSet(object.me) ? StarHunterSlim.fromJSON(object.me) : undefined,
    };
  },

  toJSON(message: RenderStarHuntersLeaderboardImageRequest): unknown {
    const obj: any = {};
    if (message.starHunters?.length) {
      obj.starHunters = message.starHunters.map((e) => StarHunterSlim.toJSON(e));
    }
    if (message.me !== undefined) {
      obj.me = StarHunterSlim.toJSON(message.me);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenderStarHuntersLeaderboardImageRequest>, I>>(
    base?: I,
  ): RenderStarHuntersLeaderboardImageRequest {
    return RenderStarHuntersLeaderboardImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenderStarHuntersLeaderboardImageRequest>, I>>(
    object: I,
  ): RenderStarHuntersLeaderboardImageRequest {
    const message = createBaseRenderStarHuntersLeaderboardImageRequest();
    message.starHunters = object.starHunters?.map((e) => StarHunterSlim.fromPartial(e)) || [];
    message.me = (object.me !== undefined && object.me !== null) ? StarHunterSlim.fromPartial(object.me) : undefined;
    return message;
  },
};

function createBaseRenderTopRankerLeaderboardImageRequest(): RenderTopRankerLeaderboardImageRequest {
  return { topRankers: [], me: undefined };
}

export const RenderTopRankerLeaderboardImageRequest: MessageFns<RenderTopRankerLeaderboardImageRequest> = {
  encode(message: RenderTopRankerLeaderboardImageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topRankers) {
      TopRankerSlim.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.me !== undefined) {
      TopRankerSlim.encode(message.me, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenderTopRankerLeaderboardImageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderTopRankerLeaderboardImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topRankers.push(TopRankerSlim.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.me = TopRankerSlim.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderTopRankerLeaderboardImageRequest {
    return {
      topRankers: globalThis.Array.isArray(object?.topRankers)
        ? object.topRankers.map((e: any) => TopRankerSlim.fromJSON(e))
        : [],
      me: isSet(object.me) ? TopRankerSlim.fromJSON(object.me) : undefined,
    };
  },

  toJSON(message: RenderTopRankerLeaderboardImageRequest): unknown {
    const obj: any = {};
    if (message.topRankers?.length) {
      obj.topRankers = message.topRankers.map((e) => TopRankerSlim.toJSON(e));
    }
    if (message.me !== undefined) {
      obj.me = TopRankerSlim.toJSON(message.me);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenderTopRankerLeaderboardImageRequest>, I>>(
    base?: I,
  ): RenderTopRankerLeaderboardImageRequest {
    return RenderTopRankerLeaderboardImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenderTopRankerLeaderboardImageRequest>, I>>(
    object: I,
  ): RenderTopRankerLeaderboardImageRequest {
    const message = createBaseRenderTopRankerLeaderboardImageRequest();
    message.topRankers = object.topRankers?.map((e) => TopRankerSlim.fromPartial(e)) || [];
    message.me = (object.me !== undefined && object.me !== null) ? TopRankerSlim.fromPartial(object.me) : undefined;
    return message;
  },
};

function createBaseStarHunterSlim(): StarHunterSlim {
  return { rank: 0, profile: "", totalStars: 0 };
}

export const StarHunterSlim: MessageFns<StarHunterSlim> = {
  encode(message: StarHunterSlim, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.profile !== "") {
      writer.uint32(18).string(message.profile);
    }
    if (message.totalStars !== 0) {
      writer.uint32(24).uint32(message.totalStars);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StarHunterSlim {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStarHunterSlim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profile = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalStars = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StarHunterSlim {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      profile: isSet(object.profile) ? globalThis.String(object.profile) : "",
      totalStars: isSet(object.totalStars) ? globalThis.Number(object.totalStars) : 0,
    };
  },

  toJSON(message: StarHunterSlim): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.profile !== undefined) {
      obj.profile = message.profile;
    }
    if (message.totalStars !== undefined) {
      obj.totalStars = Math.round(message.totalStars);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StarHunterSlim>, I>>(base?: I): StarHunterSlim {
    return StarHunterSlim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StarHunterSlim>, I>>(object: I): StarHunterSlim {
    const message = createBaseStarHunterSlim();
    message.rank = object.rank ?? 0;
    message.profile = object.profile ?? "";
    message.totalStars = object.totalStars ?? 0;
    return message;
  },
};

function createBaseTopRankerSlim(): TopRankerSlim {
  return { rank: 0, profile: "", scorePoint: 0 };
}

export const TopRankerSlim: MessageFns<TopRankerSlim> = {
  encode(message: TopRankerSlim, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.profile !== "") {
      writer.uint32(18).string(message.profile);
    }
    if (message.scorePoint !== 0) {
      writer.uint32(24).uint32(message.scorePoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopRankerSlim {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopRankerSlim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profile = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.scorePoint = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopRankerSlim {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      profile: isSet(object.profile) ? globalThis.String(object.profile) : "",
      scorePoint: isSet(object.scorePoint) ? globalThis.Number(object.scorePoint) : 0,
    };
  },

  toJSON(message: TopRankerSlim): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.profile !== undefined) {
      obj.profile = message.profile;
    }
    if (message.scorePoint !== undefined) {
      obj.scorePoint = Math.round(message.scorePoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopRankerSlim>, I>>(base?: I): TopRankerSlim {
    return TopRankerSlim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopRankerSlim>, I>>(object: I): TopRankerSlim {
    const message = createBaseTopRankerSlim();
    message.rank = object.rank ?? 0;
    message.profile = object.profile ?? "";
    message.scorePoint = object.scorePoint ?? 0;
    return message;
  },
};

/** LeaderboardService contains the function to get leaderboard */
export type LeaderboardServiceService = typeof LeaderboardServiceService;
export const LeaderboardServiceService = {
  /** GetTopRankerLeaderboard will return best score leaderboard */
  getTopRankerLeaderboard: {
    path: "/ethereum.v1.leaderboard.LeaderboardService/GetTopRankerLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTopRankerLeaderboardRequest) =>
      Buffer.from(GetTopRankerLeaderboardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTopRankerLeaderboardRequest.decode(value),
    responseSerialize: (value: GetTopRankerLeaderboardResponse) =>
      Buffer.from(GetTopRankerLeaderboardResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetTopRankerLeaderboardResponse.decode(value),
  },
  /** GetTopRanker will return weekly top collector. */
  getTopRanker: {
    path: "/ethereum.v1.leaderboard.LeaderboardService/GetTopRanker",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTopRankerRequest) => Buffer.from(GetTopRankerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTopRankerRequest.decode(value),
    responseSerialize: (value: TopRanker) => Buffer.from(TopRanker.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TopRanker.decode(value),
  },
  /** RenderTopRankerLeaderboard will render weekly top collectors image. */
  renderTopRankerLeaderboard: {
    path: "/ethereum.v1.leaderboard.LeaderboardService/RenderTopRankerLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RenderTopRankerLeaderboardRequest) =>
      Buffer.from(RenderTopRankerLeaderboardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RenderTopRankerLeaderboardRequest.decode(value),
    responseSerialize: (value: ImageResponse) => Buffer.from(ImageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ImageResponse.decode(value),
  },
  /** GetWeeklyTopCollectorLeaderboard will return weekly top collectors. */
  getWeeklyTopCollectorLeaderboard: {
    path: "/ethereum.v1.leaderboard.LeaderboardService/GetWeeklyTopCollectorLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWeeklyTopCollectorLeaderboardRequest) =>
      Buffer.from(GetWeeklyTopCollectorLeaderboardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWeeklyTopCollectorLeaderboardRequest.decode(value),
    responseSerialize: (value: GetWeeklyTopCollectorLeaderboardResponse) =>
      Buffer.from(GetWeeklyTopCollectorLeaderboardResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWeeklyTopCollectorLeaderboardResponse.decode(value),
  },
  /** GetWeeklyTopCollector will return weekly top collector. */
  getWeeklyTopCollector: {
    path: "/ethereum.v1.leaderboard.LeaderboardService/GetWeeklyTopCollector",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWeeklyTopCollectorRequest) =>
      Buffer.from(GetWeeklyTopCollectorRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWeeklyTopCollectorRequest.decode(value),
    responseSerialize: (value: StarHunter) => Buffer.from(StarHunter.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StarHunter.decode(value),
  },
  /** RenderWeeklyTopCollectorLeaderboard will render weekly top collectors image. */
  renderWeeklyTopCollectorLeaderboard: {
    path: "/ethereum.v1.leaderboard.LeaderboardService/RenderWeeklyTopCollectorLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RenderWeeklyStarHunterLeaderboardRequest) =>
      Buffer.from(RenderWeeklyStarHunterLeaderboardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RenderWeeklyStarHunterLeaderboardRequest.decode(value),
    responseSerialize: (value: ImageResponse) => Buffer.from(ImageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ImageResponse.decode(value),
  },
  /** GetAllTimeTopCollectorLeaderboard will return all time top collectors. */
  getAllTimeTopCollectorLeaderboard: {
    path: "/ethereum.v1.leaderboard.LeaderboardService/GetAllTimeTopCollectorLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllTimeTopCollectorLeaderboardRequest) =>
      Buffer.from(GetAllTimeTopCollectorLeaderboardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllTimeTopCollectorLeaderboardRequest.decode(value),
    responseSerialize: (value: GetAllTimeTopCollectorLeaderboardResponse) =>
      Buffer.from(GetAllTimeTopCollectorLeaderboardResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllTimeTopCollectorLeaderboardResponse.decode(value),
  },
  /** GetWeeklyStarHunterLeaderboard will return weekly top collectors. */
  getWeeklyStarHunterLeaderboard: {
    path: "/ethereum.v1.leaderboard.LeaderboardService/GetWeeklyStarHunterLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWeeklyStarHunterLeaderboardRequest) =>
      Buffer.from(GetWeeklyStarHunterLeaderboardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWeeklyStarHunterLeaderboardRequest.decode(value),
    responseSerialize: (value: GetWeeklyStarHunterLeaderboardResponse) =>
      Buffer.from(GetWeeklyStarHunterLeaderboardResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWeeklyStarHunterLeaderboardResponse.decode(value),
  },
  /** GetWeeklyStarHunter will return weekly top collector. */
  getWeeklyStarHunter: {
    path: "/ethereum.v1.leaderboard.LeaderboardService/GetWeeklyStarHunter",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWeeklyStarHunterRequest) =>
      Buffer.from(GetWeeklyStarHunterRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWeeklyStarHunterRequest.decode(value),
    responseSerialize: (value: StarHunter) => Buffer.from(StarHunter.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StarHunter.decode(value),
  },
  /** RenderWeeklyStarHunterLeaderboard will render weekly top collectors image. */
  renderWeeklyStarHunterLeaderboard: {
    path: "/ethereum.v1.leaderboard.LeaderboardService/RenderWeeklyStarHunterLeaderboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RenderWeeklyStarHunterLeaderboardRequest) =>
      Buffer.from(RenderWeeklyStarHunterLeaderboardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RenderWeeklyStarHunterLeaderboardRequest.decode(value),
    responseSerialize: (value: ImageResponse) => Buffer.from(ImageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ImageResponse.decode(value),
  },
} as const;

export interface LeaderboardServiceServer extends UntypedServiceImplementation {
  /** GetTopRankerLeaderboard will return best score leaderboard */
  getTopRankerLeaderboard: handleUnaryCall<GetTopRankerLeaderboardRequest, GetTopRankerLeaderboardResponse>;
  /** GetTopRanker will return weekly top collector. */
  getTopRanker: handleUnaryCall<GetTopRankerRequest, TopRanker>;
  /** RenderTopRankerLeaderboard will render weekly top collectors image. */
  renderTopRankerLeaderboard: handleUnaryCall<RenderTopRankerLeaderboardRequest, ImageResponse>;
  /** GetWeeklyTopCollectorLeaderboard will return weekly top collectors. */
  getWeeklyTopCollectorLeaderboard: handleUnaryCall<
    GetWeeklyTopCollectorLeaderboardRequest,
    GetWeeklyTopCollectorLeaderboardResponse
  >;
  /** GetWeeklyTopCollector will return weekly top collector. */
  getWeeklyTopCollector: handleUnaryCall<GetWeeklyTopCollectorRequest, StarHunter>;
  /** RenderWeeklyTopCollectorLeaderboard will render weekly top collectors image. */
  renderWeeklyTopCollectorLeaderboard: handleUnaryCall<RenderWeeklyStarHunterLeaderboardRequest, ImageResponse>;
  /** GetAllTimeTopCollectorLeaderboard will return all time top collectors. */
  getAllTimeTopCollectorLeaderboard: handleUnaryCall<
    GetAllTimeTopCollectorLeaderboardRequest,
    GetAllTimeTopCollectorLeaderboardResponse
  >;
  /** GetWeeklyStarHunterLeaderboard will return weekly top collectors. */
  getWeeklyStarHunterLeaderboard: handleUnaryCall<
    GetWeeklyStarHunterLeaderboardRequest,
    GetWeeklyStarHunterLeaderboardResponse
  >;
  /** GetWeeklyStarHunter will return weekly top collector. */
  getWeeklyStarHunter: handleUnaryCall<GetWeeklyStarHunterRequest, StarHunter>;
  /** RenderWeeklyStarHunterLeaderboard will render weekly top collectors image. */
  renderWeeklyStarHunterLeaderboard: handleUnaryCall<RenderWeeklyStarHunterLeaderboardRequest, ImageResponse>;
}

export interface LeaderboardServiceClient extends Client {
  /** GetTopRankerLeaderboard will return best score leaderboard */
  getTopRankerLeaderboard(
    request: GetTopRankerLeaderboardRequest,
    callback: (error: ServiceError | null, response: GetTopRankerLeaderboardResponse) => void,
  ): ClientUnaryCall;
  getTopRankerLeaderboard(
    request: GetTopRankerLeaderboardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetTopRankerLeaderboardResponse) => void,
  ): ClientUnaryCall;
  getTopRankerLeaderboard(
    request: GetTopRankerLeaderboardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetTopRankerLeaderboardResponse) => void,
  ): ClientUnaryCall;
  /** GetTopRanker will return weekly top collector. */
  getTopRanker(
    request: GetTopRankerRequest,
    callback: (error: ServiceError | null, response: TopRanker) => void,
  ): ClientUnaryCall;
  getTopRanker(
    request: GetTopRankerRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TopRanker) => void,
  ): ClientUnaryCall;
  getTopRanker(
    request: GetTopRankerRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TopRanker) => void,
  ): ClientUnaryCall;
  /** RenderTopRankerLeaderboard will render weekly top collectors image. */
  renderTopRankerLeaderboard(
    request: RenderTopRankerLeaderboardRequest,
    callback: (error: ServiceError | null, response: ImageResponse) => void,
  ): ClientUnaryCall;
  renderTopRankerLeaderboard(
    request: RenderTopRankerLeaderboardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ImageResponse) => void,
  ): ClientUnaryCall;
  renderTopRankerLeaderboard(
    request: RenderTopRankerLeaderboardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ImageResponse) => void,
  ): ClientUnaryCall;
  /** GetWeeklyTopCollectorLeaderboard will return weekly top collectors. */
  getWeeklyTopCollectorLeaderboard(
    request: GetWeeklyTopCollectorLeaderboardRequest,
    callback: (error: ServiceError | null, response: GetWeeklyTopCollectorLeaderboardResponse) => void,
  ): ClientUnaryCall;
  getWeeklyTopCollectorLeaderboard(
    request: GetWeeklyTopCollectorLeaderboardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWeeklyTopCollectorLeaderboardResponse) => void,
  ): ClientUnaryCall;
  getWeeklyTopCollectorLeaderboard(
    request: GetWeeklyTopCollectorLeaderboardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWeeklyTopCollectorLeaderboardResponse) => void,
  ): ClientUnaryCall;
  /** GetWeeklyTopCollector will return weekly top collector. */
  getWeeklyTopCollector(
    request: GetWeeklyTopCollectorRequest,
    callback: (error: ServiceError | null, response: StarHunter) => void,
  ): ClientUnaryCall;
  getWeeklyTopCollector(
    request: GetWeeklyTopCollectorRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StarHunter) => void,
  ): ClientUnaryCall;
  getWeeklyTopCollector(
    request: GetWeeklyTopCollectorRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StarHunter) => void,
  ): ClientUnaryCall;
  /** RenderWeeklyTopCollectorLeaderboard will render weekly top collectors image. */
  renderWeeklyTopCollectorLeaderboard(
    request: RenderWeeklyStarHunterLeaderboardRequest,
    callback: (error: ServiceError | null, response: ImageResponse) => void,
  ): ClientUnaryCall;
  renderWeeklyTopCollectorLeaderboard(
    request: RenderWeeklyStarHunterLeaderboardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ImageResponse) => void,
  ): ClientUnaryCall;
  renderWeeklyTopCollectorLeaderboard(
    request: RenderWeeklyStarHunterLeaderboardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ImageResponse) => void,
  ): ClientUnaryCall;
  /** GetAllTimeTopCollectorLeaderboard will return all time top collectors. */
  getAllTimeTopCollectorLeaderboard(
    request: GetAllTimeTopCollectorLeaderboardRequest,
    callback: (error: ServiceError | null, response: GetAllTimeTopCollectorLeaderboardResponse) => void,
  ): ClientUnaryCall;
  getAllTimeTopCollectorLeaderboard(
    request: GetAllTimeTopCollectorLeaderboardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllTimeTopCollectorLeaderboardResponse) => void,
  ): ClientUnaryCall;
  getAllTimeTopCollectorLeaderboard(
    request: GetAllTimeTopCollectorLeaderboardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllTimeTopCollectorLeaderboardResponse) => void,
  ): ClientUnaryCall;
  /** GetWeeklyStarHunterLeaderboard will return weekly top collectors. */
  getWeeklyStarHunterLeaderboard(
    request: GetWeeklyStarHunterLeaderboardRequest,
    callback: (error: ServiceError | null, response: GetWeeklyStarHunterLeaderboardResponse) => void,
  ): ClientUnaryCall;
  getWeeklyStarHunterLeaderboard(
    request: GetWeeklyStarHunterLeaderboardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWeeklyStarHunterLeaderboardResponse) => void,
  ): ClientUnaryCall;
  getWeeklyStarHunterLeaderboard(
    request: GetWeeklyStarHunterLeaderboardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWeeklyStarHunterLeaderboardResponse) => void,
  ): ClientUnaryCall;
  /** GetWeeklyStarHunter will return weekly top collector. */
  getWeeklyStarHunter(
    request: GetWeeklyStarHunterRequest,
    callback: (error: ServiceError | null, response: StarHunter) => void,
  ): ClientUnaryCall;
  getWeeklyStarHunter(
    request: GetWeeklyStarHunterRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StarHunter) => void,
  ): ClientUnaryCall;
  getWeeklyStarHunter(
    request: GetWeeklyStarHunterRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StarHunter) => void,
  ): ClientUnaryCall;
  /** RenderWeeklyStarHunterLeaderboard will render weekly top collectors image. */
  renderWeeklyStarHunterLeaderboard(
    request: RenderWeeklyStarHunterLeaderboardRequest,
    callback: (error: ServiceError | null, response: ImageResponse) => void,
  ): ClientUnaryCall;
  renderWeeklyStarHunterLeaderboard(
    request: RenderWeeklyStarHunterLeaderboardRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ImageResponse) => void,
  ): ClientUnaryCall;
  renderWeeklyStarHunterLeaderboard(
    request: RenderWeeklyStarHunterLeaderboardRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ImageResponse) => void,
  ): ClientUnaryCall;
}

export const LeaderboardServiceClient = makeGenericClientConstructor(
  LeaderboardServiceService,
  "ethereum.v1.leaderboard.LeaderboardService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): LeaderboardServiceClient;
  service: typeof LeaderboardServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
