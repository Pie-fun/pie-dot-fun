// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: ethereum/v1/outpost/bank.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../../../google/protobuf/timestamp";

/** SymbolType enum represents the symbol of a currency. */
export enum Symbol {
  SYMBOL_UNSPECIFIED = "SYMBOL_UNSPECIFIED",
  /** STAR - STAR */
  STAR = "STAR",
}

export function symbolFromJSON(object: any): Symbol {
  switch (object) {
    case 0:
    case "SYMBOL_UNSPECIFIED":
      return Symbol.SYMBOL_UNSPECIFIED;
    case 1:
    case "STAR":
      return Symbol.STAR;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Symbol");
  }
}

export function symbolToJSON(object: Symbol): string {
  switch (object) {
    case Symbol.SYMBOL_UNSPECIFIED:
      return "SYMBOL_UNSPECIFIED";
    case Symbol.STAR:
      return "STAR";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Symbol");
  }
}

export function symbolToNumber(object: Symbol): number {
  switch (object) {
    case Symbol.SYMBOL_UNSPECIFIED:
      return 0;
    case Symbol.STAR:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Symbol");
  }
}

/** TransferRequest */
export interface TransferRequest {
  /** transfer star token from whom */
  account: string;
  /** transfer star token to whom */
  to: string;
  /** amount of star token to transfer */
  amount: number;
  /**
   * etag determine whether a resource has changed since the last request.
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on requests to ensure the
   * client has an up-to-date value before proceeding.
   * If the ETag does not match, send a 412 Precondition Failed response
   */
  etag: string;
}

/** WithdrawOptimisticRequest */
export interface WithdrawOptimisticRequest {
  /** The account to withdraw from. */
  account: string;
  /** amount of star token to supply */
  amount: number;
}

/** DepositOptimisticRequest */
export interface DepositOptimisticRequest {
  /** The account to deposit star token */
  account: string;
  /** amount of star token to absob */
  amount: number;
}

/** GetStarTokenBalanceRequest */
export interface GetAccountRequest {
  /**
   * The name of the account to retrieve.
   * Format: accounts/{address}
   */
  account: string;
}

/**
 * ListAccountsRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface ListAccountsRequest {
  /**
   * The maximum number of accounts to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListAccounts` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

/**
 * ListAccountsResponse
 * (-- api-linter: core::0158::response-next-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 */
export interface ListAccountsResponse {
  /** The list of rows that matched the query. */
  accounts: Account[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

/** Account message represents a Account. */
export interface Account {
  /**
   * name
   * format: accounts/{address}
   */
  name: string;
  /** The address of the account. */
  address: string;
  /** The balance of the account. */
  balance:
    | Balance
    | undefined;
  /** The list of transactions associated with the account. */
  lastTransactions: Transaction[];
  /**
   * The create time of the account.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  createTime:
    | string
    | undefined;
  /**
   * The update time of the account.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  updateTime: string | undefined;
}

/** Balance message represents a currency. */
export interface Balance {
  /** The currency symbol. */
  symbol: Symbol;
  /** The amount of currency. */
  amount: number;
  /** The cumulative total of currency. */
  cumulativeTotal: number;
}

/** Money message represents a currency. */
export interface Money {
  /** The currency symbol. */
  symbol: Symbol;
  /** The amount of currency. */
  amount: number;
}

/** Transaction message represents a financial transaction. */
export interface Transaction {
  /** The ID of the transaction. */
  id: number;
  /** The type of the transaction. */
  type: Transaction_Type;
  /** The amount of currency involved in the transaction. */
  money:
    | Money
    | undefined;
  /**
   * The destination of the transaction.
   * This field is optional
   */
  recipient?:
    | string
    | undefined;
  /** The create time of the transaction. */
  createTime: string | undefined;
}

/** Type enum represents the type of a transaction. */
export enum Transaction_Type {
  TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
  DEPOSIT = "DEPOSIT",
  WITHDRAWAL = "WITHDRAWAL",
  TRANSFER = "TRANSFER",
}

export function transaction_TypeFromJSON(object: any): Transaction_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Transaction_Type.TYPE_UNSPECIFIED;
    case 1:
    case "DEPOSIT":
      return Transaction_Type.DEPOSIT;
    case 2:
    case "WITHDRAWAL":
      return Transaction_Type.WITHDRAWAL;
    case 3:
    case "TRANSFER":
      return Transaction_Type.TRANSFER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Transaction_Type");
  }
}

export function transaction_TypeToJSON(object: Transaction_Type): string {
  switch (object) {
    case Transaction_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Transaction_Type.DEPOSIT:
      return "DEPOSIT";
    case Transaction_Type.WITHDRAWAL:
      return "WITHDRAWAL";
    case Transaction_Type.TRANSFER:
      return "TRANSFER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Transaction_Type");
  }
}

export function transaction_TypeToNumber(object: Transaction_Type): number {
  switch (object) {
    case Transaction_Type.TYPE_UNSPECIFIED:
      return 0;
    case Transaction_Type.DEPOSIT:
      return 1;
    case Transaction_Type.WITHDRAWAL:
      return 2;
    case Transaction_Type.TRANSFER:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Transaction_Type");
  }
}

function createBaseTransferRequest(): TransferRequest {
  return { account: "", to: "", amount: 0, etag: "" };
}

export const TransferRequest: MessageFns<TransferRequest> = {
  encode(message: TransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint32(message.amount);
    }
    if (message.etag !== "") {
      writer.uint32(34).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.etag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: TransferRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = message.account;
    }
    if (message.to !== undefined) {
      obj.to = message.to;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    if (message.etag !== undefined) {
      obj.etag = message.etag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferRequest>, I>>(base?: I): TransferRequest {
    return TransferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferRequest>, I>>(object: I): TransferRequest {
    const message = createBaseTransferRequest();
    message.account = object.account ?? "";
    message.to = object.to ?? "";
    message.amount = object.amount ?? 0;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseWithdrawOptimisticRequest(): WithdrawOptimisticRequest {
  return { account: "", amount: 0 };
}

export const WithdrawOptimisticRequest: MessageFns<WithdrawOptimisticRequest> = {
  encode(message: WithdrawOptimisticRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint32(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawOptimisticRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawOptimisticRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WithdrawOptimisticRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: WithdrawOptimisticRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = message.account;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WithdrawOptimisticRequest>, I>>(base?: I): WithdrawOptimisticRequest {
    return WithdrawOptimisticRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WithdrawOptimisticRequest>, I>>(object: I): WithdrawOptimisticRequest {
    const message = createBaseWithdrawOptimisticRequest();
    message.account = object.account ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseDepositOptimisticRequest(): DepositOptimisticRequest {
  return { account: "", amount: 0 };
}

export const DepositOptimisticRequest: MessageFns<DepositOptimisticRequest> = {
  encode(message: DepositOptimisticRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint32(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepositOptimisticRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepositOptimisticRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepositOptimisticRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: DepositOptimisticRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = message.account;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DepositOptimisticRequest>, I>>(base?: I): DepositOptimisticRequest {
    return DepositOptimisticRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DepositOptimisticRequest>, I>>(object: I): DepositOptimisticRequest {
    const message = createBaseDepositOptimisticRequest();
    message.account = object.account ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseGetAccountRequest(): GetAccountRequest {
  return { account: "" };
}

export const GetAccountRequest: MessageFns<GetAccountRequest> = {
  encode(message: GetAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountRequest {
    return { account: isSet(object.account) ? globalThis.String(object.account) : "" };
  },

  toJSON(message: GetAccountRequest): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = message.account;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAccountRequest>, I>>(base?: I): GetAccountRequest {
    return GetAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAccountRequest>, I>>(object: I): GetAccountRequest {
    const message = createBaseGetAccountRequest();
    message.account = object.account ?? "";
    return message;
  },
};

function createBaseListAccountsRequest(): ListAccountsRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListAccountsRequest: MessageFns<ListAccountsRequest> = {
  encode(message: ListAccountsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAccountsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAccountsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAccountsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAccountsRequest>, I>>(base?: I): ListAccountsRequest {
    return ListAccountsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAccountsRequest>, I>>(object: I): ListAccountsRequest {
    const message = createBaseListAccountsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAccountsResponse(): ListAccountsResponse {
  return { accounts: [], nextPageToken: "" };
}

export const ListAccountsResponse: MessageFns<ListAccountsResponse> = {
  encode(message: ListAccountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      Account.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAccountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAccountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(Account.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAccountsResponse {
    return {
      accounts: globalThis.Array.isArray(object?.accounts) ? object.accounts.map((e: any) => Account.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAccountsResponse): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => Account.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAccountsResponse>, I>>(base?: I): ListAccountsResponse {
    return ListAccountsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAccountsResponse>, I>>(object: I): ListAccountsResponse {
    const message = createBaseListAccountsResponse();
    message.accounts = object.accounts?.map((e) => Account.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseAccount(): Account {
  return {
    name: "",
    address: "",
    balance: undefined,
    lastTransactions: [],
    createTime: undefined,
    updateTime: undefined,
  };
}

export const Account: MessageFns<Account> = {
  encode(message: Account, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.balance !== undefined) {
      Balance.encode(message.balance, writer.uint32(34).fork()).join();
    }
    for (const v of message.lastTransactions) {
      Transaction.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Account {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.balance = Balance.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastTransactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Account {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      balance: isSet(object.balance) ? Balance.fromJSON(object.balance) : undefined,
      lastTransactions: globalThis.Array.isArray(object?.lastTransactions)
        ? object.lastTransactions.map((e: any) => Transaction.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? globalThis.String(object.updateTime) : undefined,
    };
  },

  toJSON(message: Account): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.balance !== undefined) {
      obj.balance = Balance.toJSON(message.balance);
    }
    if (message.lastTransactions?.length) {
      obj.lastTransactions = message.lastTransactions.map((e) => Transaction.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account>, I>>(base?: I): Account {
    return Account.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account>, I>>(object: I): Account {
    const message = createBaseAccount();
    message.name = object.name ?? "";
    message.address = object.address ?? "";
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Balance.fromPartial(object.balance)
      : undefined;
    message.lastTransactions = object.lastTransactions?.map((e) => Transaction.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseBalance(): Balance {
  return { symbol: Symbol.SYMBOL_UNSPECIFIED, amount: 0, cumulativeTotal: 0 };
}

export const Balance: MessageFns<Balance> = {
  encode(message: Balance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== Symbol.SYMBOL_UNSPECIFIED) {
      writer.uint32(8).int32(symbolToNumber(message.symbol));
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint32(message.amount);
    }
    if (message.cumulativeTotal !== 0) {
      writer.uint32(24).uint32(message.cumulativeTotal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Balance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.symbol = symbolFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cumulativeTotal = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Balance {
    return {
      symbol: isSet(object.symbol) ? symbolFromJSON(object.symbol) : Symbol.SYMBOL_UNSPECIFIED,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      cumulativeTotal: isSet(object.cumulativeTotal) ? globalThis.Number(object.cumulativeTotal) : 0,
    };
  },

  toJSON(message: Balance): unknown {
    const obj: any = {};
    if (message.symbol !== undefined) {
      obj.symbol = symbolToJSON(message.symbol);
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    if (message.cumulativeTotal !== undefined) {
      obj.cumulativeTotal = Math.round(message.cumulativeTotal);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Balance>, I>>(base?: I): Balance {
    return Balance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Balance>, I>>(object: I): Balance {
    const message = createBaseBalance();
    message.symbol = object.symbol ?? Symbol.SYMBOL_UNSPECIFIED;
    message.amount = object.amount ?? 0;
    message.cumulativeTotal = object.cumulativeTotal ?? 0;
    return message;
  },
};

function createBaseMoney(): Money {
  return { symbol: Symbol.SYMBOL_UNSPECIFIED, amount: 0 };
}

export const Money: MessageFns<Money> = {
  encode(message: Money, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== Symbol.SYMBOL_UNSPECIFIED) {
      writer.uint32(8).int32(symbolToNumber(message.symbol));
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint32(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Money {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.symbol = symbolFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Money {
    return {
      symbol: isSet(object.symbol) ? symbolFromJSON(object.symbol) : Symbol.SYMBOL_UNSPECIFIED,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: Money): unknown {
    const obj: any = {};
    if (message.symbol !== undefined) {
      obj.symbol = symbolToJSON(message.symbol);
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Money>, I>>(base?: I): Money {
    return Money.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Money>, I>>(object: I): Money {
    const message = createBaseMoney();
    message.symbol = object.symbol ?? Symbol.SYMBOL_UNSPECIFIED;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    id: 0,
    type: Transaction_Type.TYPE_UNSPECIFIED,
    money: undefined,
    recipient: undefined,
    createTime: undefined,
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.type !== Transaction_Type.TYPE_UNSPECIFIED) {
      writer.uint32(16).int32(transaction_TypeToNumber(message.type));
    }
    if (message.money !== undefined) {
      Money.encode(message.money, writer.uint32(26).fork()).join();
    }
    if (message.recipient !== undefined) {
      writer.uint32(34).string(message.recipient);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = transaction_TypeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.money = Money.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.recipient = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      type: isSet(object.type) ? transaction_TypeFromJSON(object.type) : Transaction_Type.TYPE_UNSPECIFIED,
      money: isSet(object.money) ? Money.fromJSON(object.money) : undefined,
      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : undefined,
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== undefined) {
      obj.type = transaction_TypeToJSON(message.type);
    }
    if (message.money !== undefined) {
      obj.money = Money.toJSON(message.money);
    }
    if (message.recipient !== undefined) {
      obj.recipient = message.recipient;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.id = object.id ?? 0;
    message.type = object.type ?? Transaction_Type.TYPE_UNSPECIFIED;
    message.money = (object.money !== undefined && object.money !== null) ? Money.fromPartial(object.money) : undefined;
    message.recipient = object.recipient ?? undefined;
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

/** BankService contains the function to interact with the StarToken of the spacebar */
export type BankServiceService = typeof BankServiceService;
export const BankServiceService = {
  depositStarTokenOptimistic: {
    path: "/ethereum.v1.outpost.BankService/DepositStarTokenOptimistic",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DepositOptimisticRequest) => Buffer.from(DepositOptimisticRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DepositOptimisticRequest.decode(value),
    responseSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Account.decode(value),
  },
  withdrawStarTokenOptimistic: {
    path: "/ethereum.v1.outpost.BankService/WithdrawStarTokenOptimistic",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WithdrawOptimisticRequest) =>
      Buffer.from(WithdrawOptimisticRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WithdrawOptimisticRequest.decode(value),
    responseSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Account.decode(value),
  },
  getAccount: {
    path: "/ethereum.v1.outpost.BankService/GetAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAccountRequest) => Buffer.from(GetAccountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAccountRequest.decode(value),
    responseSerialize: (value: Account) => Buffer.from(Account.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Account.decode(value),
  },
  listAccounts: {
    path: "/ethereum.v1.outpost.BankService/ListAccounts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAccountsRequest) => Buffer.from(ListAccountsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListAccountsRequest.decode(value),
    responseSerialize: (value: ListAccountsResponse) => Buffer.from(ListAccountsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListAccountsResponse.decode(value),
  },
} as const;

export interface BankServiceServer extends UntypedServiceImplementation {
  depositStarTokenOptimistic: handleUnaryCall<DepositOptimisticRequest, Account>;
  withdrawStarTokenOptimistic: handleUnaryCall<WithdrawOptimisticRequest, Account>;
  getAccount: handleUnaryCall<GetAccountRequest, Account>;
  listAccounts: handleUnaryCall<ListAccountsRequest, ListAccountsResponse>;
}

export interface BankServiceClient extends Client {
  depositStarTokenOptimistic(
    request: DepositOptimisticRequest,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  depositStarTokenOptimistic(
    request: DepositOptimisticRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  depositStarTokenOptimistic(
    request: DepositOptimisticRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  withdrawStarTokenOptimistic(
    request: WithdrawOptimisticRequest,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  withdrawStarTokenOptimistic(
    request: WithdrawOptimisticRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  withdrawStarTokenOptimistic(
    request: WithdrawOptimisticRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  getAccount(
    request: GetAccountRequest,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  getAccount(
    request: GetAccountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  getAccount(
    request: GetAccountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Account) => void,
  ): ClientUnaryCall;
  listAccounts(
    request: ListAccountsRequest,
    callback: (error: ServiceError | null, response: ListAccountsResponse) => void,
  ): ClientUnaryCall;
  listAccounts(
    request: ListAccountsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListAccountsResponse) => void,
  ): ClientUnaryCall;
  listAccounts(
    request: ListAccountsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListAccountsResponse) => void,
  ): ClientUnaryCall;
}

export const BankServiceClient = makeGenericClientConstructor(
  BankServiceService,
  "ethereum.v1.outpost.BankService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): BankServiceClient;
  service: typeof BankServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
