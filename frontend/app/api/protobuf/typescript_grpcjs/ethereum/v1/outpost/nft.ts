// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: ethereum/v1/outpost/nft.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

/**
 * ChainType enumeration represents the type of blockchain.
 * Does not support optimism, zksync, bsc yet
 */
export enum ChainType {
  /** CHAIN_UNSPECIFIED - Unspecified blockchain type. */
  CHAIN_UNSPECIFIED = "CHAIN_UNSPECIFIED",
  /** ETHEREUM - Ethereum Mainnet blockchain. */
  ETHEREUM = "ETHEREUM",
  /** POLYGON - Polygon Mainnet blockchain. */
  POLYGON = "POLYGON",
  /** ARBITRUM - Arbitrum Mainnet blockchain. */
  ARBITRUM = "ARBITRUM",
  /** OPTIMISM - Optimism Mainnet blockchain. */
  OPTIMISM = "OPTIMISM",
  /** BASE - Base Mainnet blockchain. */
  BASE = "BASE",
  /** BLAST - Blast Mainnet blockchain. */
  BLAST = "BLAST",
  /** ETHEREUM_SEPOLIA - Sepolia Testnet blockchain. */
  ETHEREUM_SEPOLIA = "ETHEREUM_SEPOLIA",
  /** POLYGON_MUMBAI - Polygon Testnet blockchain. */
  POLYGON_MUMBAI = "POLYGON_MUMBAI",
  /** BLAST_SEPOLIA - Blast Testnet blockchain. */
  BLAST_SEPOLIA = "BLAST_SEPOLIA",
}

export function chainTypeFromJSON(object: any): ChainType {
  switch (object) {
    case 0:
    case "CHAIN_UNSPECIFIED":
      return ChainType.CHAIN_UNSPECIFIED;
    case 1:
    case "ETHEREUM":
      return ChainType.ETHEREUM;
    case 137:
    case "POLYGON":
      return ChainType.POLYGON;
    case 42161:
    case "ARBITRUM":
      return ChainType.ARBITRUM;
    case 10:
    case "OPTIMISM":
      return ChainType.OPTIMISM;
    case 8453:
    case "BASE":
      return ChainType.BASE;
    case 81457:
    case "BLAST":
      return ChainType.BLAST;
    case 11155111:
    case "ETHEREUM_SEPOLIA":
      return ChainType.ETHEREUM_SEPOLIA;
    case 80001:
    case "POLYGON_MUMBAI":
      return ChainType.POLYGON_MUMBAI;
    case 168587773:
    case "BLAST_SEPOLIA":
      return ChainType.BLAST_SEPOLIA;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ChainType");
  }
}

export function chainTypeToJSON(object: ChainType): string {
  switch (object) {
    case ChainType.CHAIN_UNSPECIFIED:
      return "CHAIN_UNSPECIFIED";
    case ChainType.ETHEREUM:
      return "ETHEREUM";
    case ChainType.POLYGON:
      return "POLYGON";
    case ChainType.ARBITRUM:
      return "ARBITRUM";
    case ChainType.OPTIMISM:
      return "OPTIMISM";
    case ChainType.BASE:
      return "BASE";
    case ChainType.BLAST:
      return "BLAST";
    case ChainType.ETHEREUM_SEPOLIA:
      return "ETHEREUM_SEPOLIA";
    case ChainType.POLYGON_MUMBAI:
      return "POLYGON_MUMBAI";
    case ChainType.BLAST_SEPOLIA:
      return "BLAST_SEPOLIA";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ChainType");
  }
}

export function chainTypeToNumber(object: ChainType): number {
  switch (object) {
    case ChainType.CHAIN_UNSPECIFIED:
      return 0;
    case ChainType.ETHEREUM:
      return 1;
    case ChainType.POLYGON:
      return 137;
    case ChainType.ARBITRUM:
      return 42161;
    case ChainType.OPTIMISM:
      return 10;
    case ChainType.BASE:
      return 8453;
    case ChainType.BLAST:
      return 81457;
    case ChainType.ETHEREUM_SEPOLIA:
      return 11155111;
    case ChainType.POLYGON_MUMBAI:
      return 80001;
    case ChainType.BLAST_SEPOLIA:
      return 168587773;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ChainType");
  }
}

export enum ContractType {
  /** CONTRACT_TYPE_UNSPECIFIED - Unspecified contract type. */
  CONTRACT_TYPE_UNSPECIFIED = "CONTRACT_TYPE_UNSPECIFIED",
  /** ERC721 - ERC721 contract type. */
  ERC721 = "ERC721",
  /** ERC1155 - ERC1155 contract type. */
  ERC1155 = "ERC1155",
}

export function contractTypeFromJSON(object: any): ContractType {
  switch (object) {
    case 0:
    case "CONTRACT_TYPE_UNSPECIFIED":
      return ContractType.CONTRACT_TYPE_UNSPECIFIED;
    case 1:
    case "ERC721":
      return ContractType.ERC721;
    case 2:
    case "ERC1155":
      return ContractType.ERC1155;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ContractType");
  }
}

export function contractTypeToJSON(object: ContractType): string {
  switch (object) {
    case ContractType.CONTRACT_TYPE_UNSPECIFIED:
      return "CONTRACT_TYPE_UNSPECIFIED";
    case ContractType.ERC721:
      return "ERC721";
    case ContractType.ERC1155:
      return "ERC1155";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ContractType");
  }
}

export function contractTypeToNumber(object: ContractType): number {
  switch (object) {
    case ContractType.CONTRACT_TYPE_UNSPECIFIED:
      return 0;
    case ContractType.ERC721:
      return 1;
    case ContractType.ERC1155:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ContractType");
  }
}

/**
 * ListNFTsRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface ListNFTsRequest {
  /**
   * The owner address of the profile.
   * This field is required if `sync_onchain` is true.
   * When `sync_onchain` is true, only EOA address is supported.
   */
  ownerAddress: string;
  /**
   * The maximum number of nfts to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When page token is not specified, nft assets are synced with the blockchain. If
   * page token is specified, nft assets are not synced with the blockchain and retrieved from the database.
   *
   * The page token is valid for only 2 hours.
   *
   * When paginating, all other parameters provided to `ListNFTs` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Available Sequence and Operator
   * * name
   *   * `equal`
   * * has_image
   *   * `negation`
   * * address
   *   * `equal`
   * * contract.address
   *   * `equal`
   * * contract.display_name
   *   * `equal`
   * * contract.chain
   *   * supported value is [ETHEREUM, POLYGON, ARBITRUM, OPTIMISM, BASE, STARKNET, ETHEREUM_SEPOLIA, POLYGON_MUMBAI]
   *   * `equal`
   * * contract.type
   *   * `equal`
   *
   * Examples
   * * filter=name="nfts/MUMBAI/0xb4Afd0Ecb77460f0d8F93E7Fba93D7c18491f7a3/424"
   * * filter=has_image
   * * filter=address="0xa3d8090e4ea02d4cc76ecb2e8b09ab140cd11dee"
   * * filter=contract.address="0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d"
   * * filter=contract.display_name="CryptoKitties"
   * * filter=contract.chain=ETHEREUM
   * * filter=contract.type=ERC721
   */
  filter: string;
  /**
   * Supported value is ["true", "1", "yes", "y"], other then all this value will be treated as false.
   * If true, the service will fetch assets using third party NFT APIs.
   */
  syncOnchain: string;
}

/**
 * ListNFTsResponse response
 * (-- api-linter: core::0158::response-next-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 */
export interface ListNFTsResponse {
  /** The list of rows that matched the query. */
  nfts: NFT[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

/** ListNFTsDelegateRequest */
export interface ListNFTsDelegateRequest {
  /**
   * The owner address of the profile.
   * This field is required if `sync_onchain` is true.
   * When `sync_onchain` is true, only EOA address is supported.
   */
  ownerAddress: string;
}

/** ListNFTsDelegateRequest */
export interface ListNFTsDelegateResponse {
  /** The list of rows that matched the query. */
  nfts: NFT[];
}

/** GetNFTRequest */
export interface GetNFTRequest {
  /**
   * The resource name of the nft to retrieve.
   * Format: nfts/{chain_type}/{contract_address}/{token_id}
   * Examples: nfts/ETHEREUM/0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326/1
   */
  nft: string;
}

/** ValidateNFTAccessRequest */
export interface ValidateNFTAccessRequest {
  /**
   * The resource name of the nft to retrieve.
   * Format: nfts/{chain_type}/{contract_address}/{token_id}
   * Examples: nfts/ETHEREUM/0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326/1
   */
  nft: string;
  /** The owner address of the NFT asset. */
  ownerAddress: string;
}

export interface ValidateNFTAccessResponse {
  nft: NFT | undefined;
  access: boolean;
}

export interface ListOwnersRequest {
  nfts: string[];
}

export interface ListOwnersResponse {
  owners: { [key: string]: ListOwnersResponse_NFTs };
}

export interface ListOwnersResponse_NFTs {
  nfts: string[];
}

export interface ListOwnersResponse_OwnersEntry {
  key: string;
  value: ListOwnersResponse_NFTs | undefined;
}

/** ValidateNFTRequest */
export interface ValidateNFTRequest {
  /**
   * The resource name of the nft to retrieve.
   * Format: nfts/{chain_type}/{contract_address}/{token_id}
   * Examples: nfts/ETHEREUM/0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326/1
   */
  nft: string;
}

export interface ValidateNFTResponse {
  valid: boolean;
}

export interface GetContractRequest {
  /**
   * The resource name of the nft contract to retrieve.
   * Format: nfts/{chain_type}/{contract_address}
   * Examples: nfts/ETHEREUM/0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326
   */
  nftContract: string;
}

export interface CheckHolderOfContractRequest {
  /**
   * The resource name of the nft contract to retrieve.
   * Format: nfts/{chain_type}/{contract_address}
   * Examples: nfts/ETHEREUM/0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326
   */
  nftContract: string;
  walletAddress: string;
}

export interface CheckHolderOfContractResponse {
  isHolder: boolean;
}

/** NFT message represents an NFT asset. */
export interface NFT {
  /**
   * The resource name of the NFT asset.
   * Format: nfts/{chain_type}/{contract_address}/{token_id}
   * Examples: nfts/ETHEREUM/0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326/1
   */
  name: string;
  /** EIP-6551 TBA Address of the NFT asset. */
  address: string;
  /** Token ID of the NFT asset. */
  tokenId: string;
  /** Token Name of the NFT asset. */
  tokenName: string;
  /**
   * The URI of the NFT asset's image.
   * This URI can be cached version of image original URI
   * e.g. "https://i.seadn.io/gcs/files/f3564ef33373939b024fb791f21ec37b.png?w=500&auto=format"
   */
  imageUri: string;
  /**
   * The URI of the NFT asset's original image.
   * e.g. "https://www.larvalabs.com/cryptopunks/cryptopunk1.png"
   */
  imageOriginalUri: string;
  /**
   * The URI of the NFT asset's animation.
   * This URI can be cached version of animation original URI
   * This field is optional
   */
  animationUri?:
    | string
    | undefined;
  /**
   * The URI of the NFT asset's original animation.
   * This field is optional
   */
  animationOriginalUri?:
    | string
    | undefined;
  /** Additional metadata about the NFT asset. */
  metadataUri: string;
  /**
   * The owner address of the NFT asset.
   * This field is optional
   */
  ownerAddress?:
    | string
    | undefined;
  /**
   * The contract that owns the NFT asset.
   * Output only.
   */
  contract: NFTContract | undefined;
}

/** NFTContract message represents an NFT contract. */
export interface NFTContract {
  /**
   * The resource name of the nft contract.
   * Format: nfts/{chain_type}/{contract_address}
   * Examples: nfts/ETHEREUM/0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326
   */
  name: string;
  /** The address of the NFT contract. */
  address: string;
  /** The display name of the NFT contract. */
  displayName: string;
  /** The symbol of the NFT contract. */
  symbol: string;
  /** The blockchain on which the NFT contract resides. */
  chain: ChainType;
  /** The type of the NFT contract. */
  type: ContractType;
  /** The URI of the contract image */
  imageUri: string;
}

function createBaseListNFTsRequest(): ListNFTsRequest {
  return { ownerAddress: "", pageSize: 0, pageToken: "", filter: "", syncOnchain: "" };
}

export const ListNFTsRequest: MessageFns<ListNFTsRequest> = {
  encode(message: ListNFTsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.syncOnchain !== "") {
      writer.uint32(42).string(message.syncOnchain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNFTsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNFTsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.syncOnchain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNFTsRequest {
    return {
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      syncOnchain: isSet(object.syncOnchain) ? globalThis.String(object.syncOnchain) : "",
    };
  },

  toJSON(message: ListNFTsRequest): unknown {
    const obj: any = {};
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    if (message.syncOnchain !== undefined) {
      obj.syncOnchain = message.syncOnchain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNFTsRequest>, I>>(base?: I): ListNFTsRequest {
    return ListNFTsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNFTsRequest>, I>>(object: I): ListNFTsRequest {
    const message = createBaseListNFTsRequest();
    message.ownerAddress = object.ownerAddress ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.syncOnchain = object.syncOnchain ?? "";
    return message;
  },
};

function createBaseListNFTsResponse(): ListNFTsResponse {
  return { nfts: [], nextPageToken: "" };
}

export const ListNFTsResponse: MessageFns<ListNFTsResponse> = {
  encode(message: ListNFTsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nfts) {
      NFT.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNFTsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNFTsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nfts.push(NFT.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNFTsResponse {
    return {
      nfts: globalThis.Array.isArray(object?.nfts) ? object.nfts.map((e: any) => NFT.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListNFTsResponse): unknown {
    const obj: any = {};
    if (message.nfts?.length) {
      obj.nfts = message.nfts.map((e) => NFT.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNFTsResponse>, I>>(base?: I): ListNFTsResponse {
    return ListNFTsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNFTsResponse>, I>>(object: I): ListNFTsResponse {
    const message = createBaseListNFTsResponse();
    message.nfts = object.nfts?.map((e) => NFT.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListNFTsDelegateRequest(): ListNFTsDelegateRequest {
  return { ownerAddress: "" };
}

export const ListNFTsDelegateRequest: MessageFns<ListNFTsDelegateRequest> = {
  encode(message: ListNFTsDelegateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNFTsDelegateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNFTsDelegateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNFTsDelegateRequest {
    return { ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "" };
  },

  toJSON(message: ListNFTsDelegateRequest): unknown {
    const obj: any = {};
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNFTsDelegateRequest>, I>>(base?: I): ListNFTsDelegateRequest {
    return ListNFTsDelegateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNFTsDelegateRequest>, I>>(object: I): ListNFTsDelegateRequest {
    const message = createBaseListNFTsDelegateRequest();
    message.ownerAddress = object.ownerAddress ?? "";
    return message;
  },
};

function createBaseListNFTsDelegateResponse(): ListNFTsDelegateResponse {
  return { nfts: [] };
}

export const ListNFTsDelegateResponse: MessageFns<ListNFTsDelegateResponse> = {
  encode(message: ListNFTsDelegateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nfts) {
      NFT.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNFTsDelegateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNFTsDelegateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nfts.push(NFT.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNFTsDelegateResponse {
    return { nfts: globalThis.Array.isArray(object?.nfts) ? object.nfts.map((e: any) => NFT.fromJSON(e)) : [] };
  },

  toJSON(message: ListNFTsDelegateResponse): unknown {
    const obj: any = {};
    if (message.nfts?.length) {
      obj.nfts = message.nfts.map((e) => NFT.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNFTsDelegateResponse>, I>>(base?: I): ListNFTsDelegateResponse {
    return ListNFTsDelegateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNFTsDelegateResponse>, I>>(object: I): ListNFTsDelegateResponse {
    const message = createBaseListNFTsDelegateResponse();
    message.nfts = object.nfts?.map((e) => NFT.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetNFTRequest(): GetNFTRequest {
  return { nft: "" };
}

export const GetNFTRequest: MessageFns<GetNFTRequest> = {
  encode(message: GetNFTRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nft !== "") {
      writer.uint32(10).string(message.nft);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNFTRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNFTRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nft = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNFTRequest {
    return { nft: isSet(object.nft) ? globalThis.String(object.nft) : "" };
  },

  toJSON(message: GetNFTRequest): unknown {
    const obj: any = {};
    if (message.nft !== undefined) {
      obj.nft = message.nft;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNFTRequest>, I>>(base?: I): GetNFTRequest {
    return GetNFTRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNFTRequest>, I>>(object: I): GetNFTRequest {
    const message = createBaseGetNFTRequest();
    message.nft = object.nft ?? "";
    return message;
  },
};

function createBaseValidateNFTAccessRequest(): ValidateNFTAccessRequest {
  return { nft: "", ownerAddress: "" };
}

export const ValidateNFTAccessRequest: MessageFns<ValidateNFTAccessRequest> = {
  encode(message: ValidateNFTAccessRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nft !== "") {
      writer.uint32(10).string(message.nft);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(18).string(message.ownerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateNFTAccessRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateNFTAccessRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nft = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateNFTAccessRequest {
    return {
      nft: isSet(object.nft) ? globalThis.String(object.nft) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
    };
  },

  toJSON(message: ValidateNFTAccessRequest): unknown {
    const obj: any = {};
    if (message.nft !== undefined) {
      obj.nft = message.nft;
    }
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateNFTAccessRequest>, I>>(base?: I): ValidateNFTAccessRequest {
    return ValidateNFTAccessRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateNFTAccessRequest>, I>>(object: I): ValidateNFTAccessRequest {
    const message = createBaseValidateNFTAccessRequest();
    message.nft = object.nft ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    return message;
  },
};

function createBaseValidateNFTAccessResponse(): ValidateNFTAccessResponse {
  return { nft: undefined, access: false };
}

export const ValidateNFTAccessResponse: MessageFns<ValidateNFTAccessResponse> = {
  encode(message: ValidateNFTAccessResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nft !== undefined) {
      NFT.encode(message.nft, writer.uint32(10).fork()).join();
    }
    if (message.access !== false) {
      writer.uint32(16).bool(message.access);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateNFTAccessResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateNFTAccessResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nft = NFT.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.access = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateNFTAccessResponse {
    return {
      nft: isSet(object.nft) ? NFT.fromJSON(object.nft) : undefined,
      access: isSet(object.access) ? globalThis.Boolean(object.access) : false,
    };
  },

  toJSON(message: ValidateNFTAccessResponse): unknown {
    const obj: any = {};
    if (message.nft !== undefined) {
      obj.nft = NFT.toJSON(message.nft);
    }
    if (message.access !== undefined) {
      obj.access = message.access;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateNFTAccessResponse>, I>>(base?: I): ValidateNFTAccessResponse {
    return ValidateNFTAccessResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateNFTAccessResponse>, I>>(object: I): ValidateNFTAccessResponse {
    const message = createBaseValidateNFTAccessResponse();
    message.nft = (object.nft !== undefined && object.nft !== null) ? NFT.fromPartial(object.nft) : undefined;
    message.access = object.access ?? false;
    return message;
  },
};

function createBaseListOwnersRequest(): ListOwnersRequest {
  return { nfts: [] };
}

export const ListOwnersRequest: MessageFns<ListOwnersRequest> = {
  encode(message: ListOwnersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nfts) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOwnersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOwnersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nfts.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOwnersRequest {
    return { nfts: globalThis.Array.isArray(object?.nfts) ? object.nfts.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ListOwnersRequest): unknown {
    const obj: any = {};
    if (message.nfts?.length) {
      obj.nfts = message.nfts;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOwnersRequest>, I>>(base?: I): ListOwnersRequest {
    return ListOwnersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOwnersRequest>, I>>(object: I): ListOwnersRequest {
    const message = createBaseListOwnersRequest();
    message.nfts = object.nfts?.map((e) => e) || [];
    return message;
  },
};

function createBaseListOwnersResponse(): ListOwnersResponse {
  return { owners: {} };
}

export const ListOwnersResponse: MessageFns<ListOwnersResponse> = {
  encode(message: ListOwnersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.owners).forEach(([key, value]) => {
      ListOwnersResponse_OwnersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOwnersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOwnersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = ListOwnersResponse_OwnersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.owners[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOwnersResponse {
    return {
      owners: isObject(object.owners)
        ? Object.entries(object.owners).reduce<{ [key: string]: ListOwnersResponse_NFTs }>((acc, [key, value]) => {
          acc[key] = ListOwnersResponse_NFTs.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ListOwnersResponse): unknown {
    const obj: any = {};
    if (message.owners) {
      const entries = Object.entries(message.owners);
      if (entries.length > 0) {
        obj.owners = {};
        entries.forEach(([k, v]) => {
          obj.owners[k] = ListOwnersResponse_NFTs.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOwnersResponse>, I>>(base?: I): ListOwnersResponse {
    return ListOwnersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOwnersResponse>, I>>(object: I): ListOwnersResponse {
    const message = createBaseListOwnersResponse();
    message.owners = Object.entries(object.owners ?? {}).reduce<{ [key: string]: ListOwnersResponse_NFTs }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ListOwnersResponse_NFTs.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseListOwnersResponse_NFTs(): ListOwnersResponse_NFTs {
  return { nfts: [] };
}

export const ListOwnersResponse_NFTs: MessageFns<ListOwnersResponse_NFTs> = {
  encode(message: ListOwnersResponse_NFTs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nfts) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOwnersResponse_NFTs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOwnersResponse_NFTs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nfts.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOwnersResponse_NFTs {
    return { nfts: globalThis.Array.isArray(object?.nfts) ? object.nfts.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ListOwnersResponse_NFTs): unknown {
    const obj: any = {};
    if (message.nfts?.length) {
      obj.nfts = message.nfts;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOwnersResponse_NFTs>, I>>(base?: I): ListOwnersResponse_NFTs {
    return ListOwnersResponse_NFTs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOwnersResponse_NFTs>, I>>(object: I): ListOwnersResponse_NFTs {
    const message = createBaseListOwnersResponse_NFTs();
    message.nfts = object.nfts?.map((e) => e) || [];
    return message;
  },
};

function createBaseListOwnersResponse_OwnersEntry(): ListOwnersResponse_OwnersEntry {
  return { key: "", value: undefined };
}

export const ListOwnersResponse_OwnersEntry: MessageFns<ListOwnersResponse_OwnersEntry> = {
  encode(message: ListOwnersResponse_OwnersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListOwnersResponse_NFTs.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOwnersResponse_OwnersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOwnersResponse_OwnersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ListOwnersResponse_NFTs.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOwnersResponse_OwnersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ListOwnersResponse_NFTs.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ListOwnersResponse_OwnersEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ListOwnersResponse_NFTs.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOwnersResponse_OwnersEntry>, I>>(base?: I): ListOwnersResponse_OwnersEntry {
    return ListOwnersResponse_OwnersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOwnersResponse_OwnersEntry>, I>>(
    object: I,
  ): ListOwnersResponse_OwnersEntry {
    const message = createBaseListOwnersResponse_OwnersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ListOwnersResponse_NFTs.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseValidateNFTRequest(): ValidateNFTRequest {
  return { nft: "" };
}

export const ValidateNFTRequest: MessageFns<ValidateNFTRequest> = {
  encode(message: ValidateNFTRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nft !== "") {
      writer.uint32(10).string(message.nft);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateNFTRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateNFTRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nft = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateNFTRequest {
    return { nft: isSet(object.nft) ? globalThis.String(object.nft) : "" };
  },

  toJSON(message: ValidateNFTRequest): unknown {
    const obj: any = {};
    if (message.nft !== undefined) {
      obj.nft = message.nft;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateNFTRequest>, I>>(base?: I): ValidateNFTRequest {
    return ValidateNFTRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateNFTRequest>, I>>(object: I): ValidateNFTRequest {
    const message = createBaseValidateNFTRequest();
    message.nft = object.nft ?? "";
    return message;
  },
};

function createBaseValidateNFTResponse(): ValidateNFTResponse {
  return { valid: false };
}

export const ValidateNFTResponse: MessageFns<ValidateNFTResponse> = {
  encode(message: ValidateNFTResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(16).bool(message.valid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateNFTResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateNFTResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateNFTResponse {
    return { valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false };
  },

  toJSON(message: ValidateNFTResponse): unknown {
    const obj: any = {};
    if (message.valid !== undefined) {
      obj.valid = message.valid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateNFTResponse>, I>>(base?: I): ValidateNFTResponse {
    return ValidateNFTResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateNFTResponse>, I>>(object: I): ValidateNFTResponse {
    const message = createBaseValidateNFTResponse();
    message.valid = object.valid ?? false;
    return message;
  },
};

function createBaseGetContractRequest(): GetContractRequest {
  return { nftContract: "" };
}

export const GetContractRequest: MessageFns<GetContractRequest> = {
  encode(message: GetContractRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftContract !== "") {
      writer.uint32(10).string(message.nftContract);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContractRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftContract = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContractRequest {
    return { nftContract: isSet(object.nftContract) ? globalThis.String(object.nftContract) : "" };
  },

  toJSON(message: GetContractRequest): unknown {
    const obj: any = {};
    if (message.nftContract !== undefined) {
      obj.nftContract = message.nftContract;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContractRequest>, I>>(base?: I): GetContractRequest {
    return GetContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContractRequest>, I>>(object: I): GetContractRequest {
    const message = createBaseGetContractRequest();
    message.nftContract = object.nftContract ?? "";
    return message;
  },
};

function createBaseCheckHolderOfContractRequest(): CheckHolderOfContractRequest {
  return { nftContract: "", walletAddress: "" };
}

export const CheckHolderOfContractRequest: MessageFns<CheckHolderOfContractRequest> = {
  encode(message: CheckHolderOfContractRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nftContract !== "") {
      writer.uint32(10).string(message.nftContract);
    }
    if (message.walletAddress !== "") {
      writer.uint32(18).string(message.walletAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckHolderOfContractRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckHolderOfContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nftContract = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.walletAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckHolderOfContractRequest {
    return {
      nftContract: isSet(object.nftContract) ? globalThis.String(object.nftContract) : "",
      walletAddress: isSet(object.walletAddress) ? globalThis.String(object.walletAddress) : "",
    };
  },

  toJSON(message: CheckHolderOfContractRequest): unknown {
    const obj: any = {};
    if (message.nftContract !== undefined) {
      obj.nftContract = message.nftContract;
    }
    if (message.walletAddress !== undefined) {
      obj.walletAddress = message.walletAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckHolderOfContractRequest>, I>>(base?: I): CheckHolderOfContractRequest {
    return CheckHolderOfContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckHolderOfContractRequest>, I>>(object: I): CheckHolderOfContractRequest {
    const message = createBaseCheckHolderOfContractRequest();
    message.nftContract = object.nftContract ?? "";
    message.walletAddress = object.walletAddress ?? "";
    return message;
  },
};

function createBaseCheckHolderOfContractResponse(): CheckHolderOfContractResponse {
  return { isHolder: false };
}

export const CheckHolderOfContractResponse: MessageFns<CheckHolderOfContractResponse> = {
  encode(message: CheckHolderOfContractResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isHolder !== false) {
      writer.uint32(8).bool(message.isHolder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckHolderOfContractResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckHolderOfContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isHolder = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckHolderOfContractResponse {
    return { isHolder: isSet(object.isHolder) ? globalThis.Boolean(object.isHolder) : false };
  },

  toJSON(message: CheckHolderOfContractResponse): unknown {
    const obj: any = {};
    if (message.isHolder !== undefined) {
      obj.isHolder = message.isHolder;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckHolderOfContractResponse>, I>>(base?: I): CheckHolderOfContractResponse {
    return CheckHolderOfContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckHolderOfContractResponse>, I>>(
    object: I,
  ): CheckHolderOfContractResponse {
    const message = createBaseCheckHolderOfContractResponse();
    message.isHolder = object.isHolder ?? false;
    return message;
  },
};

function createBaseNFT(): NFT {
  return {
    name: "",
    address: "",
    tokenId: "",
    tokenName: "",
    imageUri: "",
    imageOriginalUri: "",
    animationUri: undefined,
    animationOriginalUri: undefined,
    metadataUri: "",
    ownerAddress: undefined,
    contract: undefined,
  };
}

export const NFT: MessageFns<NFT> = {
  encode(message: NFT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.tokenId !== "") {
      writer.uint32(26).string(message.tokenId);
    }
    if (message.tokenName !== "") {
      writer.uint32(34).string(message.tokenName);
    }
    if (message.imageUri !== "") {
      writer.uint32(42).string(message.imageUri);
    }
    if (message.imageOriginalUri !== "") {
      writer.uint32(50).string(message.imageOriginalUri);
    }
    if (message.animationUri !== undefined) {
      writer.uint32(58).string(message.animationUri);
    }
    if (message.animationOriginalUri !== undefined) {
      writer.uint32(66).string(message.animationOriginalUri);
    }
    if (message.metadataUri !== "") {
      writer.uint32(74).string(message.metadataUri);
    }
    if (message.ownerAddress !== undefined) {
      writer.uint32(82).string(message.ownerAddress);
    }
    if (message.contract !== undefined) {
      NFTContract.encode(message.contract, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NFT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNFT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.imageOriginalUri = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.animationUri = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.animationOriginalUri = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadataUri = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.contract = NFTContract.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NFT {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      tokenName: isSet(object.tokenName) ? globalThis.String(object.tokenName) : "",
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      imageOriginalUri: isSet(object.imageOriginalUri) ? globalThis.String(object.imageOriginalUri) : "",
      animationUri: isSet(object.animationUri) ? globalThis.String(object.animationUri) : undefined,
      animationOriginalUri: isSet(object.animationOriginalUri)
        ? globalThis.String(object.animationOriginalUri)
        : undefined,
      metadataUri: isSet(object.metadataUri) ? globalThis.String(object.metadataUri) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : undefined,
      contract: isSet(object.contract) ? NFTContract.fromJSON(object.contract) : undefined,
    };
  },

  toJSON(message: NFT): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    if (message.tokenName !== undefined) {
      obj.tokenName = message.tokenName;
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    if (message.imageOriginalUri !== undefined) {
      obj.imageOriginalUri = message.imageOriginalUri;
    }
    if (message.animationUri !== undefined) {
      obj.animationUri = message.animationUri;
    }
    if (message.animationOriginalUri !== undefined) {
      obj.animationOriginalUri = message.animationOriginalUri;
    }
    if (message.metadataUri !== undefined) {
      obj.metadataUri = message.metadataUri;
    }
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.contract !== undefined) {
      obj.contract = NFTContract.toJSON(message.contract);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NFT>, I>>(base?: I): NFT {
    return NFT.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NFT>, I>>(object: I): NFT {
    const message = createBaseNFT();
    message.name = object.name ?? "";
    message.address = object.address ?? "";
    message.tokenId = object.tokenId ?? "";
    message.tokenName = object.tokenName ?? "";
    message.imageUri = object.imageUri ?? "";
    message.imageOriginalUri = object.imageOriginalUri ?? "";
    message.animationUri = object.animationUri ?? undefined;
    message.animationOriginalUri = object.animationOriginalUri ?? undefined;
    message.metadataUri = object.metadataUri ?? "";
    message.ownerAddress = object.ownerAddress ?? undefined;
    message.contract = (object.contract !== undefined && object.contract !== null)
      ? NFTContract.fromPartial(object.contract)
      : undefined;
    return message;
  },
};

function createBaseNFTContract(): NFTContract {
  return {
    name: "",
    address: "",
    displayName: "",
    symbol: "",
    chain: ChainType.CHAIN_UNSPECIFIED,
    type: ContractType.CONTRACT_TYPE_UNSPECIFIED,
    imageUri: "",
  };
}

export const NFTContract: MessageFns<NFTContract> = {
  encode(message: NFTContract, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.chain !== ChainType.CHAIN_UNSPECIFIED) {
      writer.uint32(40).int32(chainTypeToNumber(message.chain));
    }
    if (message.type !== ContractType.CONTRACT_TYPE_UNSPECIFIED) {
      writer.uint32(48).int32(contractTypeToNumber(message.type));
    }
    if (message.imageUri !== "") {
      writer.uint32(58).string(message.imageUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NFTContract {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNFTContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.chain = chainTypeFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.type = contractTypeFromJSON(reader.int32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NFTContract {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      chain: isSet(object.chain) ? chainTypeFromJSON(object.chain) : ChainType.CHAIN_UNSPECIFIED,
      type: isSet(object.type) ? contractTypeFromJSON(object.type) : ContractType.CONTRACT_TYPE_UNSPECIFIED,
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
    };
  },

  toJSON(message: NFTContract): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.chain !== undefined) {
      obj.chain = chainTypeToJSON(message.chain);
    }
    if (message.type !== undefined) {
      obj.type = contractTypeToJSON(message.type);
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NFTContract>, I>>(base?: I): NFTContract {
    return NFTContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NFTContract>, I>>(object: I): NFTContract {
    const message = createBaseNFTContract();
    message.name = object.name ?? "";
    message.address = object.address ?? "";
    message.displayName = object.displayName ?? "";
    message.symbol = object.symbol ?? "";
    message.chain = object.chain ?? ChainType.CHAIN_UNSPECIFIED;
    message.type = object.type ?? ContractType.CONTRACT_TYPE_UNSPECIFIED;
    message.imageUri = object.imageUri ?? "";
    return message;
  },
};

/**
 * NFTService contains the function to interact with the NFT of the spacebar
 * It provides only the (explicit)SyncNFTs and ListNFTs API.
 * Implicit sync is performed real-time/periodically while monitoring the blockchain.
 */
export type NFTServiceService = typeof NFTServiceService;
export const NFTServiceService = {
  /** GetNFT will return NFT. */
  getNft: {
    path: "/ethereum.v1.outpost.NFTService/GetNFT",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNFTRequest) => Buffer.from(GetNFTRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNFTRequest.decode(value),
    responseSerialize: (value: NFT) => Buffer.from(NFT.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NFT.decode(value),
  },
  /** ListNFTs will return NFTs. */
  listNfTs: {
    path: "/ethereum.v1.outpost.NFTService/ListNFTs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListNFTsRequest) => Buffer.from(ListNFTsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListNFTsRequest.decode(value),
    responseSerialize: (value: ListNFTsResponse) => Buffer.from(ListNFTsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListNFTsResponse.decode(value),
  },
  /** ListOwners will return the owner of the NFT. */
  listOwners: {
    path: "/ethereum.v1.outpost.NFTService/ListOwners",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListOwnersRequest) => Buffer.from(ListOwnersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListOwnersRequest.decode(value),
    responseSerialize: (value: ListOwnersResponse) => Buffer.from(ListOwnersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListOwnersResponse.decode(value),
  },
  /** ValidateNFTAccessRequest will validate user address access to the NFT. */
  validateNftAccess: {
    path: "/ethereum.v1.outpost.NFTService/ValidateNFTAccess",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateNFTAccessRequest) => Buffer.from(ValidateNFTAccessRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateNFTAccessRequest.decode(value),
    responseSerialize: (value: ValidateNFTAccessResponse) =>
      Buffer.from(ValidateNFTAccessResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateNFTAccessResponse.decode(value),
  },
  /** ListNFTsDelegate will return NFTs using Delegate Cash. */
  listNfTsDelegate: {
    path: "/ethereum.v1.outpost.NFTService/ListNFTsDelegate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListNFTsDelegateRequest) => Buffer.from(ListNFTsDelegateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListNFTsDelegateRequest.decode(value),
    responseSerialize: (value: ListNFTsResponse) => Buffer.from(ListNFTsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListNFTsResponse.decode(value),
  },
  /** ValidateNFT will validate given NFT is valid and image is available. */
  validateNft: {
    path: "/ethereum.v1.outpost.NFTService/ValidateNFT",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateNFTRequest) => Buffer.from(ValidateNFTRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateNFTRequest.decode(value),
    responseSerialize: (value: ValidateNFTResponse) => Buffer.from(ValidateNFTResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateNFTResponse.decode(value),
  },
  /** GetContract will return NFTContract. */
  getContract: {
    path: "/ethereum.v1.outpost.NFTService/GetContract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContractRequest) => Buffer.from(GetContractRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetContractRequest.decode(value),
    responseSerialize: (value: NFTContract) => Buffer.from(NFTContract.encode(value).finish()),
    responseDeserialize: (value: Buffer) => NFTContract.decode(value),
  },
  /** CheckHolderOfContract will check if the wallet address is the holder of the contract. */
  checkHolderOfContract: {
    path: "/ethereum.v1.outpost.NFTService/CheckHolderOfContract",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckHolderOfContractRequest) =>
      Buffer.from(CheckHolderOfContractRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckHolderOfContractRequest.decode(value),
    responseSerialize: (value: CheckHolderOfContractResponse) =>
      Buffer.from(CheckHolderOfContractResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckHolderOfContractResponse.decode(value),
  },
} as const;

export interface NFTServiceServer extends UntypedServiceImplementation {
  /** GetNFT will return NFT. */
  getNft: handleUnaryCall<GetNFTRequest, NFT>;
  /** ListNFTs will return NFTs. */
  listNfTs: handleUnaryCall<ListNFTsRequest, ListNFTsResponse>;
  /** ListOwners will return the owner of the NFT. */
  listOwners: handleUnaryCall<ListOwnersRequest, ListOwnersResponse>;
  /** ValidateNFTAccessRequest will validate user address access to the NFT. */
  validateNftAccess: handleUnaryCall<ValidateNFTAccessRequest, ValidateNFTAccessResponse>;
  /** ListNFTsDelegate will return NFTs using Delegate Cash. */
  listNfTsDelegate: handleUnaryCall<ListNFTsDelegateRequest, ListNFTsResponse>;
  /** ValidateNFT will validate given NFT is valid and image is available. */
  validateNft: handleUnaryCall<ValidateNFTRequest, ValidateNFTResponse>;
  /** GetContract will return NFTContract. */
  getContract: handleUnaryCall<GetContractRequest, NFTContract>;
  /** CheckHolderOfContract will check if the wallet address is the holder of the contract. */
  checkHolderOfContract: handleUnaryCall<CheckHolderOfContractRequest, CheckHolderOfContractResponse>;
}

export interface NFTServiceClient extends Client {
  /** GetNFT will return NFT. */
  getNft(request: GetNFTRequest, callback: (error: ServiceError | null, response: NFT) => void): ClientUnaryCall;
  getNft(
    request: GetNFTRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NFT) => void,
  ): ClientUnaryCall;
  getNft(
    request: GetNFTRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NFT) => void,
  ): ClientUnaryCall;
  /** ListNFTs will return NFTs. */
  listNfTs(
    request: ListNFTsRequest,
    callback: (error: ServiceError | null, response: ListNFTsResponse) => void,
  ): ClientUnaryCall;
  listNfTs(
    request: ListNFTsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListNFTsResponse) => void,
  ): ClientUnaryCall;
  listNfTs(
    request: ListNFTsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListNFTsResponse) => void,
  ): ClientUnaryCall;
  /** ListOwners will return the owner of the NFT. */
  listOwners(
    request: ListOwnersRequest,
    callback: (error: ServiceError | null, response: ListOwnersResponse) => void,
  ): ClientUnaryCall;
  listOwners(
    request: ListOwnersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListOwnersResponse) => void,
  ): ClientUnaryCall;
  listOwners(
    request: ListOwnersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListOwnersResponse) => void,
  ): ClientUnaryCall;
  /** ValidateNFTAccessRequest will validate user address access to the NFT. */
  validateNftAccess(
    request: ValidateNFTAccessRequest,
    callback: (error: ServiceError | null, response: ValidateNFTAccessResponse) => void,
  ): ClientUnaryCall;
  validateNftAccess(
    request: ValidateNFTAccessRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ValidateNFTAccessResponse) => void,
  ): ClientUnaryCall;
  validateNftAccess(
    request: ValidateNFTAccessRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ValidateNFTAccessResponse) => void,
  ): ClientUnaryCall;
  /** ListNFTsDelegate will return NFTs using Delegate Cash. */
  listNfTsDelegate(
    request: ListNFTsDelegateRequest,
    callback: (error: ServiceError | null, response: ListNFTsResponse) => void,
  ): ClientUnaryCall;
  listNfTsDelegate(
    request: ListNFTsDelegateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListNFTsResponse) => void,
  ): ClientUnaryCall;
  listNfTsDelegate(
    request: ListNFTsDelegateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListNFTsResponse) => void,
  ): ClientUnaryCall;
  /** ValidateNFT will validate given NFT is valid and image is available. */
  validateNft(
    request: ValidateNFTRequest,
    callback: (error: ServiceError | null, response: ValidateNFTResponse) => void,
  ): ClientUnaryCall;
  validateNft(
    request: ValidateNFTRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ValidateNFTResponse) => void,
  ): ClientUnaryCall;
  validateNft(
    request: ValidateNFTRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ValidateNFTResponse) => void,
  ): ClientUnaryCall;
  /** GetContract will return NFTContract. */
  getContract(
    request: GetContractRequest,
    callback: (error: ServiceError | null, response: NFTContract) => void,
  ): ClientUnaryCall;
  getContract(
    request: GetContractRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: NFTContract) => void,
  ): ClientUnaryCall;
  getContract(
    request: GetContractRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: NFTContract) => void,
  ): ClientUnaryCall;
  /** CheckHolderOfContract will check if the wallet address is the holder of the contract. */
  checkHolderOfContract(
    request: CheckHolderOfContractRequest,
    callback: (error: ServiceError | null, response: CheckHolderOfContractResponse) => void,
  ): ClientUnaryCall;
  checkHolderOfContract(
    request: CheckHolderOfContractRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckHolderOfContractResponse) => void,
  ): ClientUnaryCall;
  checkHolderOfContract(
    request: CheckHolderOfContractRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckHolderOfContractResponse) => void,
  ): ClientUnaryCall;
}

export const NFTServiceClient = makeGenericClientConstructor(
  NFTServiceService,
  "ethereum.v1.outpost.NFTService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): NFTServiceClient;
  service: typeof NFTServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
