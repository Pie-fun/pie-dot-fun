// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: ethereum/v1/game/game.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../../google/protobuf/timestamp";

export enum ClientMessageType {
  CLIENT_MESSAGE_TYPE_UNSPECIFIED = "CLIENT_MESSAGE_TYPE_UNSPECIFIED",
  CLIENT_START_GAME = "CLIENT_START_GAME",
  CLIENT_END_GAME = "CLIENT_END_GAME",
  CLIENT_TAKE_STAR = "CLIENT_TAKE_STAR",
  CLIENT_DESTROY_OBJECT = "CLIENT_DESTROY_OBJECT",
  CLIENT_SPACESHIP_POSITION = "CLIENT_SPACESHIP_POSITION",
  CLIENT_SPACESHIP_EVENT = "CLIENT_SPACESHIP_EVENT",
  CLIENT_KEYBOARD_EVENT = "CLIENT_KEYBOARD_EVENT",
  CLIENT_DICONNECT = "CLIENT_DICONNECT",
}

export function clientMessageTypeFromJSON(object: any): ClientMessageType {
  switch (object) {
    case 0:
    case "CLIENT_MESSAGE_TYPE_UNSPECIFIED":
      return ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED;
    case 1:
    case "CLIENT_START_GAME":
      return ClientMessageType.CLIENT_START_GAME;
    case 2:
    case "CLIENT_END_GAME":
      return ClientMessageType.CLIENT_END_GAME;
    case 3:
    case "CLIENT_TAKE_STAR":
      return ClientMessageType.CLIENT_TAKE_STAR;
    case 4:
    case "CLIENT_DESTROY_OBJECT":
      return ClientMessageType.CLIENT_DESTROY_OBJECT;
    case 5:
    case "CLIENT_SPACESHIP_POSITION":
      return ClientMessageType.CLIENT_SPACESHIP_POSITION;
    case 6:
    case "CLIENT_SPACESHIP_EVENT":
      return ClientMessageType.CLIENT_SPACESHIP_EVENT;
    case 7:
    case "CLIENT_KEYBOARD_EVENT":
      return ClientMessageType.CLIENT_KEYBOARD_EVENT;
    case 8:
    case "CLIENT_DICONNECT":
      return ClientMessageType.CLIENT_DICONNECT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientMessageType");
  }
}

export function clientMessageTypeToJSON(object: ClientMessageType): string {
  switch (object) {
    case ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED:
      return "CLIENT_MESSAGE_TYPE_UNSPECIFIED";
    case ClientMessageType.CLIENT_START_GAME:
      return "CLIENT_START_GAME";
    case ClientMessageType.CLIENT_END_GAME:
      return "CLIENT_END_GAME";
    case ClientMessageType.CLIENT_TAKE_STAR:
      return "CLIENT_TAKE_STAR";
    case ClientMessageType.CLIENT_DESTROY_OBJECT:
      return "CLIENT_DESTROY_OBJECT";
    case ClientMessageType.CLIENT_SPACESHIP_POSITION:
      return "CLIENT_SPACESHIP_POSITION";
    case ClientMessageType.CLIENT_SPACESHIP_EVENT:
      return "CLIENT_SPACESHIP_EVENT";
    case ClientMessageType.CLIENT_KEYBOARD_EVENT:
      return "CLIENT_KEYBOARD_EVENT";
    case ClientMessageType.CLIENT_DICONNECT:
      return "CLIENT_DICONNECT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientMessageType");
  }
}

export function clientMessageTypeToNumber(object: ClientMessageType): number {
  switch (object) {
    case ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED:
      return 0;
    case ClientMessageType.CLIENT_START_GAME:
      return 1;
    case ClientMessageType.CLIENT_END_GAME:
      return 2;
    case ClientMessageType.CLIENT_TAKE_STAR:
      return 3;
    case ClientMessageType.CLIENT_DESTROY_OBJECT:
      return 4;
    case ClientMessageType.CLIENT_SPACESHIP_POSITION:
      return 5;
    case ClientMessageType.CLIENT_SPACESHIP_EVENT:
      return 6;
    case ClientMessageType.CLIENT_KEYBOARD_EVENT:
      return 7;
    case ClientMessageType.CLIENT_DICONNECT:
      return 8;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientMessageType");
  }
}

export enum ServerMessageType {
  SERVER_MESSAGE_TYPE_UNSPECIFIED = "SERVER_MESSAGE_TYPE_UNSPECIFIED",
  SERVER_CONNECT = "SERVER_CONNECT",
  SERVER_DISCONNECT = "SERVER_DISCONNECT",
  SERVER_START_GAME = "SERVER_START_GAME",
  SERVER_END_GAME = "SERVER_END_GAME",
  SERVER_TAKE_STAR = "SERVER_TAKE_STAR",
  SERVER_DESTROY_OBJECT = "SERVER_DESTROY_OBJECT",
  SERVER_SPACESHIP_POSITION = "SERVER_SPACESHIP_POSITION",
  SERVER_SPACESHIP_EVENT = "SERVER_SPACESHIP_EVENT",
  SERVER_KEYBOARD_EVENT = "SERVER_KEYBOARD_EVENT",
}

export function serverMessageTypeFromJSON(object: any): ServerMessageType {
  switch (object) {
    case 0:
    case "SERVER_MESSAGE_TYPE_UNSPECIFIED":
      return ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED;
    case 1:
    case "SERVER_CONNECT":
      return ServerMessageType.SERVER_CONNECT;
    case 2:
    case "SERVER_DISCONNECT":
      return ServerMessageType.SERVER_DISCONNECT;
    case 3:
    case "SERVER_START_GAME":
      return ServerMessageType.SERVER_START_GAME;
    case 4:
    case "SERVER_END_GAME":
      return ServerMessageType.SERVER_END_GAME;
    case 5:
    case "SERVER_TAKE_STAR":
      return ServerMessageType.SERVER_TAKE_STAR;
    case 6:
    case "SERVER_DESTROY_OBJECT":
      return ServerMessageType.SERVER_DESTROY_OBJECT;
    case 7:
    case "SERVER_SPACESHIP_POSITION":
      return ServerMessageType.SERVER_SPACESHIP_POSITION;
    case 8:
    case "SERVER_SPACESHIP_EVENT":
      return ServerMessageType.SERVER_SPACESHIP_EVENT;
    case 9:
    case "SERVER_KEYBOARD_EVENT":
      return ServerMessageType.SERVER_KEYBOARD_EVENT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerMessageType");
  }
}

export function serverMessageTypeToJSON(object: ServerMessageType): string {
  switch (object) {
    case ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED:
      return "SERVER_MESSAGE_TYPE_UNSPECIFIED";
    case ServerMessageType.SERVER_CONNECT:
      return "SERVER_CONNECT";
    case ServerMessageType.SERVER_DISCONNECT:
      return "SERVER_DISCONNECT";
    case ServerMessageType.SERVER_START_GAME:
      return "SERVER_START_GAME";
    case ServerMessageType.SERVER_END_GAME:
      return "SERVER_END_GAME";
    case ServerMessageType.SERVER_TAKE_STAR:
      return "SERVER_TAKE_STAR";
    case ServerMessageType.SERVER_DESTROY_OBJECT:
      return "SERVER_DESTROY_OBJECT";
    case ServerMessageType.SERVER_SPACESHIP_POSITION:
      return "SERVER_SPACESHIP_POSITION";
    case ServerMessageType.SERVER_SPACESHIP_EVENT:
      return "SERVER_SPACESHIP_EVENT";
    case ServerMessageType.SERVER_KEYBOARD_EVENT:
      return "SERVER_KEYBOARD_EVENT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerMessageType");
  }
}

export function serverMessageTypeToNumber(object: ServerMessageType): number {
  switch (object) {
    case ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED:
      return 0;
    case ServerMessageType.SERVER_CONNECT:
      return 1;
    case ServerMessageType.SERVER_DISCONNECT:
      return 2;
    case ServerMessageType.SERVER_START_GAME:
      return 3;
    case ServerMessageType.SERVER_END_GAME:
      return 4;
    case ServerMessageType.SERVER_TAKE_STAR:
      return 5;
    case ServerMessageType.SERVER_DESTROY_OBJECT:
      return 6;
    case ServerMessageType.SERVER_SPACESHIP_POSITION:
      return 7;
    case ServerMessageType.SERVER_SPACESHIP_EVENT:
      return 8;
    case ServerMessageType.SERVER_KEYBOARD_EVENT:
      return 9;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerMessageType");
  }
}

export enum ServerAckType {
  SERVER_RESPONSE_TYPE_UNSPECIFIED = "SERVER_RESPONSE_TYPE_UNSPECIFIED",
  /** ACK - Message sent to client when message from client is accepted */
  ACK = "ACK",
  /** NACK - Message sent to client when message from client is rejected */
  NACK = "NACK",
  /** NACK_UNAUTHENTICATED -  */
  NACK_UNAUTHENTICATED = "NACK_UNAUTHENTICATED",
  /** NACK_SESSION_ALREADY_EXISTS -  */
  NACK_SESSION_ALREADY_EXISTS = "NACK_SESSION_ALREADY_EXISTS",
  /** NACK_DAILY_ROUND_EXCEEDED -  */
  NACK_DAILY_ROUND_EXCEEDED = "NACK_DAILY_ROUND_EXCEEDED",
  /** ERR - Message sent to client when internal server error occurs */
  ERR = "ERR",
}

export function serverAckTypeFromJSON(object: any): ServerAckType {
  switch (object) {
    case 0:
    case "SERVER_RESPONSE_TYPE_UNSPECIFIED":
      return ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED;
    case 100:
    case "ACK":
      return ServerAckType.ACK;
    case 200:
    case "NACK":
      return ServerAckType.NACK;
    case 201:
    case "NACK_UNAUTHENTICATED":
      return ServerAckType.NACK_UNAUTHENTICATED;
    case 202:
    case "NACK_SESSION_ALREADY_EXISTS":
      return ServerAckType.NACK_SESSION_ALREADY_EXISTS;
    case 203:
    case "NACK_DAILY_ROUND_EXCEEDED":
      return ServerAckType.NACK_DAILY_ROUND_EXCEEDED;
    case 300:
    case "ERR":
      return ServerAckType.ERR;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerAckType");
  }
}

export function serverAckTypeToJSON(object: ServerAckType): string {
  switch (object) {
    case ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED:
      return "SERVER_RESPONSE_TYPE_UNSPECIFIED";
    case ServerAckType.ACK:
      return "ACK";
    case ServerAckType.NACK:
      return "NACK";
    case ServerAckType.NACK_UNAUTHENTICATED:
      return "NACK_UNAUTHENTICATED";
    case ServerAckType.NACK_SESSION_ALREADY_EXISTS:
      return "NACK_SESSION_ALREADY_EXISTS";
    case ServerAckType.NACK_DAILY_ROUND_EXCEEDED:
      return "NACK_DAILY_ROUND_EXCEEDED";
    case ServerAckType.ERR:
      return "ERR";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerAckType");
  }
}

export function serverAckTypeToNumber(object: ServerAckType): number {
  switch (object) {
    case ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED:
      return 0;
    case ServerAckType.ACK:
      return 100;
    case ServerAckType.NACK:
      return 200;
    case ServerAckType.NACK_UNAUTHENTICATED:
      return 201;
    case ServerAckType.NACK_SESSION_ALREADY_EXISTS:
      return 202;
    case ServerAckType.NACK_DAILY_ROUND_EXCEEDED:
      return 203;
    case ServerAckType.ERR:
      return 300;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerAckType");
  }
}

export interface ClientMessage {
  msgType: ClientMessageType;
  payload: string;
}

export interface ServerMessage {
  msgType: ServerMessageType;
  ackType: ServerAckType;
  payload: string;
}

export interface ConnectServerPayload {
  sessionId: string;
  game: Game | undefined;
}

export interface TakeStarClientPayload {
  star: Star | undefined;
}

export interface SpceshipPosiitionClientPayload {
  position: Position | undefined;
}

export interface SpaceshipEventClientPayload {
  event: string;
}

export interface KeyboardEventClientPayload {
  event: string;
}

export interface DestroyObjectClientPayload {
  position: Position | undefined;
}

export interface Star {
  id: string;
  position: Position | undefined;
  score: number;
}

export interface Capsule {
  id: string;
  position: Position | undefined;
}

export interface Position {
  x: number;
  y: number;
}

export interface Map {
  stars: Star[];
  capsules: Capsule[];
}

export interface Spaceship {
  position: Position | undefined;
  booster: number;
  bullet: number;
}

export interface Game {
  /** UUID of the game. Used to identify the game in the api server which means new game score will be created using this id. */
  id: string;
  map: Map | undefined;
  spaceship: Spaceship | undefined;
  score: number;
  createTime: string | undefined;
}

function createBaseClientMessage(): ClientMessage {
  return { msgType: ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED, payload: "" };
}

export const ClientMessage: MessageFns<ClientMessage> = {
  encode(message: ClientMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgType !== ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(clientMessageTypeToNumber(message.msgType));
    }
    if (message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgType = clientMessageTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMessage {
    return {
      msgType: isSet(object.msgType)
        ? clientMessageTypeFromJSON(object.msgType)
        : ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED,
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
    };
  },

  toJSON(message: ClientMessage): unknown {
    const obj: any = {};
    if (message.msgType !== undefined) {
      obj.msgType = clientMessageTypeToJSON(message.msgType);
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMessage>, I>>(base?: I): ClientMessage {
    return ClientMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMessage>, I>>(object: I): ClientMessage {
    const message = createBaseClientMessage();
    message.msgType = object.msgType ?? ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED;
    message.payload = object.payload ?? "";
    return message;
  },
};

function createBaseServerMessage(): ServerMessage {
  return {
    msgType: ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED,
    ackType: ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED,
    payload: "",
  };
}

export const ServerMessage: MessageFns<ServerMessage> = {
  encode(message: ServerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgType !== ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(serverMessageTypeToNumber(message.msgType));
    }
    if (message.ackType !== ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED) {
      writer.uint32(16).int32(serverAckTypeToNumber(message.ackType));
    }
    if (message.payload !== "") {
      writer.uint32(26).string(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgType = serverMessageTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ackType = serverAckTypeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMessage {
    return {
      msgType: isSet(object.msgType)
        ? serverMessageTypeFromJSON(object.msgType)
        : ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED,
      ackType: isSet(object.ackType)
        ? serverAckTypeFromJSON(object.ackType)
        : ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED,
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
    };
  },

  toJSON(message: ServerMessage): unknown {
    const obj: any = {};
    if (message.msgType !== undefined) {
      obj.msgType = serverMessageTypeToJSON(message.msgType);
    }
    if (message.ackType !== undefined) {
      obj.ackType = serverAckTypeToJSON(message.ackType);
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMessage>, I>>(base?: I): ServerMessage {
    return ServerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMessage>, I>>(object: I): ServerMessage {
    const message = createBaseServerMessage();
    message.msgType = object.msgType ?? ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED;
    message.ackType = object.ackType ?? ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED;
    message.payload = object.payload ?? "";
    return message;
  },
};

function createBaseConnectServerPayload(): ConnectServerPayload {
  return { sessionId: "", game: undefined };
}

export const ConnectServerPayload: MessageFns<ConnectServerPayload> = {
  encode(message: ConnectServerPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectServerPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectServerPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectServerPayload {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
    };
  },

  toJSON(message: ConnectServerPayload): unknown {
    const obj: any = {};
    if (message.sessionId !== undefined) {
      obj.sessionId = message.sessionId;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectServerPayload>, I>>(base?: I): ConnectServerPayload {
    return ConnectServerPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectServerPayload>, I>>(object: I): ConnectServerPayload {
    const message = createBaseConnectServerPayload();
    message.sessionId = object.sessionId ?? "";
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    return message;
  },
};

function createBaseTakeStarClientPayload(): TakeStarClientPayload {
  return { star: undefined };
}

export const TakeStarClientPayload: MessageFns<TakeStarClientPayload> = {
  encode(message: TakeStarClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.star !== undefined) {
      Star.encode(message.star, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TakeStarClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeStarClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.star = Star.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TakeStarClientPayload {
    return { star: isSet(object.star) ? Star.fromJSON(object.star) : undefined };
  },

  toJSON(message: TakeStarClientPayload): unknown {
    const obj: any = {};
    if (message.star !== undefined) {
      obj.star = Star.toJSON(message.star);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TakeStarClientPayload>, I>>(base?: I): TakeStarClientPayload {
    return TakeStarClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TakeStarClientPayload>, I>>(object: I): TakeStarClientPayload {
    const message = createBaseTakeStarClientPayload();
    message.star = (object.star !== undefined && object.star !== null) ? Star.fromPartial(object.star) : undefined;
    return message;
  },
};

function createBaseSpceshipPosiitionClientPayload(): SpceshipPosiitionClientPayload {
  return { position: undefined };
}

export const SpceshipPosiitionClientPayload: MessageFns<SpceshipPosiitionClientPayload> = {
  encode(message: SpceshipPosiitionClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpceshipPosiitionClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpceshipPosiitionClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpceshipPosiitionClientPayload {
    return { position: isSet(object.position) ? Position.fromJSON(object.position) : undefined };
  },

  toJSON(message: SpceshipPosiitionClientPayload): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpceshipPosiitionClientPayload>, I>>(base?: I): SpceshipPosiitionClientPayload {
    return SpceshipPosiitionClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpceshipPosiitionClientPayload>, I>>(
    object: I,
  ): SpceshipPosiitionClientPayload {
    const message = createBaseSpceshipPosiitionClientPayload();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseSpaceshipEventClientPayload(): SpaceshipEventClientPayload {
  return { event: "" };
}

export const SpaceshipEventClientPayload: MessageFns<SpaceshipEventClientPayload> = {
  encode(message: SpaceshipEventClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== "") {
      writer.uint32(10).string(message.event);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpaceshipEventClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpaceshipEventClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpaceshipEventClientPayload {
    return { event: isSet(object.event) ? globalThis.String(object.event) : "" };
  },

  toJSON(message: SpaceshipEventClientPayload): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = message.event;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpaceshipEventClientPayload>, I>>(base?: I): SpaceshipEventClientPayload {
    return SpaceshipEventClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpaceshipEventClientPayload>, I>>(object: I): SpaceshipEventClientPayload {
    const message = createBaseSpaceshipEventClientPayload();
    message.event = object.event ?? "";
    return message;
  },
};

function createBaseKeyboardEventClientPayload(): KeyboardEventClientPayload {
  return { event: "" };
}

export const KeyboardEventClientPayload: MessageFns<KeyboardEventClientPayload> = {
  encode(message: KeyboardEventClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== "") {
      writer.uint32(10).string(message.event);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyboardEventClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyboardEventClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyboardEventClientPayload {
    return { event: isSet(object.event) ? globalThis.String(object.event) : "" };
  },

  toJSON(message: KeyboardEventClientPayload): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = message.event;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyboardEventClientPayload>, I>>(base?: I): KeyboardEventClientPayload {
    return KeyboardEventClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyboardEventClientPayload>, I>>(object: I): KeyboardEventClientPayload {
    const message = createBaseKeyboardEventClientPayload();
    message.event = object.event ?? "";
    return message;
  },
};

function createBaseDestroyObjectClientPayload(): DestroyObjectClientPayload {
  return { position: undefined };
}

export const DestroyObjectClientPayload: MessageFns<DestroyObjectClientPayload> = {
  encode(message: DestroyObjectClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroyObjectClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroyObjectClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroyObjectClientPayload {
    return { position: isSet(object.position) ? Position.fromJSON(object.position) : undefined };
  },

  toJSON(message: DestroyObjectClientPayload): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestroyObjectClientPayload>, I>>(base?: I): DestroyObjectClientPayload {
    return DestroyObjectClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestroyObjectClientPayload>, I>>(object: I): DestroyObjectClientPayload {
    const message = createBaseDestroyObjectClientPayload();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseStar(): Star {
  return { id: "", position: undefined, score: 0 };
}

export const Star: MessageFns<Star> = {
  encode(message: Star, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(18).fork()).join();
    }
    if (message.score !== 0) {
      writer.uint32(24).int32(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Star {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Star {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: Star): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.score !== undefined) {
      obj.score = Math.round(message.score);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Star>, I>>(base?: I): Star {
    return Star.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Star>, I>>(object: I): Star {
    const message = createBaseStar();
    message.id = object.id ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseCapsule(): Capsule {
  return { id: "", position: undefined };
}

export const Capsule: MessageFns<Capsule> = {
  encode(message: Capsule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Capsule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapsule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Capsule {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: Capsule): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Capsule>, I>>(base?: I): Capsule {
    return Capsule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Capsule>, I>>(object: I): Capsule {
    const message = createBaseCapsule();
    message.id = object.id ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBasePosition(): Position {
  return { x: 0, y: 0 };
}

export const Position: MessageFns<Position> = {
  encode(message: Position, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Position {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Position {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Position): unknown {
    const obj: any = {};
    if (message.x !== undefined) {
      obj.x = message.x;
    }
    if (message.y !== undefined) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Position>, I>>(base?: I): Position {
    return Position.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Position>, I>>(object: I): Position {
    const message = createBasePosition();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseMap(): Map {
  return { stars: [], capsules: [] };
}

export const Map: MessageFns<Map> = {
  encode(message: Map, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.stars) {
      Star.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.capsules) {
      Capsule.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Map {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stars.push(Star.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.capsules.push(Capsule.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Map {
    return {
      stars: globalThis.Array.isArray(object?.stars) ? object.stars.map((e: any) => Star.fromJSON(e)) : [],
      capsules: globalThis.Array.isArray(object?.capsules) ? object.capsules.map((e: any) => Capsule.fromJSON(e)) : [],
    };
  },

  toJSON(message: Map): unknown {
    const obj: any = {};
    if (message.stars?.length) {
      obj.stars = message.stars.map((e) => Star.toJSON(e));
    }
    if (message.capsules?.length) {
      obj.capsules = message.capsules.map((e) => Capsule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Map>, I>>(base?: I): Map {
    return Map.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Map>, I>>(object: I): Map {
    const message = createBaseMap();
    message.stars = object.stars?.map((e) => Star.fromPartial(e)) || [];
    message.capsules = object.capsules?.map((e) => Capsule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpaceship(): Spaceship {
  return { position: undefined, booster: 0, bullet: 0 };
}

export const Spaceship: MessageFns<Spaceship> = {
  encode(message: Spaceship, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).join();
    }
    if (message.booster !== 0) {
      writer.uint32(16).int32(message.booster);
    }
    if (message.bullet !== 0) {
      writer.uint32(24).int32(message.bullet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spaceship {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpaceship();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.booster = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bullet = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spaceship {
    return {
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      booster: isSet(object.booster) ? globalThis.Number(object.booster) : 0,
      bullet: isSet(object.bullet) ? globalThis.Number(object.bullet) : 0,
    };
  },

  toJSON(message: Spaceship): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.booster !== undefined) {
      obj.booster = Math.round(message.booster);
    }
    if (message.bullet !== undefined) {
      obj.bullet = Math.round(message.bullet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Spaceship>, I>>(base?: I): Spaceship {
    return Spaceship.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Spaceship>, I>>(object: I): Spaceship {
    const message = createBaseSpaceship();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.booster = object.booster ?? 0;
    message.bullet = object.bullet ?? 0;
    return message;
  },
};

function createBaseGame(): Game {
  return { id: "", map: undefined, spaceship: undefined, score: 0, createTime: undefined };
}

export const Game: MessageFns<Game> = {
  encode(message: Game, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.map !== undefined) {
      Map.encode(message.map, writer.uint32(18).fork()).join();
    }
    if (message.spaceship !== undefined) {
      Spaceship.encode(message.spaceship, writer.uint32(26).fork()).join();
    }
    if (message.score !== 0) {
      writer.uint32(32).int32(message.score);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Game {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.map = Map.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.spaceship = Spaceship.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Game {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      map: isSet(object.map) ? Map.fromJSON(object.map) : undefined,
      spaceship: isSet(object.spaceship) ? Spaceship.fromJSON(object.spaceship) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
    };
  },

  toJSON(message: Game): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.map !== undefined) {
      obj.map = Map.toJSON(message.map);
    }
    if (message.spaceship !== undefined) {
      obj.spaceship = Spaceship.toJSON(message.spaceship);
    }
    if (message.score !== undefined) {
      obj.score = Math.round(message.score);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Game>, I>>(base?: I): Game {
    return Game.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Game>, I>>(object: I): Game {
    const message = createBaseGame();
    message.id = object.id ?? "";
    message.map = (object.map !== undefined && object.map !== null) ? Map.fromPartial(object.map) : undefined;
    message.spaceship = (object.spaceship !== undefined && object.spaceship !== null)
      ? Spaceship.fromPartial(object.spaceship)
      : undefined;
    message.score = object.score ?? 0;
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
