// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: pie-dot-fun/v1/pie-program.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata as Metadata1,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "../../google/protobuf/empty";

export enum PoolType {
  POOL_TYPE_UNSPECIFIED = "POOL_TYPE_UNSPECIFIED",
  AMM = "AMM",
  CLMM = "CLMM",
  CPMM = "CPMM",
}

export function poolTypeFromJSON(object: any): PoolType {
  switch (object) {
    case 0:
    case "POOL_TYPE_UNSPECIFIED":
      return PoolType.POOL_TYPE_UNSPECIFIED;
    case 1:
    case "AMM":
      return PoolType.AMM;
    case 2:
    case "CLMM":
      return PoolType.CLMM;
    case 3:
    case "CPMM":
      return PoolType.CPMM;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PoolType");
  }
}

export function poolTypeToJSON(object: PoolType): string {
  switch (object) {
    case PoolType.POOL_TYPE_UNSPECIFIED:
      return "POOL_TYPE_UNSPECIFIED";
    case PoolType.AMM:
      return "AMM";
    case PoolType.CLMM:
      return "CLMM";
    case PoolType.CPMM:
      return "CPMM";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PoolType");
  }
}

export function poolTypeToNumber(object: PoolType): number {
  switch (object) {
    case PoolType.POOL_TYPE_UNSPECIFIED:
      return 0;
    case PoolType.AMM:
      return 1;
    case PoolType.CLMM:
      return 2;
    case PoolType.CPMM:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PoolType");
  }
}

export enum BaseType {
  BASE_TYPE_UNSPECIFIED = "BASE_TYPE_UNSPECIFIED",
  BASE_IN = "BASE_IN",
  BASE_OUT = "BASE_OUT",
}

export function baseTypeFromJSON(object: any): BaseType {
  switch (object) {
    case 0:
    case "BASE_TYPE_UNSPECIFIED":
      return BaseType.BASE_TYPE_UNSPECIFIED;
    case 1:
    case "BASE_IN":
      return BaseType.BASE_IN;
    case 2:
    case "BASE_OUT":
      return BaseType.BASE_OUT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BaseType");
  }
}

export function baseTypeToJSON(object: BaseType): string {
  switch (object) {
    case BaseType.BASE_TYPE_UNSPECIFIED:
      return "BASE_TYPE_UNSPECIFIED";
    case BaseType.BASE_IN:
      return "BASE_IN";
    case BaseType.BASE_OUT:
      return "BASE_OUT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BaseType");
  }
}

export function baseTypeToNumber(object: BaseType): number {
  switch (object) {
    case BaseType.BASE_TYPE_UNSPECIFIED:
      return 0;
    case BaseType.BASE_IN:
      return 1;
    case BaseType.BASE_OUT:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BaseType");
  }
}

export interface GetBasketVaultRequest {
  mint: string;
}

export interface GetBasketVaultResponse {
  vault: BasketVaultElement[];
}

export interface BasketVaultElement {
  mint: string;
  balance: number;
}

export interface RebalanceAction {
  inputMint: string;
  outputMint: string;
  baseType: BaseType;
  /**
   * Raw amount of the mint that `base_type` references.
   * BASE_IN: amount of `input_mint`
   * BASE_OUT: amount of `output_mint`
   */
  amount: string;
  /**
   * Threshold for the other amount
   * BASE_IN: Minimum amount of `output_mint` token to be received
   * BASE_OUT: Maximum amount of `input_mint` token to be spent
   */
  otherAmountThreshold?: string | undefined;
}

export interface SerializedTxBundle {
  serializedTxs: string[];
}

export interface BuildRebalanceTxRequest {
  basketMint: string;
  slippagePercentage: number;
  actions: RebalanceAction[];
}

export interface BuySwapData {
  mint: string;
  amountIn: string;
  maxAmountIn: string;
  amountOut: string;
}

export interface BuildMintTxRequest {
  basketMint: string;
  mintAmount: string;
  inputAmount: string;
  ownerAddress: string;
  buySwapData: BuySwapData[];
  /**
   * percentage
   * If null, value is set to 10(%)
   */
  maxSlippage?: number | undefined;
}

export interface BuildRedeemTxRequest {
  basketMint: string;
  amount: string;
  ownerAddress: string;
  /**
   * percentage
   * If null, value is set to 10(%)
   */
  maxSlippage?: number | undefined;
}

export interface GetBasketConfigByIDRequest {
  basketId: string;
}

export interface GetBasketMintByIDRequest {
  basketId: string;
}

export interface GetBasketMintByIDResponse {
  mint: string;
}

export interface CommandCreateBasketRequest {
}

export interface GetBasketRequest {
  mint: string;
}

export interface BatchCreateTokenPoolsRequest {
  tokenPools: TokenPool[];
}

export interface BatchCreateTokenPoolsResponse {
  tokenPools: TokenPool[];
}

export interface TxResponse {
  tx: string;
}

export interface Basket {
  mint: string;
  basketId: number;
  name: string;
  symbol: string;
  uri: string;
  components: BasketComponent[];
}

export interface TokenPool {
  mint: string;
  poolType: PoolType;
  poolId: string;
  lookupTable: string;
}

export interface ProgramState {
  bump: number;
  admin: string;
  platformFeeWallet: string;
  basketCounter: string;
  rebalanceMarginLamports: string;
  creatorFeePercentage: string;
  platformFeePercentage: string;
  enableCreator: boolean;
  isInitialized: boolean;
}

export interface BasketConfig {
  bump: number;
  id: number;
  creator: string;
  rebalancer: string;
  mint: string;
  isRebalancing: boolean;
  components: BasketComponent[];
}

export interface BasketComponent {
  mint: string;
  /** In system raw amount */
  quantity: number;
}

function createBaseGetBasketVaultRequest(): GetBasketVaultRequest {
  return { mint: "" };
}

export const GetBasketVaultRequest: MessageFns<GetBasketVaultRequest> = {
  encode(message: GetBasketVaultRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBasketVaultRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketVaultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketVaultRequest {
    return { mint: isSet(object.mint) ? globalThis.String(object.mint) : "" };
  },

  toJSON(message: GetBasketVaultRequest): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketVaultRequest>, I>>(base?: I): GetBasketVaultRequest {
    return GetBasketVaultRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketVaultRequest>, I>>(object: I): GetBasketVaultRequest {
    const message = createBaseGetBasketVaultRequest();
    message.mint = object.mint ?? "";
    return message;
  },
};

function createBaseGetBasketVaultResponse(): GetBasketVaultResponse {
  return { vault: [] };
}

export const GetBasketVaultResponse: MessageFns<GetBasketVaultResponse> = {
  encode(message: GetBasketVaultResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.vault) {
      BasketVaultElement.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBasketVaultResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketVaultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vault.push(BasketVaultElement.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketVaultResponse {
    return {
      vault: globalThis.Array.isArray(object?.vault)
        ? object.vault.map((e: any) => BasketVaultElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetBasketVaultResponse): unknown {
    const obj: any = {};
    if (message.vault?.length) {
      obj.vault = message.vault.map((e) => BasketVaultElement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketVaultResponse>, I>>(base?: I): GetBasketVaultResponse {
    return GetBasketVaultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketVaultResponse>, I>>(object: I): GetBasketVaultResponse {
    const message = createBaseGetBasketVaultResponse();
    message.vault = object.vault?.map((e) => BasketVaultElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBasketVaultElement(): BasketVaultElement {
  return { mint: "", balance: 0 };
}

export const BasketVaultElement: MessageFns<BasketVaultElement> = {
  encode(message: BasketVaultElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.balance !== 0) {
      writer.uint32(16).uint64(message.balance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasketVaultElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketVaultElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.balance = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketVaultElement {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
    };
  },

  toJSON(message: BasketVaultElement): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.balance !== undefined) {
      obj.balance = Math.round(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketVaultElement>, I>>(base?: I): BasketVaultElement {
    return BasketVaultElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketVaultElement>, I>>(object: I): BasketVaultElement {
    const message = createBaseBasketVaultElement();
    message.mint = object.mint ?? "";
    message.balance = object.balance ?? 0;
    return message;
  },
};

function createBaseRebalanceAction(): RebalanceAction {
  return {
    inputMint: "",
    outputMint: "",
    baseType: BaseType.BASE_TYPE_UNSPECIFIED,
    amount: "",
    otherAmountThreshold: undefined,
  };
}

export const RebalanceAction: MessageFns<RebalanceAction> = {
  encode(message: RebalanceAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputMint !== "") {
      writer.uint32(10).string(message.inputMint);
    }
    if (message.outputMint !== "") {
      writer.uint32(18).string(message.outputMint);
    }
    if (message.baseType !== BaseType.BASE_TYPE_UNSPECIFIED) {
      writer.uint32(24).int32(baseTypeToNumber(message.baseType));
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.otherAmountThreshold !== undefined) {
      writer.uint32(42).string(message.otherAmountThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RebalanceAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inputMint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputMint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.baseType = baseTypeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.otherAmountThreshold = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebalanceAction {
    return {
      inputMint: isSet(object.inputMint) ? globalThis.String(object.inputMint) : "",
      outputMint: isSet(object.outputMint) ? globalThis.String(object.outputMint) : "",
      baseType: isSet(object.baseType) ? baseTypeFromJSON(object.baseType) : BaseType.BASE_TYPE_UNSPECIFIED,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      otherAmountThreshold: isSet(object.otherAmountThreshold)
        ? globalThis.String(object.otherAmountThreshold)
        : undefined,
    };
  },

  toJSON(message: RebalanceAction): unknown {
    const obj: any = {};
    if (message.inputMint !== undefined) {
      obj.inputMint = message.inputMint;
    }
    if (message.outputMint !== undefined) {
      obj.outputMint = message.outputMint;
    }
    if (message.baseType !== undefined) {
      obj.baseType = baseTypeToJSON(message.baseType);
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.otherAmountThreshold !== undefined) {
      obj.otherAmountThreshold = message.otherAmountThreshold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceAction>, I>>(base?: I): RebalanceAction {
    return RebalanceAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceAction>, I>>(object: I): RebalanceAction {
    const message = createBaseRebalanceAction();
    message.inputMint = object.inputMint ?? "";
    message.outputMint = object.outputMint ?? "";
    message.baseType = object.baseType ?? BaseType.BASE_TYPE_UNSPECIFIED;
    message.amount = object.amount ?? "";
    message.otherAmountThreshold = object.otherAmountThreshold ?? undefined;
    return message;
  },
};

function createBaseSerializedTxBundle(): SerializedTxBundle {
  return { serializedTxs: [] };
}

export const SerializedTxBundle: MessageFns<SerializedTxBundle> = {
  encode(message: SerializedTxBundle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.serializedTxs) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SerializedTxBundle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSerializedTxBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serializedTxs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SerializedTxBundle {
    return {
      serializedTxs: globalThis.Array.isArray(object?.serializedTxs)
        ? object.serializedTxs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SerializedTxBundle): unknown {
    const obj: any = {};
    if (message.serializedTxs?.length) {
      obj.serializedTxs = message.serializedTxs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SerializedTxBundle>, I>>(base?: I): SerializedTxBundle {
    return SerializedTxBundle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SerializedTxBundle>, I>>(object: I): SerializedTxBundle {
    const message = createBaseSerializedTxBundle();
    message.serializedTxs = object.serializedTxs?.map((e) => e) || [];
    return message;
  },
};

function createBaseBuildRebalanceTxRequest(): BuildRebalanceTxRequest {
  return { basketMint: "", slippagePercentage: 0, actions: [] };
}

export const BuildRebalanceTxRequest: MessageFns<BuildRebalanceTxRequest> = {
  encode(message: BuildRebalanceTxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basketMint !== "") {
      writer.uint32(10).string(message.basketMint);
    }
    if (message.slippagePercentage !== 0) {
      writer.uint32(17).double(message.slippagePercentage);
    }
    for (const v of message.actions) {
      RebalanceAction.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildRebalanceTxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildRebalanceTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.basketMint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.slippagePercentage = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.actions.push(RebalanceAction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildRebalanceTxRequest {
    return {
      basketMint: isSet(object.basketMint) ? globalThis.String(object.basketMint) : "",
      slippagePercentage: isSet(object.slippagePercentage) ? globalThis.Number(object.slippagePercentage) : 0,
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => RebalanceAction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BuildRebalanceTxRequest): unknown {
    const obj: any = {};
    if (message.basketMint !== undefined) {
      obj.basketMint = message.basketMint;
    }
    if (message.slippagePercentage !== undefined) {
      obj.slippagePercentage = message.slippagePercentage;
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => RebalanceAction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildRebalanceTxRequest>, I>>(base?: I): BuildRebalanceTxRequest {
    return BuildRebalanceTxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildRebalanceTxRequest>, I>>(object: I): BuildRebalanceTxRequest {
    const message = createBaseBuildRebalanceTxRequest();
    message.basketMint = object.basketMint ?? "";
    message.slippagePercentage = object.slippagePercentage ?? 0;
    message.actions = object.actions?.map((e) => RebalanceAction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBuySwapData(): BuySwapData {
  return { mint: "", amountIn: "", maxAmountIn: "", amountOut: "" };
}

export const BuySwapData: MessageFns<BuySwapData> = {
  encode(message: BuySwapData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.amountIn !== "") {
      writer.uint32(18).string(message.amountIn);
    }
    if (message.maxAmountIn !== "") {
      writer.uint32(26).string(message.maxAmountIn);
    }
    if (message.amountOut !== "") {
      writer.uint32(34).string(message.amountOut);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuySwapData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuySwapData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxAmountIn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuySwapData {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      maxAmountIn: isSet(object.maxAmountIn) ? globalThis.String(object.maxAmountIn) : "",
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
    };
  },

  toJSON(message: BuySwapData): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.amountIn !== undefined) {
      obj.amountIn = message.amountIn;
    }
    if (message.maxAmountIn !== undefined) {
      obj.maxAmountIn = message.maxAmountIn;
    }
    if (message.amountOut !== undefined) {
      obj.amountOut = message.amountOut;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuySwapData>, I>>(base?: I): BuySwapData {
    return BuySwapData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuySwapData>, I>>(object: I): BuySwapData {
    const message = createBaseBuySwapData();
    message.mint = object.mint ?? "";
    message.amountIn = object.amountIn ?? "";
    message.maxAmountIn = object.maxAmountIn ?? "";
    message.amountOut = object.amountOut ?? "";
    return message;
  },
};

function createBaseBuildMintTxRequest(): BuildMintTxRequest {
  return { basketMint: "", mintAmount: "", inputAmount: "", ownerAddress: "", buySwapData: [], maxSlippage: undefined };
}

export const BuildMintTxRequest: MessageFns<BuildMintTxRequest> = {
  encode(message: BuildMintTxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basketMint !== "") {
      writer.uint32(10).string(message.basketMint);
    }
    if (message.mintAmount !== "") {
      writer.uint32(18).string(message.mintAmount);
    }
    if (message.inputAmount !== "") {
      writer.uint32(26).string(message.inputAmount);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(34).string(message.ownerAddress);
    }
    for (const v of message.buySwapData) {
      BuySwapData.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.maxSlippage !== undefined) {
      writer.uint32(48).uint64(message.maxSlippage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMintTxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMintTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.basketMint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mintAmount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputAmount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.buySwapData.push(BuySwapData.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxSlippage = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMintTxRequest {
    return {
      basketMint: isSet(object.basketMint) ? globalThis.String(object.basketMint) : "",
      mintAmount: isSet(object.mintAmount) ? globalThis.String(object.mintAmount) : "",
      inputAmount: isSet(object.inputAmount) ? globalThis.String(object.inputAmount) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      buySwapData: globalThis.Array.isArray(object?.buySwapData)
        ? object.buySwapData.map((e: any) => BuySwapData.fromJSON(e))
        : [],
      maxSlippage: isSet(object.maxSlippage) ? globalThis.Number(object.maxSlippage) : undefined,
    };
  },

  toJSON(message: BuildMintTxRequest): unknown {
    const obj: any = {};
    if (message.basketMint !== undefined) {
      obj.basketMint = message.basketMint;
    }
    if (message.mintAmount !== undefined) {
      obj.mintAmount = message.mintAmount;
    }
    if (message.inputAmount !== undefined) {
      obj.inputAmount = message.inputAmount;
    }
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.buySwapData?.length) {
      obj.buySwapData = message.buySwapData.map((e) => BuySwapData.toJSON(e));
    }
    if (message.maxSlippage !== undefined) {
      obj.maxSlippage = Math.round(message.maxSlippage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMintTxRequest>, I>>(base?: I): BuildMintTxRequest {
    return BuildMintTxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMintTxRequest>, I>>(object: I): BuildMintTxRequest {
    const message = createBaseBuildMintTxRequest();
    message.basketMint = object.basketMint ?? "";
    message.mintAmount = object.mintAmount ?? "";
    message.inputAmount = object.inputAmount ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.buySwapData = object.buySwapData?.map((e) => BuySwapData.fromPartial(e)) || [];
    message.maxSlippage = object.maxSlippage ?? undefined;
    return message;
  },
};

function createBaseBuildRedeemTxRequest(): BuildRedeemTxRequest {
  return { basketMint: "", amount: "", ownerAddress: "", maxSlippage: undefined };
}

export const BuildRedeemTxRequest: MessageFns<BuildRedeemTxRequest> = {
  encode(message: BuildRedeemTxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basketMint !== "") {
      writer.uint32(10).string(message.basketMint);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(26).string(message.ownerAddress);
    }
    if (message.maxSlippage !== undefined) {
      writer.uint32(32).uint64(message.maxSlippage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildRedeemTxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildRedeemTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.basketMint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxSlippage = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildRedeemTxRequest {
    return {
      basketMint: isSet(object.basketMint) ? globalThis.String(object.basketMint) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      maxSlippage: isSet(object.maxSlippage) ? globalThis.Number(object.maxSlippage) : undefined,
    };
  },

  toJSON(message: BuildRedeemTxRequest): unknown {
    const obj: any = {};
    if (message.basketMint !== undefined) {
      obj.basketMint = message.basketMint;
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.maxSlippage !== undefined) {
      obj.maxSlippage = Math.round(message.maxSlippage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildRedeemTxRequest>, I>>(base?: I): BuildRedeemTxRequest {
    return BuildRedeemTxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildRedeemTxRequest>, I>>(object: I): BuildRedeemTxRequest {
    const message = createBaseBuildRedeemTxRequest();
    message.basketMint = object.basketMint ?? "";
    message.amount = object.amount ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.maxSlippage = object.maxSlippage ?? undefined;
    return message;
  },
};

function createBaseGetBasketConfigByIDRequest(): GetBasketConfigByIDRequest {
  return { basketId: "" };
}

export const GetBasketConfigByIDRequest: MessageFns<GetBasketConfigByIDRequest> = {
  encode(message: GetBasketConfigByIDRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basketId !== "") {
      writer.uint32(10).string(message.basketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBasketConfigByIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketConfigByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.basketId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketConfigByIDRequest {
    return { basketId: isSet(object.basketId) ? globalThis.String(object.basketId) : "" };
  },

  toJSON(message: GetBasketConfigByIDRequest): unknown {
    const obj: any = {};
    if (message.basketId !== undefined) {
      obj.basketId = message.basketId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketConfigByIDRequest>, I>>(base?: I): GetBasketConfigByIDRequest {
    return GetBasketConfigByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketConfigByIDRequest>, I>>(object: I): GetBasketConfigByIDRequest {
    const message = createBaseGetBasketConfigByIDRequest();
    message.basketId = object.basketId ?? "";
    return message;
  },
};

function createBaseGetBasketMintByIDRequest(): GetBasketMintByIDRequest {
  return { basketId: "" };
}

export const GetBasketMintByIDRequest: MessageFns<GetBasketMintByIDRequest> = {
  encode(message: GetBasketMintByIDRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basketId !== "") {
      writer.uint32(10).string(message.basketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBasketMintByIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketMintByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.basketId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketMintByIDRequest {
    return { basketId: isSet(object.basketId) ? globalThis.String(object.basketId) : "" };
  },

  toJSON(message: GetBasketMintByIDRequest): unknown {
    const obj: any = {};
    if (message.basketId !== undefined) {
      obj.basketId = message.basketId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketMintByIDRequest>, I>>(base?: I): GetBasketMintByIDRequest {
    return GetBasketMintByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketMintByIDRequest>, I>>(object: I): GetBasketMintByIDRequest {
    const message = createBaseGetBasketMintByIDRequest();
    message.basketId = object.basketId ?? "";
    return message;
  },
};

function createBaseGetBasketMintByIDResponse(): GetBasketMintByIDResponse {
  return { mint: "" };
}

export const GetBasketMintByIDResponse: MessageFns<GetBasketMintByIDResponse> = {
  encode(message: GetBasketMintByIDResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBasketMintByIDResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketMintByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketMintByIDResponse {
    return { mint: isSet(object.mint) ? globalThis.String(object.mint) : "" };
  },

  toJSON(message: GetBasketMintByIDResponse): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketMintByIDResponse>, I>>(base?: I): GetBasketMintByIDResponse {
    return GetBasketMintByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketMintByIDResponse>, I>>(object: I): GetBasketMintByIDResponse {
    const message = createBaseGetBasketMintByIDResponse();
    message.mint = object.mint ?? "";
    return message;
  },
};

function createBaseCommandCreateBasketRequest(): CommandCreateBasketRequest {
  return {};
}

export const CommandCreateBasketRequest: MessageFns<CommandCreateBasketRequest> = {
  encode(_: CommandCreateBasketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandCreateBasketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandCreateBasketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CommandCreateBasketRequest {
    return {};
  },

  toJSON(_: CommandCreateBasketRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandCreateBasketRequest>, I>>(base?: I): CommandCreateBasketRequest {
    return CommandCreateBasketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandCreateBasketRequest>, I>>(_: I): CommandCreateBasketRequest {
    const message = createBaseCommandCreateBasketRequest();
    return message;
  },
};

function createBaseGetBasketRequest(): GetBasketRequest {
  return { mint: "" };
}

export const GetBasketRequest: MessageFns<GetBasketRequest> = {
  encode(message: GetBasketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBasketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketRequest {
    return { mint: isSet(object.mint) ? globalThis.String(object.mint) : "" };
  },

  toJSON(message: GetBasketRequest): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketRequest>, I>>(base?: I): GetBasketRequest {
    return GetBasketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketRequest>, I>>(object: I): GetBasketRequest {
    const message = createBaseGetBasketRequest();
    message.mint = object.mint ?? "";
    return message;
  },
};

function createBaseBatchCreateTokenPoolsRequest(): BatchCreateTokenPoolsRequest {
  return { tokenPools: [] };
}

export const BatchCreateTokenPoolsRequest: MessageFns<BatchCreateTokenPoolsRequest> = {
  encode(message: BatchCreateTokenPoolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokenPools) {
      TokenPool.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateTokenPoolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateTokenPoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenPools.push(TokenPool.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateTokenPoolsRequest {
    return {
      tokenPools: globalThis.Array.isArray(object?.tokenPools)
        ? object.tokenPools.map((e: any) => TokenPool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateTokenPoolsRequest): unknown {
    const obj: any = {};
    if (message.tokenPools?.length) {
      obj.tokenPools = message.tokenPools.map((e) => TokenPool.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchCreateTokenPoolsRequest>, I>>(base?: I): BatchCreateTokenPoolsRequest {
    return BatchCreateTokenPoolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchCreateTokenPoolsRequest>, I>>(object: I): BatchCreateTokenPoolsRequest {
    const message = createBaseBatchCreateTokenPoolsRequest();
    message.tokenPools = object.tokenPools?.map((e) => TokenPool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchCreateTokenPoolsResponse(): BatchCreateTokenPoolsResponse {
  return { tokenPools: [] };
}

export const BatchCreateTokenPoolsResponse: MessageFns<BatchCreateTokenPoolsResponse> = {
  encode(message: BatchCreateTokenPoolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tokenPools) {
      TokenPool.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateTokenPoolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateTokenPoolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokenPools.push(TokenPool.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateTokenPoolsResponse {
    return {
      tokenPools: globalThis.Array.isArray(object?.tokenPools)
        ? object.tokenPools.map((e: any) => TokenPool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateTokenPoolsResponse): unknown {
    const obj: any = {};
    if (message.tokenPools?.length) {
      obj.tokenPools = message.tokenPools.map((e) => TokenPool.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchCreateTokenPoolsResponse>, I>>(base?: I): BatchCreateTokenPoolsResponse {
    return BatchCreateTokenPoolsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchCreateTokenPoolsResponse>, I>>(
    object: I,
  ): BatchCreateTokenPoolsResponse {
    const message = createBaseBatchCreateTokenPoolsResponse();
    message.tokenPools = object.tokenPools?.map((e) => TokenPool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTxResponse(): TxResponse {
  return { tx: "" };
}

export const TxResponse: MessageFns<TxResponse> = {
  encode(message: TxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tx !== "") {
      writer.uint32(10).string(message.tx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tx = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TxResponse {
    return { tx: isSet(object.tx) ? globalThis.String(object.tx) : "" };
  },

  toJSON(message: TxResponse): unknown {
    const obj: any = {};
    if (message.tx !== undefined) {
      obj.tx = message.tx;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TxResponse>, I>>(base?: I): TxResponse {
    return TxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TxResponse>, I>>(object: I): TxResponse {
    const message = createBaseTxResponse();
    message.tx = object.tx ?? "";
    return message;
  },
};

function createBaseBasket(): Basket {
  return { mint: "", basketId: 0, name: "", symbol: "", uri: "", components: [] };
}

export const Basket: MessageFns<Basket> = {
  encode(message: Basket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.basketId !== 0) {
      writer.uint32(16).uint64(message.basketId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.uri !== "") {
      writer.uint32(42).string(message.uri);
    }
    for (const v of message.components) {
      BasketComponent.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Basket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.basketId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.components.push(BasketComponent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Basket {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      basketId: isSet(object.basketId) ? globalThis.Number(object.basketId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => BasketComponent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Basket): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.basketId !== undefined) {
      obj.basketId = Math.round(message.basketId);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => BasketComponent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Basket>, I>>(base?: I): Basket {
    return Basket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Basket>, I>>(object: I): Basket {
    const message = createBaseBasket();
    message.mint = object.mint ?? "";
    message.basketId = object.basketId ?? 0;
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.uri = object.uri ?? "";
    message.components = object.components?.map((e) => BasketComponent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenPool(): TokenPool {
  return { mint: "", poolType: PoolType.POOL_TYPE_UNSPECIFIED, poolId: "", lookupTable: "" };
}

export const TokenPool: MessageFns<TokenPool> = {
  encode(message: TokenPool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.poolType !== PoolType.POOL_TYPE_UNSPECIFIED) {
      writer.uint32(16).int32(poolTypeToNumber(message.poolType));
    }
    if (message.poolId !== "") {
      writer.uint32(26).string(message.poolId);
    }
    if (message.lookupTable !== "") {
      writer.uint32(34).string(message.lookupTable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenPool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.poolType = poolTypeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.poolId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lookupTable = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenPool {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      poolType: isSet(object.poolType) ? poolTypeFromJSON(object.poolType) : PoolType.POOL_TYPE_UNSPECIFIED,
      poolId: isSet(object.poolId) ? globalThis.String(object.poolId) : "",
      lookupTable: isSet(object.lookupTable) ? globalThis.String(object.lookupTable) : "",
    };
  },

  toJSON(message: TokenPool): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.poolType !== undefined) {
      obj.poolType = poolTypeToJSON(message.poolType);
    }
    if (message.poolId !== undefined) {
      obj.poolId = message.poolId;
    }
    if (message.lookupTable !== undefined) {
      obj.lookupTable = message.lookupTable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenPool>, I>>(base?: I): TokenPool {
    return TokenPool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenPool>, I>>(object: I): TokenPool {
    const message = createBaseTokenPool();
    message.mint = object.mint ?? "";
    message.poolType = object.poolType ?? PoolType.POOL_TYPE_UNSPECIFIED;
    message.poolId = object.poolId ?? "";
    message.lookupTable = object.lookupTable ?? "";
    return message;
  },
};

function createBaseProgramState(): ProgramState {
  return {
    bump: 0,
    admin: "",
    platformFeeWallet: "",
    basketCounter: "",
    rebalanceMarginLamports: "",
    creatorFeePercentage: "",
    platformFeePercentage: "",
    enableCreator: false,
    isInitialized: false,
  };
}

export const ProgramState: MessageFns<ProgramState> = {
  encode(message: ProgramState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bump !== 0) {
      writer.uint32(8).uint32(message.bump);
    }
    if (message.admin !== "") {
      writer.uint32(18).string(message.admin);
    }
    if (message.platformFeeWallet !== "") {
      writer.uint32(26).string(message.platformFeeWallet);
    }
    if (message.basketCounter !== "") {
      writer.uint32(34).string(message.basketCounter);
    }
    if (message.rebalanceMarginLamports !== "") {
      writer.uint32(42).string(message.rebalanceMarginLamports);
    }
    if (message.creatorFeePercentage !== "") {
      writer.uint32(50).string(message.creatorFeePercentage);
    }
    if (message.platformFeePercentage !== "") {
      writer.uint32(58).string(message.platformFeePercentage);
    }
    if (message.enableCreator !== false) {
      writer.uint32(64).bool(message.enableCreator);
    }
    if (message.isInitialized !== false) {
      writer.uint32(72).bool(message.isInitialized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgramState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bump = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.platformFeeWallet = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.basketCounter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rebalanceMarginLamports = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.creatorFeePercentage = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.platformFeePercentage = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.enableCreator = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isInitialized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramState {
    return {
      bump: isSet(object.bump) ? globalThis.Number(object.bump) : 0,
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      platformFeeWallet: isSet(object.platformFeeWallet) ? globalThis.String(object.platformFeeWallet) : "",
      basketCounter: isSet(object.basketCounter) ? globalThis.String(object.basketCounter) : "",
      rebalanceMarginLamports: isSet(object.rebalanceMarginLamports)
        ? globalThis.String(object.rebalanceMarginLamports)
        : "",
      creatorFeePercentage: isSet(object.creatorFeePercentage) ? globalThis.String(object.creatorFeePercentage) : "",
      platformFeePercentage: isSet(object.platformFeePercentage) ? globalThis.String(object.platformFeePercentage) : "",
      enableCreator: isSet(object.enableCreator) ? globalThis.Boolean(object.enableCreator) : false,
      isInitialized: isSet(object.isInitialized) ? globalThis.Boolean(object.isInitialized) : false,
    };
  },

  toJSON(message: ProgramState): unknown {
    const obj: any = {};
    if (message.bump !== undefined) {
      obj.bump = Math.round(message.bump);
    }
    if (message.admin !== undefined) {
      obj.admin = message.admin;
    }
    if (message.platformFeeWallet !== undefined) {
      obj.platformFeeWallet = message.platformFeeWallet;
    }
    if (message.basketCounter !== undefined) {
      obj.basketCounter = message.basketCounter;
    }
    if (message.rebalanceMarginLamports !== undefined) {
      obj.rebalanceMarginLamports = message.rebalanceMarginLamports;
    }
    if (message.creatorFeePercentage !== undefined) {
      obj.creatorFeePercentage = message.creatorFeePercentage;
    }
    if (message.platformFeePercentage !== undefined) {
      obj.platformFeePercentage = message.platformFeePercentage;
    }
    if (message.enableCreator !== undefined) {
      obj.enableCreator = message.enableCreator;
    }
    if (message.isInitialized !== undefined) {
      obj.isInitialized = message.isInitialized;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgramState>, I>>(base?: I): ProgramState {
    return ProgramState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgramState>, I>>(object: I): ProgramState {
    const message = createBaseProgramState();
    message.bump = object.bump ?? 0;
    message.admin = object.admin ?? "";
    message.platformFeeWallet = object.platformFeeWallet ?? "";
    message.basketCounter = object.basketCounter ?? "";
    message.rebalanceMarginLamports = object.rebalanceMarginLamports ?? "";
    message.creatorFeePercentage = object.creatorFeePercentage ?? "";
    message.platformFeePercentage = object.platformFeePercentage ?? "";
    message.enableCreator = object.enableCreator ?? false;
    message.isInitialized = object.isInitialized ?? false;
    return message;
  },
};

function createBaseBasketConfig(): BasketConfig {
  return { bump: 0, id: 0, creator: "", rebalancer: "", mint: "", isRebalancing: false, components: [] };
}

export const BasketConfig: MessageFns<BasketConfig> = {
  encode(message: BasketConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bump !== 0) {
      writer.uint32(8).uint32(message.bump);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    if (message.creator !== "") {
      writer.uint32(26).string(message.creator);
    }
    if (message.rebalancer !== "") {
      writer.uint32(34).string(message.rebalancer);
    }
    if (message.mint !== "") {
      writer.uint32(42).string(message.mint);
    }
    if (message.isRebalancing !== false) {
      writer.uint32(48).bool(message.isRebalancing);
    }
    for (const v of message.components) {
      BasketComponent.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasketConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bump = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rebalancer = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isRebalancing = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.components.push(BasketComponent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketConfig {
    return {
      bump: isSet(object.bump) ? globalThis.Number(object.bump) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      rebalancer: isSet(object.rebalancer) ? globalThis.String(object.rebalancer) : "",
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      isRebalancing: isSet(object.isRebalancing) ? globalThis.Boolean(object.isRebalancing) : false,
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => BasketComponent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BasketConfig): unknown {
    const obj: any = {};
    if (message.bump !== undefined) {
      obj.bump = Math.round(message.bump);
    }
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.creator !== undefined) {
      obj.creator = message.creator;
    }
    if (message.rebalancer !== undefined) {
      obj.rebalancer = message.rebalancer;
    }
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.isRebalancing !== undefined) {
      obj.isRebalancing = message.isRebalancing;
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => BasketComponent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketConfig>, I>>(base?: I): BasketConfig {
    return BasketConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketConfig>, I>>(object: I): BasketConfig {
    const message = createBaseBasketConfig();
    message.bump = object.bump ?? 0;
    message.id = object.id ?? 0;
    message.creator = object.creator ?? "";
    message.rebalancer = object.rebalancer ?? "";
    message.mint = object.mint ?? "";
    message.isRebalancing = object.isRebalancing ?? false;
    message.components = object.components?.map((e) => BasketComponent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBasketComponent(): BasketComponent {
  return { mint: "", quantity: 0 };
}

export const BasketComponent: MessageFns<BasketComponent> = {
  encode(message: BasketComponent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).uint64(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasketComponent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketComponent {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: BasketComponent): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.quantity !== undefined) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketComponent>, I>>(base?: I): BasketComponent {
    return BasketComponent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketComponent>, I>>(object: I): BasketComponent {
    const message = createBaseBasketComponent();
    message.mint = object.mint ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

export type PieProgramServiceService = typeof PieProgramServiceService;
export const PieProgramServiceService = {
  getProgramState: {
    path: "/piedotfun.v1.PieProgramService/GetProgramState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ProgramState) => Buffer.from(ProgramState.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProgramState.decode(value),
  },
  getBasketConfigById: {
    path: "/piedotfun.v1.PieProgramService/GetBasketConfigByID",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBasketConfigByIDRequest) =>
      Buffer.from(GetBasketConfigByIDRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBasketConfigByIDRequest.decode(value),
    responseSerialize: (value: BasketConfig) => Buffer.from(BasketConfig.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BasketConfig.decode(value),
  },
  getBasket: {
    path: "/piedotfun.v1.PieProgramService/GetBasket",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBasketRequest) => Buffer.from(GetBasketRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBasketRequest.decode(value),
    responseSerialize: (value: Basket) => Buffer.from(Basket.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Basket.decode(value),
  },
  /** Get Basket Vault */
  getBasketVault: {
    path: "/piedotfun.v1.PieProgramService/GetBasketVault",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBasketVaultRequest) => Buffer.from(GetBasketVaultRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetBasketVaultRequest.decode(value),
    responseSerialize: (value: GetBasketVaultResponse) => Buffer.from(GetBasketVaultResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetBasketVaultResponse.decode(value),
  },
  /** Batch Create Token Pools */
  batchCreateTokenPools: {
    path: "/piedotfun.v1.PieProgramService/BatchCreateTokenPools",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchCreateTokenPoolsRequest) =>
      Buffer.from(BatchCreateTokenPoolsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BatchCreateTokenPoolsRequest.decode(value),
    responseSerialize: (value: BatchCreateTokenPoolsResponse) =>
      Buffer.from(BatchCreateTokenPoolsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BatchCreateTokenPoolsResponse.decode(value),
  },
  /** Build Rebalance Trasaction */
  buildRebalanceTx: {
    path: "/piedotfun.v1.PieProgramService/BuildRebalanceTx",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BuildRebalanceTxRequest) => Buffer.from(BuildRebalanceTxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BuildRebalanceTxRequest.decode(value),
    responseSerialize: (value: SerializedTxBundle) => Buffer.from(SerializedTxBundle.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SerializedTxBundle.decode(value),
  },
  /** Build Mint Transaction */
  buildMintTx: {
    path: "/piedotfun.v1.PieProgramService/BuildMintTx",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BuildMintTxRequest) => Buffer.from(BuildMintTxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BuildMintTxRequest.decode(value),
    responseSerialize: (value: SerializedTxBundle) => Buffer.from(SerializedTxBundle.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SerializedTxBundle.decode(value),
  },
  /** Build Redeem Transaction */
  buildRedeemTx: {
    path: "/piedotfun.v1.PieProgramService/BuildRedeemTx",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BuildRedeemTxRequest) => Buffer.from(BuildRedeemTxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BuildRedeemTxRequest.decode(value),
    responseSerialize: (value: SerializedTxBundle) => Buffer.from(SerializedTxBundle.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SerializedTxBundle.decode(value),
  },
  /** Send Create Basket Transaction to Solana */
  commandCreateBasket: {
    path: "/piedotfun.v1.PieProgramService/CommandCreateBasket",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Basket) => Buffer.from(Basket.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Basket.decode(value),
    responseSerialize: (value: Basket) => Buffer.from(Basket.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Basket.decode(value),
  },
  commandStartRebalanceBasket: {
    path: "/piedotfun.v1.PieProgramService/CommandStartRebalanceBasket",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Basket) => Buffer.from(Basket.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Basket.decode(value),
    responseSerialize: (value: TxResponse) => Buffer.from(TxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TxResponse.decode(value),
  },
  commandStopRebalanceBasket: {
    path: "/piedotfun.v1.PieProgramService/CommandStopRebalanceBasket",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Basket) => Buffer.from(Basket.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Basket.decode(value),
    responseSerialize: (value: TxResponse) => Buffer.from(TxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TxResponse.decode(value),
  },
} as const;

export interface PieProgramServiceServer extends UntypedServiceImplementation {
  getProgramState: handleUnaryCall<Empty, ProgramState>;
  getBasketConfigById: handleUnaryCall<GetBasketConfigByIDRequest, BasketConfig>;
  getBasket: handleUnaryCall<GetBasketRequest, Basket>;
  /** Get Basket Vault */
  getBasketVault: handleUnaryCall<GetBasketVaultRequest, GetBasketVaultResponse>;
  /** Batch Create Token Pools */
  batchCreateTokenPools: handleUnaryCall<BatchCreateTokenPoolsRequest, BatchCreateTokenPoolsResponse>;
  /** Build Rebalance Trasaction */
  buildRebalanceTx: handleUnaryCall<BuildRebalanceTxRequest, SerializedTxBundle>;
  /** Build Mint Transaction */
  buildMintTx: handleUnaryCall<BuildMintTxRequest, SerializedTxBundle>;
  /** Build Redeem Transaction */
  buildRedeemTx: handleUnaryCall<BuildRedeemTxRequest, SerializedTxBundle>;
  /** Send Create Basket Transaction to Solana */
  commandCreateBasket: handleUnaryCall<Basket, Basket>;
  commandStartRebalanceBasket: handleUnaryCall<Basket, TxResponse>;
  commandStopRebalanceBasket: handleUnaryCall<Basket, TxResponse>;
}

export interface PieProgramServiceClient extends Client {
  getProgramState(
    request: Empty,
    callback: (error: ServiceError | null, response: ProgramState) => void,
  ): ClientUnaryCall;
  getProgramState(
    request: Empty,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: ProgramState) => void,
  ): ClientUnaryCall;
  getProgramState(
    request: Empty,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ProgramState) => void,
  ): ClientUnaryCall;
  getBasketConfigById(
    request: GetBasketConfigByIDRequest,
    callback: (error: ServiceError | null, response: BasketConfig) => void,
  ): ClientUnaryCall;
  getBasketConfigById(
    request: GetBasketConfigByIDRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: BasketConfig) => void,
  ): ClientUnaryCall;
  getBasketConfigById(
    request: GetBasketConfigByIDRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BasketConfig) => void,
  ): ClientUnaryCall;
  getBasket(
    request: GetBasketRequest,
    callback: (error: ServiceError | null, response: Basket) => void,
  ): ClientUnaryCall;
  getBasket(
    request: GetBasketRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: Basket) => void,
  ): ClientUnaryCall;
  getBasket(
    request: GetBasketRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Basket) => void,
  ): ClientUnaryCall;
  /** Get Basket Vault */
  getBasketVault(
    request: GetBasketVaultRequest,
    callback: (error: ServiceError | null, response: GetBasketVaultResponse) => void,
  ): ClientUnaryCall;
  getBasketVault(
    request: GetBasketVaultRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: GetBasketVaultResponse) => void,
  ): ClientUnaryCall;
  getBasketVault(
    request: GetBasketVaultRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBasketVaultResponse) => void,
  ): ClientUnaryCall;
  /** Batch Create Token Pools */
  batchCreateTokenPools(
    request: BatchCreateTokenPoolsRequest,
    callback: (error: ServiceError | null, response: BatchCreateTokenPoolsResponse) => void,
  ): ClientUnaryCall;
  batchCreateTokenPools(
    request: BatchCreateTokenPoolsRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: BatchCreateTokenPoolsResponse) => void,
  ): ClientUnaryCall;
  batchCreateTokenPools(
    request: BatchCreateTokenPoolsRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchCreateTokenPoolsResponse) => void,
  ): ClientUnaryCall;
  /** Build Rebalance Trasaction */
  buildRebalanceTx(
    request: BuildRebalanceTxRequest,
    callback: (error: ServiceError | null, response: SerializedTxBundle) => void,
  ): ClientUnaryCall;
  buildRebalanceTx(
    request: BuildRebalanceTxRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: SerializedTxBundle) => void,
  ): ClientUnaryCall;
  buildRebalanceTx(
    request: BuildRebalanceTxRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SerializedTxBundle) => void,
  ): ClientUnaryCall;
  /** Build Mint Transaction */
  buildMintTx(
    request: BuildMintTxRequest,
    callback: (error: ServiceError | null, response: SerializedTxBundle) => void,
  ): ClientUnaryCall;
  buildMintTx(
    request: BuildMintTxRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: SerializedTxBundle) => void,
  ): ClientUnaryCall;
  buildMintTx(
    request: BuildMintTxRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SerializedTxBundle) => void,
  ): ClientUnaryCall;
  /** Build Redeem Transaction */
  buildRedeemTx(
    request: BuildRedeemTxRequest,
    callback: (error: ServiceError | null, response: SerializedTxBundle) => void,
  ): ClientUnaryCall;
  buildRedeemTx(
    request: BuildRedeemTxRequest,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: SerializedTxBundle) => void,
  ): ClientUnaryCall;
  buildRedeemTx(
    request: BuildRedeemTxRequest,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SerializedTxBundle) => void,
  ): ClientUnaryCall;
  /** Send Create Basket Transaction to Solana */
  commandCreateBasket(
    request: Basket,
    callback: (error: ServiceError | null, response: Basket) => void,
  ): ClientUnaryCall;
  commandCreateBasket(
    request: Basket,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: Basket) => void,
  ): ClientUnaryCall;
  commandCreateBasket(
    request: Basket,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Basket) => void,
  ): ClientUnaryCall;
  commandStartRebalanceBasket(
    request: Basket,
    callback: (error: ServiceError | null, response: TxResponse) => void,
  ): ClientUnaryCall;
  commandStartRebalanceBasket(
    request: Basket,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: TxResponse) => void,
  ): ClientUnaryCall;
  commandStartRebalanceBasket(
    request: Basket,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TxResponse) => void,
  ): ClientUnaryCall;
  commandStopRebalanceBasket(
    request: Basket,
    callback: (error: ServiceError | null, response: TxResponse) => void,
  ): ClientUnaryCall;
  commandStopRebalanceBasket(
    request: Basket,
    metadata: Metadata1,
    callback: (error: ServiceError | null, response: TxResponse) => void,
  ): ClientUnaryCall;
  commandStopRebalanceBasket(
    request: Basket,
    metadata: Metadata1,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TxResponse) => void,
  ): ClientUnaryCall;
}

export const PieProgramServiceClient = makeGenericClientConstructor(
  PieProgramServiceService,
  "piedotfun.v1.PieProgramService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PieProgramServiceClient;
  service: typeof PieProgramServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
