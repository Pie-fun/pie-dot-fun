// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: blast/v1/aggregate/aggregate.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Activity, Bonus, Multiplier, Referral, Staking } from "../points/points";
import {
  PFPBoost,
  Private,
  Public,
  SquareJoinType,
  squareJoinTypeFromJSON,
  squareJoinTypeToJSON,
  squareJoinTypeToNumber,
  SquareMemberRankType,
  squareMemberRankTypeFromJSON,
  squareMemberRankTypeToJSON,
  squareMemberRankTypeToNumber,
  SquareMemberType,
  squareMemberTypeFromJSON,
  squareMemberTypeToJSON,
  squareMemberTypeToNumber,
  SquareNFT,
  SquareState,
  squareStateFromJSON,
  squareStateToJSON,
  squareStateToNumber,
  SquareView,
  squareViewFromJSON,
  squareViewToJSON,
  squareViewToNumber,
  TokenGated,
} from "../square/square";
import { User } from "../user/user";

export interface ListPointsAggregateRequest {
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPoints` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Available Sequence and Operator
   * * name
   *   * `=`
   * * user_address
   *   * `=`
   *
   * Examples
   * * name="points/0x6F11EF2c07f2E381CbE514198DdE87A0c0a19442"
   * * user_address="0x6F11EF2c07f2E381CbE514198DdE87A0c0a19442"
   */
  filter: string;
  /**
   * One or more fields to compare and use to sort the output. (optional)
   * Default order for a field is descending by id
   * To specify ascending or descending order, append " asc" or " desc" to the field name. If not specified, the order is ascending.
   *
   * Reference
   * * https://google.aip.dev/132#ordering.
   *
   * Supported Fields
   * * "id", "user_address", "points"
   *
   * Examples
   * * order_by=points desc
   */
  orderBy: string;
}

/** ListPointsResponse */
export interface ListPointsAggregateResponse {
  /** The list of rows that matched the query. */
  pointsAggregate: PointsAggregate[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface PointsAggregate {
  /**
   * The resource name of the Points.
   * Format: users/{address}/points
   */
  name: string;
  /**  */
  user:
    | User
    | undefined;
  /**  */
  totalPoints: number;
  referral: Referral | undefined;
  staking: Staking | undefined;
  activity: Activity | undefined;
  bonus: Bonus | undefined;
  multipliers: Multiplier[];
}

export interface ListSquareMemberRankingsAggregateRequest {
  /**
   * The name of the square to retrieve.
   * Format: squares/{token_id}
   */
  square: string;
  rankType: SquareMemberRankType;
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPoints` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListSquareMemberRankingsAggregateResponse {
  /** The list of rows that matched the query. */
  rankingsAggregate: SquareMemberRankingAggregate[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface SquareMemberRankingAggregate {
  rank: number;
  points: number;
  member: SquareMemberAggregate | undefined;
}

export interface SquareMemberAggregate {
  /**
   * The resource name of the Square.
   * Format: squares/{square_token_id}/members/{user_address}
   */
  name: string;
  /** The token ID of the Square. */
  squareTokenId: string;
  /** The user address of the member. */
  user:
    | User
    | undefined;
  /** The member type of the square. */
  type: SquareMemberType;
  totalPoints: number;
  /** RFC3339 format e.g. "2006-01-02T15:04:05Z07:00" */
  joinTime: string | undefined;
}

/**  */
export interface GetSquareAggregateRequest {
  /**
   * The name of the square to retrieve.
   * Format: squares/{token_id}
   */
  square: string;
  /** The view of the square. */
  view: SquareView;
}

export interface SquareAggregate {
  /**
   * The resource name of the Square.
   * Format: squares/{token_id}
   */
  name: string;
  /** ERC721 token ID of the Square. */
  tokenId: string;
  /**  */
  owner:
    | User
    | undefined;
  /**
   * The created time of Square.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  createTime: string | undefined;
  state: SquareState;
  /**
   * The signature id of the Square.
   * This field is used for multi signature when minting the Square NFT.
   */
  signatureId: string;
  /** The join type of the square. */
  joinType: SquareJoinType;
  join?:
    | { $case: "public"; public: Public }
    | { $case: "private"; private: Private }
    | { $case: "tokenGated"; tokenGated: TokenGated }
    | undefined;
  /** The display name of the square. */
  displayName: string;
  /** The introduction of the square. */
  introduction: string;
  /** The minimum required staking amount to join the square in ETH. */
  minimumStakingAmountToJoinInEth: number;
  /** The total staking amount of all members in the square in ETH. */
  totalMembersStakingAmountInEth: number;
  /** The multiplier of the square. */
  multiplier: number;
  /** The all-time total points of the square. */
  totalPoints: number;
  /** The total capacity of the square. */
  capacity: number;
  /** The current number of members in the square. */
  occupancy: number;
  /** The occupancy of the square including join pending members. */
  occupancyIncludingPending: number;
  /** The PFP boost of the square. */
  pfpBoost:
    | PFPBoost
    | undefined;
  /** The NFT of the square. */
  nft:
    | SquareNFT
    | undefined;
  /**  */
  spirits: number;
  /**  */
  stars: number;
  totalSpirits: number;
  weeklySpirits: number;
}

export interface ListSquaresAggregateRequest {
  /**
   * The maximum number of squares to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListSquares` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Available Sequence and Operator
   * * name
   *   * `=`
   * * token_id
   *   * `=`
   * * signature_id
   *   * `=`
   * * state
   *   * `=`
   * * join_type
   *   * `=`
   * * display_name
   *   * `=`
   *
   * Examples
   * * name="squares/10"
   * * token_id="10"
   * * signature_id="3ed92b99-00be-4417-b69f-dca2d8d14c7f"
   * * join_type=TOKEN_GATED
   * * display_name="SQUARE"
   */
  filter: string;
  /**
   * Optional. One or more fields to compare and use to sort the output.
   * Default order for a field is descending by id
   * To specify ascending or descending order, append " asc" or " desc" to the field name. If not specified, the order is ascending.
   *
   * Reference
   * * https://google.aip.dev/132#ordering.
   *
   * Supported Fields
   * * "token_id", "total_points", "spirits"
   *
   * Examples
   * * order_by=token_id asc
   * * order_by=total_points desc
   * * order_by=spirits asc
   */
  orderBy: string;
}

/** ListSquaresAggregateResponse */
export interface ListSquaresAggregateResponse {
  /** The list of rows that matched the query. */
  squaresAggregate: SquareAggregate[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

function createBaseListPointsAggregateRequest(): ListPointsAggregateRequest {
  return { pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListPointsAggregateRequest: MessageFns<ListPointsAggregateRequest> = {
  encode(message: ListPointsAggregateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPointsAggregateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPointsAggregateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPointsAggregateRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListPointsAggregateRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    if (message.orderBy !== undefined) {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPointsAggregateRequest>, I>>(base?: I): ListPointsAggregateRequest {
    return ListPointsAggregateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPointsAggregateRequest>, I>>(object: I): ListPointsAggregateRequest {
    const message = createBaseListPointsAggregateRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListPointsAggregateResponse(): ListPointsAggregateResponse {
  return { pointsAggregate: [], nextPageToken: "" };
}

export const ListPointsAggregateResponse: MessageFns<ListPointsAggregateResponse> = {
  encode(message: ListPointsAggregateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pointsAggregate) {
      PointsAggregate.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPointsAggregateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPointsAggregateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pointsAggregate.push(PointsAggregate.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPointsAggregateResponse {
    return {
      pointsAggregate: globalThis.Array.isArray(object?.pointsAggregate)
        ? object.pointsAggregate.map((e: any) => PointsAggregate.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPointsAggregateResponse): unknown {
    const obj: any = {};
    if (message.pointsAggregate?.length) {
      obj.pointsAggregate = message.pointsAggregate.map((e) => PointsAggregate.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPointsAggregateResponse>, I>>(base?: I): ListPointsAggregateResponse {
    return ListPointsAggregateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPointsAggregateResponse>, I>>(object: I): ListPointsAggregateResponse {
    const message = createBaseListPointsAggregateResponse();
    message.pointsAggregate = object.pointsAggregate?.map((e) => PointsAggregate.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBasePointsAggregate(): PointsAggregate {
  return {
    name: "",
    user: undefined,
    totalPoints: 0,
    referral: undefined,
    staking: undefined,
    activity: undefined,
    bonus: undefined,
    multipliers: [],
  };
}

export const PointsAggregate: MessageFns<PointsAggregate> = {
  encode(message: PointsAggregate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.totalPoints !== 0) {
      writer.uint32(24).uint32(message.totalPoints);
    }
    if (message.referral !== undefined) {
      Referral.encode(message.referral, writer.uint32(42).fork()).join();
    }
    if (message.staking !== undefined) {
      Staking.encode(message.staking, writer.uint32(50).fork()).join();
    }
    if (message.activity !== undefined) {
      Activity.encode(message.activity, writer.uint32(58).fork()).join();
    }
    if (message.bonus !== undefined) {
      Bonus.encode(message.bonus, writer.uint32(66).fork()).join();
    }
    for (const v of message.multipliers) {
      Multiplier.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PointsAggregate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointsAggregate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalPoints = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referral = Referral.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.staking = Staking.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.activity = Activity.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bonus = Bonus.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.multipliers.push(Multiplier.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointsAggregate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
      referral: isSet(object.referral) ? Referral.fromJSON(object.referral) : undefined,
      staking: isSet(object.staking) ? Staking.fromJSON(object.staking) : undefined,
      activity: isSet(object.activity) ? Activity.fromJSON(object.activity) : undefined,
      bonus: isSet(object.bonus) ? Bonus.fromJSON(object.bonus) : undefined,
      multipliers: globalThis.Array.isArray(object?.multipliers)
        ? object.multipliers.map((e: any) => Multiplier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PointsAggregate): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.totalPoints !== undefined) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    if (message.referral !== undefined) {
      obj.referral = Referral.toJSON(message.referral);
    }
    if (message.staking !== undefined) {
      obj.staking = Staking.toJSON(message.staking);
    }
    if (message.activity !== undefined) {
      obj.activity = Activity.toJSON(message.activity);
    }
    if (message.bonus !== undefined) {
      obj.bonus = Bonus.toJSON(message.bonus);
    }
    if (message.multipliers?.length) {
      obj.multipliers = message.multipliers.map((e) => Multiplier.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PointsAggregate>, I>>(base?: I): PointsAggregate {
    return PointsAggregate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PointsAggregate>, I>>(object: I): PointsAggregate {
    const message = createBasePointsAggregate();
    message.name = object.name ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.totalPoints = object.totalPoints ?? 0;
    message.referral = (object.referral !== undefined && object.referral !== null)
      ? Referral.fromPartial(object.referral)
      : undefined;
    message.staking = (object.staking !== undefined && object.staking !== null)
      ? Staking.fromPartial(object.staking)
      : undefined;
    message.activity = (object.activity !== undefined && object.activity !== null)
      ? Activity.fromPartial(object.activity)
      : undefined;
    message.bonus = (object.bonus !== undefined && object.bonus !== null) ? Bonus.fromPartial(object.bonus) : undefined;
    message.multipliers = object.multipliers?.map((e) => Multiplier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListSquareMemberRankingsAggregateRequest(): ListSquareMemberRankingsAggregateRequest {
  return { square: "", rankType: SquareMemberRankType.SQUARE_MEMBER_RANK_TYPE_UNSPECIFIED, pageSize: 0, pageToken: "" };
}

export const ListSquareMemberRankingsAggregateRequest: MessageFns<ListSquareMemberRankingsAggregateRequest> = {
  encode(message: ListSquareMemberRankingsAggregateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.square !== "") {
      writer.uint32(10).string(message.square);
    }
    if (message.rankType !== SquareMemberRankType.SQUARE_MEMBER_RANK_TYPE_UNSPECIFIED) {
      writer.uint32(16).int32(squareMemberRankTypeToNumber(message.rankType));
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSquareMemberRankingsAggregateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquareMemberRankingsAggregateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.square = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rankType = squareMemberRankTypeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquareMemberRankingsAggregateRequest {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      rankType: isSet(object.rankType)
        ? squareMemberRankTypeFromJSON(object.rankType)
        : SquareMemberRankType.SQUARE_MEMBER_RANK_TYPE_UNSPECIFIED,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSquareMemberRankingsAggregateRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.rankType !== undefined) {
      obj.rankType = squareMemberRankTypeToJSON(message.rankType);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquareMemberRankingsAggregateRequest>, I>>(
    base?: I,
  ): ListSquareMemberRankingsAggregateRequest {
    return ListSquareMemberRankingsAggregateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquareMemberRankingsAggregateRequest>, I>>(
    object: I,
  ): ListSquareMemberRankingsAggregateRequest {
    const message = createBaseListSquareMemberRankingsAggregateRequest();
    message.square = object.square ?? "";
    message.rankType = object.rankType ?? SquareMemberRankType.SQUARE_MEMBER_RANK_TYPE_UNSPECIFIED;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSquareMemberRankingsAggregateResponse(): ListSquareMemberRankingsAggregateResponse {
  return { rankingsAggregate: [], nextPageToken: "" };
}

export const ListSquareMemberRankingsAggregateResponse: MessageFns<ListSquareMemberRankingsAggregateResponse> = {
  encode(message: ListSquareMemberRankingsAggregateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rankingsAggregate) {
      SquareMemberRankingAggregate.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSquareMemberRankingsAggregateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquareMemberRankingsAggregateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rankingsAggregate.push(SquareMemberRankingAggregate.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquareMemberRankingsAggregateResponse {
    return {
      rankingsAggregate: globalThis.Array.isArray(object?.rankingsAggregate)
        ? object.rankingsAggregate.map((e: any) => SquareMemberRankingAggregate.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSquareMemberRankingsAggregateResponse): unknown {
    const obj: any = {};
    if (message.rankingsAggregate?.length) {
      obj.rankingsAggregate = message.rankingsAggregate.map((e) => SquareMemberRankingAggregate.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquareMemberRankingsAggregateResponse>, I>>(
    base?: I,
  ): ListSquareMemberRankingsAggregateResponse {
    return ListSquareMemberRankingsAggregateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquareMemberRankingsAggregateResponse>, I>>(
    object: I,
  ): ListSquareMemberRankingsAggregateResponse {
    const message = createBaseListSquareMemberRankingsAggregateResponse();
    message.rankingsAggregate = object.rankingsAggregate?.map((e) => SquareMemberRankingAggregate.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSquareMemberRankingAggregate(): SquareMemberRankingAggregate {
  return { rank: 0, points: 0, member: undefined };
}

export const SquareMemberRankingAggregate: MessageFns<SquareMemberRankingAggregate> = {
  encode(message: SquareMemberRankingAggregate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.points !== 0) {
      writer.uint32(16).uint32(message.points);
    }
    if (message.member !== undefined) {
      SquareMemberAggregate.encode(message.member, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SquareMemberRankingAggregate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSquareMemberRankingAggregate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.points = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.member = SquareMemberAggregate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SquareMemberRankingAggregate {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
      member: isSet(object.member) ? SquareMemberAggregate.fromJSON(object.member) : undefined,
    };
  },

  toJSON(message: SquareMemberRankingAggregate): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.points !== undefined) {
      obj.points = Math.round(message.points);
    }
    if (message.member !== undefined) {
      obj.member = SquareMemberAggregate.toJSON(message.member);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SquareMemberRankingAggregate>, I>>(base?: I): SquareMemberRankingAggregate {
    return SquareMemberRankingAggregate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SquareMemberRankingAggregate>, I>>(object: I): SquareMemberRankingAggregate {
    const message = createBaseSquareMemberRankingAggregate();
    message.rank = object.rank ?? 0;
    message.points = object.points ?? 0;
    message.member = (object.member !== undefined && object.member !== null)
      ? SquareMemberAggregate.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseSquareMemberAggregate(): SquareMemberAggregate {
  return {
    name: "",
    squareTokenId: "",
    user: undefined,
    type: SquareMemberType.SQUARE_MEMBER_TYPE_UNSPECIFIED,
    totalPoints: 0,
    joinTime: undefined,
  };
}

export const SquareMemberAggregate: MessageFns<SquareMemberAggregate> = {
  encode(message: SquareMemberAggregate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.squareTokenId !== "") {
      writer.uint32(18).string(message.squareTokenId);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    if (message.type !== SquareMemberType.SQUARE_MEMBER_TYPE_UNSPECIFIED) {
      writer.uint32(32).int32(squareMemberTypeToNumber(message.type));
    }
    if (message.totalPoints !== 0) {
      writer.uint32(40).uint32(message.totalPoints);
    }
    if (message.joinTime !== undefined) {
      Timestamp.encode(toTimestamp(message.joinTime), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SquareMemberAggregate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSquareMemberAggregate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.squareTokenId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = squareMemberTypeFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalPoints = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.joinTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SquareMemberAggregate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      squareTokenId: isSet(object.squareTokenId) ? globalThis.String(object.squareTokenId) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      type: isSet(object.type)
        ? squareMemberTypeFromJSON(object.type)
        : SquareMemberType.SQUARE_MEMBER_TYPE_UNSPECIFIED,
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
      joinTime: isSet(object.joinTime) ? globalThis.String(object.joinTime) : undefined,
    };
  },

  toJSON(message: SquareMemberAggregate): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.squareTokenId !== undefined) {
      obj.squareTokenId = message.squareTokenId;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.type !== undefined) {
      obj.type = squareMemberTypeToJSON(message.type);
    }
    if (message.totalPoints !== undefined) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    if (message.joinTime !== undefined) {
      obj.joinTime = message.joinTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SquareMemberAggregate>, I>>(base?: I): SquareMemberAggregate {
    return SquareMemberAggregate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SquareMemberAggregate>, I>>(object: I): SquareMemberAggregate {
    const message = createBaseSquareMemberAggregate();
    message.name = object.name ?? "";
    message.squareTokenId = object.squareTokenId ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.type = object.type ?? SquareMemberType.SQUARE_MEMBER_TYPE_UNSPECIFIED;
    message.totalPoints = object.totalPoints ?? 0;
    message.joinTime = object.joinTime ?? undefined;
    return message;
  },
};

function createBaseGetSquareAggregateRequest(): GetSquareAggregateRequest {
  return { square: "", view: SquareView.SQUARE_VIEW_UNSPECIFIED };
}

export const GetSquareAggregateRequest: MessageFns<GetSquareAggregateRequest> = {
  encode(message: GetSquareAggregateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.square !== "") {
      writer.uint32(10).string(message.square);
    }
    if (message.view !== SquareView.SQUARE_VIEW_UNSPECIFIED) {
      writer.uint32(16).int32(squareViewToNumber(message.view));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSquareAggregateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSquareAggregateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.square = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.view = squareViewFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSquareAggregateRequest {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      view: isSet(object.view) ? squareViewFromJSON(object.view) : SquareView.SQUARE_VIEW_UNSPECIFIED,
    };
  },

  toJSON(message: GetSquareAggregateRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.view !== undefined) {
      obj.view = squareViewToJSON(message.view);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSquareAggregateRequest>, I>>(base?: I): GetSquareAggregateRequest {
    return GetSquareAggregateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSquareAggregateRequest>, I>>(object: I): GetSquareAggregateRequest {
    const message = createBaseGetSquareAggregateRequest();
    message.square = object.square ?? "";
    message.view = object.view ?? SquareView.SQUARE_VIEW_UNSPECIFIED;
    return message;
  },
};

function createBaseSquareAggregate(): SquareAggregate {
  return {
    name: "",
    tokenId: "",
    owner: undefined,
    createTime: undefined,
    state: SquareState.STATE_UNSPECIFIED,
    signatureId: "",
    joinType: SquareJoinType.TYPE_UNSPECIFIED,
    join: undefined,
    displayName: "",
    introduction: "",
    minimumStakingAmountToJoinInEth: 0,
    totalMembersStakingAmountInEth: 0,
    multiplier: 0,
    totalPoints: 0,
    capacity: 0,
    occupancy: 0,
    occupancyIncludingPending: 0,
    pfpBoost: undefined,
    nft: undefined,
    spirits: 0,
    stars: 0,
    totalSpirits: 0,
    weeklySpirits: 0,
  };
}

export const SquareAggregate: MessageFns<SquareAggregate> = {
  encode(message: SquareAggregate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    if (message.owner !== undefined) {
      User.encode(message.owner, writer.uint32(26).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.state !== SquareState.STATE_UNSPECIFIED) {
      writer.uint32(40).int32(squareStateToNumber(message.state));
    }
    if (message.signatureId !== "") {
      writer.uint32(50).string(message.signatureId);
    }
    if (message.joinType !== SquareJoinType.TYPE_UNSPECIFIED) {
      writer.uint32(56).int32(squareJoinTypeToNumber(message.joinType));
    }
    switch (message.join?.$case) {
      case "public":
        Public.encode(message.join.public, writer.uint32(66).fork()).join();
        break;
      case "private":
        Private.encode(message.join.private, writer.uint32(74).fork()).join();
        break;
      case "tokenGated":
        TokenGated.encode(message.join.tokenGated, writer.uint32(82).fork()).join();
        break;
    }
    if (message.displayName !== "") {
      writer.uint32(90).string(message.displayName);
    }
    if (message.introduction !== "") {
      writer.uint32(98).string(message.introduction);
    }
    if (message.minimumStakingAmountToJoinInEth !== 0) {
      writer.uint32(109).float(message.minimumStakingAmountToJoinInEth);
    }
    if (message.totalMembersStakingAmountInEth !== 0) {
      writer.uint32(117).float(message.totalMembersStakingAmountInEth);
    }
    if (message.multiplier !== 0) {
      writer.uint32(125).float(message.multiplier);
    }
    if (message.totalPoints !== 0) {
      writer.uint32(128).uint32(message.totalPoints);
    }
    if (message.capacity !== 0) {
      writer.uint32(136).uint32(message.capacity);
    }
    if (message.occupancy !== 0) {
      writer.uint32(144).uint32(message.occupancy);
    }
    if (message.occupancyIncludingPending !== 0) {
      writer.uint32(152).uint32(message.occupancyIncludingPending);
    }
    if (message.pfpBoost !== undefined) {
      PFPBoost.encode(message.pfpBoost, writer.uint32(162).fork()).join();
    }
    if (message.nft !== undefined) {
      SquareNFT.encode(message.nft, writer.uint32(170).fork()).join();
    }
    if (message.spirits !== 0) {
      writer.uint32(176).uint32(message.spirits);
    }
    if (message.stars !== 0) {
      writer.uint32(184).uint32(message.stars);
    }
    if (message.totalSpirits !== 0) {
      writer.uint32(192).uint32(message.totalSpirits);
    }
    if (message.weeklySpirits !== 0) {
      writer.uint32(200).uint32(message.weeklySpirits);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SquareAggregate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSquareAggregate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = User.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.state = squareStateFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signatureId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.joinType = squareJoinTypeFromJSON(reader.int32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.join = { $case: "public", public: Public.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.join = { $case: "private", private: Private.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.join = { $case: "tokenGated", tokenGated: TokenGated.decode(reader, reader.uint32()) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.introduction = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.minimumStakingAmountToJoinInEth = reader.float();
          continue;
        }
        case 14: {
          if (tag !== 117) {
            break;
          }

          message.totalMembersStakingAmountInEth = reader.float();
          continue;
        }
        case 15: {
          if (tag !== 125) {
            break;
          }

          message.multiplier = reader.float();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.totalPoints = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.capacity = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.occupancy = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.occupancyIncludingPending = reader.uint32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.pfpBoost = PFPBoost.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.nft = SquareNFT.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.spirits = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.stars = reader.uint32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.totalSpirits = reader.uint32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.weeklySpirits = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SquareAggregate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      owner: isSet(object.owner) ? User.fromJSON(object.owner) : undefined,
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      state: isSet(object.state) ? squareStateFromJSON(object.state) : SquareState.STATE_UNSPECIFIED,
      signatureId: isSet(object.signatureId) ? globalThis.String(object.signatureId) : "",
      joinType: isSet(object.joinType) ? squareJoinTypeFromJSON(object.joinType) : SquareJoinType.TYPE_UNSPECIFIED,
      join: isSet(object.public)
        ? { $case: "public", public: Public.fromJSON(object.public) }
        : isSet(object.private)
        ? { $case: "private", private: Private.fromJSON(object.private) }
        : isSet(object.tokenGated)
        ? { $case: "tokenGated", tokenGated: TokenGated.fromJSON(object.tokenGated) }
        : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : "",
      minimumStakingAmountToJoinInEth: isSet(object.minimumStakingAmountToJoinInEth)
        ? globalThis.Number(object.minimumStakingAmountToJoinInEth)
        : 0,
      totalMembersStakingAmountInEth: isSet(object.totalMembersStakingAmountInEth)
        ? globalThis.Number(object.totalMembersStakingAmountInEth)
        : 0,
      multiplier: isSet(object.multiplier) ? globalThis.Number(object.multiplier) : 0,
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
      capacity: isSet(object.capacity) ? globalThis.Number(object.capacity) : 0,
      occupancy: isSet(object.occupancy) ? globalThis.Number(object.occupancy) : 0,
      occupancyIncludingPending: isSet(object.occupancyIncludingPending)
        ? globalThis.Number(object.occupancyIncludingPending)
        : 0,
      pfpBoost: isSet(object.pfpBoost) ? PFPBoost.fromJSON(object.pfpBoost) : undefined,
      nft: isSet(object.nft) ? SquareNFT.fromJSON(object.nft) : undefined,
      spirits: isSet(object.spirits) ? globalThis.Number(object.spirits) : 0,
      stars: isSet(object.stars) ? globalThis.Number(object.stars) : 0,
      totalSpirits: isSet(object.totalSpirits) ? globalThis.Number(object.totalSpirits) : 0,
      weeklySpirits: isSet(object.weeklySpirits) ? globalThis.Number(object.weeklySpirits) : 0,
    };
  },

  toJSON(message: SquareAggregate): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    if (message.owner !== undefined) {
      obj.owner = User.toJSON(message.owner);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.state !== undefined) {
      obj.state = squareStateToJSON(message.state);
    }
    if (message.signatureId !== undefined) {
      obj.signatureId = message.signatureId;
    }
    if (message.joinType !== undefined) {
      obj.joinType = squareJoinTypeToJSON(message.joinType);
    }
    if (message.join?.$case === "public") {
      obj.public = Public.toJSON(message.join.public);
    } else if (message.join?.$case === "private") {
      obj.private = Private.toJSON(message.join.private);
    } else if (message.join?.$case === "tokenGated") {
      obj.tokenGated = TokenGated.toJSON(message.join.tokenGated);
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.introduction !== undefined) {
      obj.introduction = message.introduction;
    }
    if (message.minimumStakingAmountToJoinInEth !== undefined) {
      obj.minimumStakingAmountToJoinInEth = message.minimumStakingAmountToJoinInEth;
    }
    if (message.totalMembersStakingAmountInEth !== undefined) {
      obj.totalMembersStakingAmountInEth = message.totalMembersStakingAmountInEth;
    }
    if (message.multiplier !== undefined) {
      obj.multiplier = message.multiplier;
    }
    if (message.totalPoints !== undefined) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    if (message.capacity !== undefined) {
      obj.capacity = Math.round(message.capacity);
    }
    if (message.occupancy !== undefined) {
      obj.occupancy = Math.round(message.occupancy);
    }
    if (message.occupancyIncludingPending !== undefined) {
      obj.occupancyIncludingPending = Math.round(message.occupancyIncludingPending);
    }
    if (message.pfpBoost !== undefined) {
      obj.pfpBoost = PFPBoost.toJSON(message.pfpBoost);
    }
    if (message.nft !== undefined) {
      obj.nft = SquareNFT.toJSON(message.nft);
    }
    if (message.spirits !== undefined) {
      obj.spirits = Math.round(message.spirits);
    }
    if (message.stars !== undefined) {
      obj.stars = Math.round(message.stars);
    }
    if (message.totalSpirits !== undefined) {
      obj.totalSpirits = Math.round(message.totalSpirits);
    }
    if (message.weeklySpirits !== undefined) {
      obj.weeklySpirits = Math.round(message.weeklySpirits);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SquareAggregate>, I>>(base?: I): SquareAggregate {
    return SquareAggregate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SquareAggregate>, I>>(object: I): SquareAggregate {
    const message = createBaseSquareAggregate();
    message.name = object.name ?? "";
    message.tokenId = object.tokenId ?? "";
    message.owner = (object.owner !== undefined && object.owner !== null) ? User.fromPartial(object.owner) : undefined;
    message.createTime = object.createTime ?? undefined;
    message.state = object.state ?? SquareState.STATE_UNSPECIFIED;
    message.signatureId = object.signatureId ?? "";
    message.joinType = object.joinType ?? SquareJoinType.TYPE_UNSPECIFIED;
    switch (object.join?.$case) {
      case "public": {
        if (object.join?.public !== undefined && object.join?.public !== null) {
          message.join = { $case: "public", public: Public.fromPartial(object.join.public) };
        }
        break;
      }
      case "private": {
        if (object.join?.private !== undefined && object.join?.private !== null) {
          message.join = { $case: "private", private: Private.fromPartial(object.join.private) };
        }
        break;
      }
      case "tokenGated": {
        if (object.join?.tokenGated !== undefined && object.join?.tokenGated !== null) {
          message.join = { $case: "tokenGated", tokenGated: TokenGated.fromPartial(object.join.tokenGated) };
        }
        break;
      }
    }
    message.displayName = object.displayName ?? "";
    message.introduction = object.introduction ?? "";
    message.minimumStakingAmountToJoinInEth = object.minimumStakingAmountToJoinInEth ?? 0;
    message.totalMembersStakingAmountInEth = object.totalMembersStakingAmountInEth ?? 0;
    message.multiplier = object.multiplier ?? 0;
    message.totalPoints = object.totalPoints ?? 0;
    message.capacity = object.capacity ?? 0;
    message.occupancy = object.occupancy ?? 0;
    message.occupancyIncludingPending = object.occupancyIncludingPending ?? 0;
    message.pfpBoost = (object.pfpBoost !== undefined && object.pfpBoost !== null)
      ? PFPBoost.fromPartial(object.pfpBoost)
      : undefined;
    message.nft = (object.nft !== undefined && object.nft !== null) ? SquareNFT.fromPartial(object.nft) : undefined;
    message.spirits = object.spirits ?? 0;
    message.stars = object.stars ?? 0;
    message.totalSpirits = object.totalSpirits ?? 0;
    message.weeklySpirits = object.weeklySpirits ?? 0;
    return message;
  },
};

function createBaseListSquaresAggregateRequest(): ListSquaresAggregateRequest {
  return { pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListSquaresAggregateRequest: MessageFns<ListSquaresAggregateRequest> = {
  encode(message: ListSquaresAggregateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSquaresAggregateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquaresAggregateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquaresAggregateRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListSquaresAggregateRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    if (message.orderBy !== undefined) {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquaresAggregateRequest>, I>>(base?: I): ListSquaresAggregateRequest {
    return ListSquaresAggregateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquaresAggregateRequest>, I>>(object: I): ListSquaresAggregateRequest {
    const message = createBaseListSquaresAggregateRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListSquaresAggregateResponse(): ListSquaresAggregateResponse {
  return { squaresAggregate: [], nextPageToken: "" };
}

export const ListSquaresAggregateResponse: MessageFns<ListSquaresAggregateResponse> = {
  encode(message: ListSquaresAggregateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.squaresAggregate) {
      SquareAggregate.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSquaresAggregateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquaresAggregateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.squaresAggregate.push(SquareAggregate.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquaresAggregateResponse {
    return {
      squaresAggregate: globalThis.Array.isArray(object?.squaresAggregate)
        ? object.squaresAggregate.map((e: any) => SquareAggregate.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSquaresAggregateResponse): unknown {
    const obj: any = {};
    if (message.squaresAggregate?.length) {
      obj.squaresAggregate = message.squaresAggregate.map((e) => SquareAggregate.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquaresAggregateResponse>, I>>(base?: I): ListSquaresAggregateResponse {
    return ListSquaresAggregateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquaresAggregateResponse>, I>>(object: I): ListSquaresAggregateResponse {
    const message = createBaseListSquaresAggregateResponse();
    message.squaresAggregate = object.squaresAggregate?.map((e) => SquareAggregate.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/** AggregateService contains the method to read full aggregate resources. */
export type AggregateServiceService = typeof AggregateServiceService;
export const AggregateServiceService = {
  /** ListPointsAggregate returns the PointsAggregate for the given request. */
  listPointsAggregate: {
    path: "/blast.v1.aggregate.AggregateService/ListPointsAggregate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPointsAggregateRequest) =>
      Buffer.from(ListPointsAggregateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListPointsAggregateRequest.decode(value),
    responseSerialize: (value: ListPointsAggregateResponse) =>
      Buffer.from(ListPointsAggregateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListPointsAggregateResponse.decode(value),
  },
  /** ListSquareMemberRankingsAggregate returns the SquareMemberRankingsAggregate for the given request. */
  listSquareMemberRankingsAggregate: {
    path: "/blast.v1.aggregate.AggregateService/ListSquareMemberRankingsAggregate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSquareMemberRankingsAggregateRequest) =>
      Buffer.from(ListSquareMemberRankingsAggregateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListSquareMemberRankingsAggregateRequest.decode(value),
    responseSerialize: (value: ListSquareMemberRankingsAggregateResponse) =>
      Buffer.from(ListSquareMemberRankingsAggregateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListSquareMemberRankingsAggregateResponse.decode(value),
  },
  /** GetSquareAggregate returns the GetSquareAggregate for the given request. */
  getSquareAggregate: {
    path: "/blast.v1.aggregate.AggregateService/GetSquareAggregate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSquareAggregateRequest) =>
      Buffer.from(GetSquareAggregateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetSquareAggregateRequest.decode(value),
    responseSerialize: (value: SquareAggregate) => Buffer.from(SquareAggregate.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SquareAggregate.decode(value),
  },
  /** ListSquaresAggregate returns the ListSquaresAggregate for the given request. */
  listSquaresAggregate: {
    path: "/blast.v1.aggregate.AggregateService/ListSquaresAggregate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSquaresAggregateRequest) =>
      Buffer.from(ListSquaresAggregateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListSquaresAggregateRequest.decode(value),
    responseSerialize: (value: ListSquaresAggregateResponse) =>
      Buffer.from(ListSquaresAggregateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListSquaresAggregateResponse.decode(value),
  },
} as const;

export interface AggregateServiceServer extends UntypedServiceImplementation {
  /** ListPointsAggregate returns the PointsAggregate for the given request. */
  listPointsAggregate: handleUnaryCall<ListPointsAggregateRequest, ListPointsAggregateResponse>;
  /** ListSquareMemberRankingsAggregate returns the SquareMemberRankingsAggregate for the given request. */
  listSquareMemberRankingsAggregate: handleUnaryCall<
    ListSquareMemberRankingsAggregateRequest,
    ListSquareMemberRankingsAggregateResponse
  >;
  /** GetSquareAggregate returns the GetSquareAggregate for the given request. */
  getSquareAggregate: handleUnaryCall<GetSquareAggregateRequest, SquareAggregate>;
  /** ListSquaresAggregate returns the ListSquaresAggregate for the given request. */
  listSquaresAggregate: handleUnaryCall<ListSquaresAggregateRequest, ListSquaresAggregateResponse>;
}

export interface AggregateServiceClient extends Client {
  /** ListPointsAggregate returns the PointsAggregate for the given request. */
  listPointsAggregate(
    request: ListPointsAggregateRequest,
    callback: (error: ServiceError | null, response: ListPointsAggregateResponse) => void,
  ): ClientUnaryCall;
  listPointsAggregate(
    request: ListPointsAggregateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPointsAggregateResponse) => void,
  ): ClientUnaryCall;
  listPointsAggregate(
    request: ListPointsAggregateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPointsAggregateResponse) => void,
  ): ClientUnaryCall;
  /** ListSquareMemberRankingsAggregate returns the SquareMemberRankingsAggregate for the given request. */
  listSquareMemberRankingsAggregate(
    request: ListSquareMemberRankingsAggregateRequest,
    callback: (error: ServiceError | null, response: ListSquareMemberRankingsAggregateResponse) => void,
  ): ClientUnaryCall;
  listSquareMemberRankingsAggregate(
    request: ListSquareMemberRankingsAggregateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSquareMemberRankingsAggregateResponse) => void,
  ): ClientUnaryCall;
  listSquareMemberRankingsAggregate(
    request: ListSquareMemberRankingsAggregateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSquareMemberRankingsAggregateResponse) => void,
  ): ClientUnaryCall;
  /** GetSquareAggregate returns the GetSquareAggregate for the given request. */
  getSquareAggregate(
    request: GetSquareAggregateRequest,
    callback: (error: ServiceError | null, response: SquareAggregate) => void,
  ): ClientUnaryCall;
  getSquareAggregate(
    request: GetSquareAggregateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SquareAggregate) => void,
  ): ClientUnaryCall;
  getSquareAggregate(
    request: GetSquareAggregateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SquareAggregate) => void,
  ): ClientUnaryCall;
  /** ListSquaresAggregate returns the ListSquaresAggregate for the given request. */
  listSquaresAggregate(
    request: ListSquaresAggregateRequest,
    callback: (error: ServiceError | null, response: ListSquaresAggregateResponse) => void,
  ): ClientUnaryCall;
  listSquaresAggregate(
    request: ListSquaresAggregateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSquaresAggregateResponse) => void,
  ): ClientUnaryCall;
  listSquaresAggregate(
    request: ListSquaresAggregateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSquaresAggregateResponse) => void,
  ): ClientUnaryCall;
}

export const AggregateServiceClient = makeGenericClientConstructor(
  AggregateServiceService,
  "blast.v1.aggregate.AggregateService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AggregateServiceClient;
  service: typeof AggregateServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
