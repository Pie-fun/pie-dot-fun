// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: blast/v1/chain/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { ChainType, chainTypeFromJSON, chainTypeToJSON, chainTypeToNumber } from "../nft/nft";

export enum DelegationType {
  DELEGATION_TYPE_UNSPECIFIED = "DELEGATION_TYPE_UNSPECIFIED",
  DELEGATION_TYPE_ALL = "DELEGATION_TYPE_ALL",
  DELEGATION_TYPE_CONTRACT = "DELEGATION_TYPE_CONTRACT",
  DELEGATION_TYPE_ERC721 = "DELEGATION_TYPE_ERC721",
}

export function delegationTypeFromJSON(object: any): DelegationType {
  switch (object) {
    case 0:
    case "DELEGATION_TYPE_UNSPECIFIED":
      return DelegationType.DELEGATION_TYPE_UNSPECIFIED;
    case 1:
    case "DELEGATION_TYPE_ALL":
      return DelegationType.DELEGATION_TYPE_ALL;
    case 2:
    case "DELEGATION_TYPE_CONTRACT":
      return DelegationType.DELEGATION_TYPE_CONTRACT;
    case 3:
    case "DELEGATION_TYPE_ERC721":
      return DelegationType.DELEGATION_TYPE_ERC721;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DelegationType");
  }
}

export function delegationTypeToJSON(object: DelegationType): string {
  switch (object) {
    case DelegationType.DELEGATION_TYPE_UNSPECIFIED:
      return "DELEGATION_TYPE_UNSPECIFIED";
    case DelegationType.DELEGATION_TYPE_ALL:
      return "DELEGATION_TYPE_ALL";
    case DelegationType.DELEGATION_TYPE_CONTRACT:
      return "DELEGATION_TYPE_CONTRACT";
    case DelegationType.DELEGATION_TYPE_ERC721:
      return "DELEGATION_TYPE_ERC721";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DelegationType");
  }
}

export function delegationTypeToNumber(object: DelegationType): number {
  switch (object) {
    case DelegationType.DELEGATION_TYPE_UNSPECIFIED:
      return 0;
    case DelegationType.DELEGATION_TYPE_ALL:
      return 1;
    case DelegationType.DELEGATION_TYPE_CONTRACT:
      return 2;
    case DelegationType.DELEGATION_TYPE_ERC721:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DelegationType");
  }
}

/** The state of the transaction receipt. */
export enum ReceiptStatus {
  /** RECEIPT_STATUS_FAILED - RECEIPT_STATUS_FAILED is the status code of a transaction if execution failed. */
  RECEIPT_STATUS_FAILED = "RECEIPT_STATUS_FAILED",
  /** RECEIPT_STATUS_SUCCESSFUL - RECEIPT_STATUS_SUCCESSFUL is the status code of a transaction if execution succeeded. */
  RECEIPT_STATUS_SUCCESSFUL = "RECEIPT_STATUS_SUCCESSFUL",
}

export function receiptStatusFromJSON(object: any): ReceiptStatus {
  switch (object) {
    case 0:
    case "RECEIPT_STATUS_FAILED":
      return ReceiptStatus.RECEIPT_STATUS_FAILED;
    case 1:
    case "RECEIPT_STATUS_SUCCESSFUL":
      return ReceiptStatus.RECEIPT_STATUS_SUCCESSFUL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ReceiptStatus");
  }
}

export function receiptStatusToJSON(object: ReceiptStatus): string {
  switch (object) {
    case ReceiptStatus.RECEIPT_STATUS_FAILED:
      return "RECEIPT_STATUS_FAILED";
    case ReceiptStatus.RECEIPT_STATUS_SUCCESSFUL:
      return "RECEIPT_STATUS_SUCCESSFUL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ReceiptStatus");
  }
}

export function receiptStatusToNumber(object: ReceiptStatus): number {
  switch (object) {
    case ReceiptStatus.RECEIPT_STATUS_FAILED:
      return 0;
    case ReceiptStatus.RECEIPT_STATUS_SUCCESSFUL:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ReceiptStatus");
  }
}

export interface QueryReceiptRequest {
  txHash: string;
  /**
   * e.g. "60s", "5m", "1h30m"
   *
   * The amount of time to wait for the transaction to be mined.
   *
   * If the transaction is not mined within this time, server will return 504 Gateway Timeout(DEADLINE_EXCEEDED).
   *
   * The default is 5 minutes.
   *
   * The maximum allowed timeout is 30 minutes. If the value is greater than 30 minutes, server will automatically set it to 30 minutes.
   *
   * If longer timeout is needed, please retry after the previous request times out.
   */
  timeout: string;
}

export interface QueryQueryTransactionCountRequest {
  address: string;
  blockNumber: number;
}

export interface QueryQueryTransactionCountResponse {
  count: number;
}

export interface QueryDelegateCashRequest {
  address: string;
  chains: ChainType[];
}

export interface QueryDelegateCashResponse {
  delegates: Delegate[];
}

export interface QueryStakingContractAddressRequest {
  address: string;
}

export interface QueryStakingContractAddressResponse {
  contractAddress: string;
}

export interface QueryStakingAmountRequest {
  address: string;
}

export interface QueryStakingAmountResponse {
  stakingAmount: string;
}

export interface QueryOwnerOfRequest {
  contractAddress: string;
  tokenId: string;
}

export interface QueryOwnerOfResponse {
  ownerAddress: string;
}

export interface QueryBalanceOfRequest {
  contractAddress: string;
  ownerAddress: string;
}

export interface QueryBalanceOfResponse {
  balance: number;
}

export interface Delegate {
  type: DelegationType;
  from: string;
  to: string;
  contract: string;
  tokenId: string;
}

export interface Receipt {
  status: ReceiptStatus;
  transactionHash: string;
  blockHash: string;
  blockNumber: string;
  cumulativeGasUsed: number;
  gasUsed: number;
  contractAddress: string;
}

export interface MintScoreEvent {
  category?: MintScoreEvent_ScoreCategory | undefined;
  score?: number | undefined;
  address?: string | undefined;
  tokenId?: string | undefined;
}

export enum MintScoreEvent_ScoreCategory {
  SCORE_CATEGORY_UNSPECIFIED = "SCORE_CATEGORY_UNSPECIFIED",
  SINGLE_PLAYER = "SINGLE_PLAYER",
  MULTI_PLAYER = "MULTI_PLAYER",
}

export function mintScoreEvent_ScoreCategoryFromJSON(object: any): MintScoreEvent_ScoreCategory {
  switch (object) {
    case 0:
    case "SCORE_CATEGORY_UNSPECIFIED":
      return MintScoreEvent_ScoreCategory.SCORE_CATEGORY_UNSPECIFIED;
    case 1:
    case "SINGLE_PLAYER":
      return MintScoreEvent_ScoreCategory.SINGLE_PLAYER;
    case 2:
    case "MULTI_PLAYER":
      return MintScoreEvent_ScoreCategory.MULTI_PLAYER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MintScoreEvent_ScoreCategory");
  }
}

export function mintScoreEvent_ScoreCategoryToJSON(object: MintScoreEvent_ScoreCategory): string {
  switch (object) {
    case MintScoreEvent_ScoreCategory.SCORE_CATEGORY_UNSPECIFIED:
      return "SCORE_CATEGORY_UNSPECIFIED";
    case MintScoreEvent_ScoreCategory.SINGLE_PLAYER:
      return "SINGLE_PLAYER";
    case MintScoreEvent_ScoreCategory.MULTI_PLAYER:
      return "MULTI_PLAYER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MintScoreEvent_ScoreCategory");
  }
}

export function mintScoreEvent_ScoreCategoryToNumber(object: MintScoreEvent_ScoreCategory): number {
  switch (object) {
    case MintScoreEvent_ScoreCategory.SCORE_CATEGORY_UNSPECIFIED:
      return 0;
    case MintScoreEvent_ScoreCategory.SINGLE_PLAYER:
      return 1;
    case MintScoreEvent_ScoreCategory.MULTI_PLAYER:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MintScoreEvent_ScoreCategory");
  }
}

export interface DeployTBAAndMintProtoShipEvent {
  profileTba: string;
  tokenId: string;
}

function createBaseQueryReceiptRequest(): QueryReceiptRequest {
  return { txHash: "", timeout: "" };
}

export const QueryReceiptRequest: MessageFns<QueryReceiptRequest> = {
  encode(message: QueryReceiptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.timeout !== "") {
      writer.uint32(18).string(message.timeout);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReceiptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReceiptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeout = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReceiptRequest {
    return {
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      timeout: isSet(object.timeout) ? globalThis.String(object.timeout) : "",
    };
  },

  toJSON(message: QueryReceiptRequest): unknown {
    const obj: any = {};
    if (message.txHash !== undefined) {
      obj.txHash = message.txHash;
    }
    if (message.timeout !== undefined) {
      obj.timeout = message.timeout;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReceiptRequest>, I>>(base?: I): QueryReceiptRequest {
    return QueryReceiptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReceiptRequest>, I>>(object: I): QueryReceiptRequest {
    const message = createBaseQueryReceiptRequest();
    message.txHash = object.txHash ?? "";
    message.timeout = object.timeout ?? "";
    return message;
  },
};

function createBaseQueryQueryTransactionCountRequest(): QueryQueryTransactionCountRequest {
  return { address: "", blockNumber: 0 };
}

export const QueryQueryTransactionCountRequest: MessageFns<QueryQueryTransactionCountRequest> = {
  encode(message: QueryQueryTransactionCountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.blockNumber !== 0) {
      writer.uint32(16).uint64(message.blockNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryQueryTransactionCountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQueryTransactionCountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blockNumber = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQueryTransactionCountRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      blockNumber: isSet(object.blockNumber) ? globalThis.Number(object.blockNumber) : 0,
    };
  },

  toJSON(message: QueryQueryTransactionCountRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.blockNumber !== undefined) {
      obj.blockNumber = Math.round(message.blockNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQueryTransactionCountRequest>, I>>(
    base?: I,
  ): QueryQueryTransactionCountRequest {
    return QueryQueryTransactionCountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQueryTransactionCountRequest>, I>>(
    object: I,
  ): QueryQueryTransactionCountRequest {
    const message = createBaseQueryQueryTransactionCountRequest();
    message.address = object.address ?? "";
    message.blockNumber = object.blockNumber ?? 0;
    return message;
  },
};

function createBaseQueryQueryTransactionCountResponse(): QueryQueryTransactionCountResponse {
  return { count: 0 };
}

export const QueryQueryTransactionCountResponse: MessageFns<QueryQueryTransactionCountResponse> = {
  encode(message: QueryQueryTransactionCountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).uint64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryQueryTransactionCountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQueryTransactionCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQueryTransactionCountResponse {
    return { count: isSet(object.count) ? globalThis.Number(object.count) : 0 };
  },

  toJSON(message: QueryQueryTransactionCountResponse): unknown {
    const obj: any = {};
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQueryTransactionCountResponse>, I>>(
    base?: I,
  ): QueryQueryTransactionCountResponse {
    return QueryQueryTransactionCountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQueryTransactionCountResponse>, I>>(
    object: I,
  ): QueryQueryTransactionCountResponse {
    const message = createBaseQueryQueryTransactionCountResponse();
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseQueryDelegateCashRequest(): QueryDelegateCashRequest {
  return { address: "", chains: [] };
}

export const QueryDelegateCashRequest: MessageFns<QueryDelegateCashRequest> = {
  encode(message: QueryDelegateCashRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    writer.uint32(18).fork();
    for (const v of message.chains) {
      writer.int32(chainTypeToNumber(v));
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDelegateCashRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDelegateCashRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.chains.push(chainTypeFromJSON(reader.int32()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.chains.push(chainTypeFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDelegateCashRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      chains: globalThis.Array.isArray(object?.chains) ? object.chains.map((e: any) => chainTypeFromJSON(e)) : [],
    };
  },

  toJSON(message: QueryDelegateCashRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => chainTypeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryDelegateCashRequest>, I>>(base?: I): QueryDelegateCashRequest {
    return QueryDelegateCashRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryDelegateCashRequest>, I>>(object: I): QueryDelegateCashRequest {
    const message = createBaseQueryDelegateCashRequest();
    message.address = object.address ?? "";
    message.chains = object.chains?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryDelegateCashResponse(): QueryDelegateCashResponse {
  return { delegates: [] };
}

export const QueryDelegateCashResponse: MessageFns<QueryDelegateCashResponse> = {
  encode(message: QueryDelegateCashResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.delegates) {
      Delegate.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDelegateCashResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDelegateCashResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delegates.push(Delegate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDelegateCashResponse {
    return {
      delegates: globalThis.Array.isArray(object?.delegates)
        ? object.delegates.map((e: any) => Delegate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryDelegateCashResponse): unknown {
    const obj: any = {};
    if (message.delegates?.length) {
      obj.delegates = message.delegates.map((e) => Delegate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryDelegateCashResponse>, I>>(base?: I): QueryDelegateCashResponse {
    return QueryDelegateCashResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryDelegateCashResponse>, I>>(object: I): QueryDelegateCashResponse {
    const message = createBaseQueryDelegateCashResponse();
    message.delegates = object.delegates?.map((e) => Delegate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryStakingContractAddressRequest(): QueryStakingContractAddressRequest {
  return { address: "" };
}

export const QueryStakingContractAddressRequest: MessageFns<QueryStakingContractAddressRequest> = {
  encode(message: QueryStakingContractAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStakingContractAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStakingContractAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStakingContractAddressRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryStakingContractAddressRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStakingContractAddressRequest>, I>>(
    base?: I,
  ): QueryStakingContractAddressRequest {
    return QueryStakingContractAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStakingContractAddressRequest>, I>>(
    object: I,
  ): QueryStakingContractAddressRequest {
    const message = createBaseQueryStakingContractAddressRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryStakingContractAddressResponse(): QueryStakingContractAddressResponse {
  return { contractAddress: "" };
}

export const QueryStakingContractAddressResponse: MessageFns<QueryStakingContractAddressResponse> = {
  encode(message: QueryStakingContractAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStakingContractAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStakingContractAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStakingContractAddressResponse {
    return { contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "" };
  },

  toJSON(message: QueryStakingContractAddressResponse): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = message.contractAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStakingContractAddressResponse>, I>>(
    base?: I,
  ): QueryStakingContractAddressResponse {
    return QueryStakingContractAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStakingContractAddressResponse>, I>>(
    object: I,
  ): QueryStakingContractAddressResponse {
    const message = createBaseQueryStakingContractAddressResponse();
    message.contractAddress = object.contractAddress ?? "";
    return message;
  },
};

function createBaseQueryStakingAmountRequest(): QueryStakingAmountRequest {
  return { address: "" };
}

export const QueryStakingAmountRequest: MessageFns<QueryStakingAmountRequest> = {
  encode(message: QueryStakingAmountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStakingAmountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStakingAmountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStakingAmountRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryStakingAmountRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStakingAmountRequest>, I>>(base?: I): QueryStakingAmountRequest {
    return QueryStakingAmountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStakingAmountRequest>, I>>(object: I): QueryStakingAmountRequest {
    const message = createBaseQueryStakingAmountRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryStakingAmountResponse(): QueryStakingAmountResponse {
  return { stakingAmount: "" };
}

export const QueryStakingAmountResponse: MessageFns<QueryStakingAmountResponse> = {
  encode(message: QueryStakingAmountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stakingAmount !== "") {
      writer.uint32(10).string(message.stakingAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStakingAmountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStakingAmountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stakingAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStakingAmountResponse {
    return { stakingAmount: isSet(object.stakingAmount) ? globalThis.String(object.stakingAmount) : "" };
  },

  toJSON(message: QueryStakingAmountResponse): unknown {
    const obj: any = {};
    if (message.stakingAmount !== undefined) {
      obj.stakingAmount = message.stakingAmount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStakingAmountResponse>, I>>(base?: I): QueryStakingAmountResponse {
    return QueryStakingAmountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStakingAmountResponse>, I>>(object: I): QueryStakingAmountResponse {
    const message = createBaseQueryStakingAmountResponse();
    message.stakingAmount = object.stakingAmount ?? "";
    return message;
  },
};

function createBaseQueryOwnerOfRequest(): QueryOwnerOfRequest {
  return { contractAddress: "", tokenId: "" };
}

export const QueryOwnerOfRequest: MessageFns<QueryOwnerOfRequest> = {
  encode(message: QueryOwnerOfRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOwnerOfRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOwnerOfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOwnerOfRequest {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: QueryOwnerOfRequest): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = message.contractAddress;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOwnerOfRequest>, I>>(base?: I): QueryOwnerOfRequest {
    return QueryOwnerOfRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOwnerOfRequest>, I>>(object: I): QueryOwnerOfRequest {
    const message = createBaseQueryOwnerOfRequest();
    message.contractAddress = object.contractAddress ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseQueryOwnerOfResponse(): QueryOwnerOfResponse {
  return { ownerAddress: "" };
}

export const QueryOwnerOfResponse: MessageFns<QueryOwnerOfResponse> = {
  encode(message: QueryOwnerOfResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOwnerOfResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOwnerOfResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOwnerOfResponse {
    return { ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "" };
  },

  toJSON(message: QueryOwnerOfResponse): unknown {
    const obj: any = {};
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOwnerOfResponse>, I>>(base?: I): QueryOwnerOfResponse {
    return QueryOwnerOfResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOwnerOfResponse>, I>>(object: I): QueryOwnerOfResponse {
    const message = createBaseQueryOwnerOfResponse();
    message.ownerAddress = object.ownerAddress ?? "";
    return message;
  },
};

function createBaseQueryBalanceOfRequest(): QueryBalanceOfRequest {
  return { contractAddress: "", ownerAddress: "" };
}

export const QueryBalanceOfRequest: MessageFns<QueryBalanceOfRequest> = {
  encode(message: QueryBalanceOfRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(18).string(message.ownerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceOfRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceOfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceOfRequest {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
    };
  },

  toJSON(message: QueryBalanceOfRequest): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = message.contractAddress;
    }
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBalanceOfRequest>, I>>(base?: I): QueryBalanceOfRequest {
    return QueryBalanceOfRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBalanceOfRequest>, I>>(object: I): QueryBalanceOfRequest {
    const message = createBaseQueryBalanceOfRequest();
    message.contractAddress = object.contractAddress ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    return message;
  },
};

function createBaseQueryBalanceOfResponse(): QueryBalanceOfResponse {
  return { balance: 0 };
}

export const QueryBalanceOfResponse: MessageFns<QueryBalanceOfResponse> = {
  encode(message: QueryBalanceOfResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== 0) {
      writer.uint32(8).uint32(message.balance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBalanceOfResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceOfResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.balance = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceOfResponse {
    return { balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0 };
  },

  toJSON(message: QueryBalanceOfResponse): unknown {
    const obj: any = {};
    if (message.balance !== undefined) {
      obj.balance = Math.round(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBalanceOfResponse>, I>>(base?: I): QueryBalanceOfResponse {
    return QueryBalanceOfResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBalanceOfResponse>, I>>(object: I): QueryBalanceOfResponse {
    const message = createBaseQueryBalanceOfResponse();
    message.balance = object.balance ?? 0;
    return message;
  },
};

function createBaseDelegate(): Delegate {
  return { type: DelegationType.DELEGATION_TYPE_UNSPECIFIED, from: "", to: "", contract: "", tokenId: "" };
}

export const Delegate: MessageFns<Delegate> = {
  encode(message: Delegate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== DelegationType.DELEGATION_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(delegationTypeToNumber(message.type));
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(26).string(message.to);
    }
    if (message.contract !== "") {
      writer.uint32(34).string(message.contract);
    }
    if (message.tokenId !== "") {
      writer.uint32(42).string(message.tokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Delegate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = delegationTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contract = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Delegate {
    return {
      type: isSet(object.type) ? delegationTypeFromJSON(object.type) : DelegationType.DELEGATION_TYPE_UNSPECIFIED,
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      contract: isSet(object.contract) ? globalThis.String(object.contract) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: Delegate): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = delegationTypeToJSON(message.type);
    }
    if (message.from !== undefined) {
      obj.from = message.from;
    }
    if (message.to !== undefined) {
      obj.to = message.to;
    }
    if (message.contract !== undefined) {
      obj.contract = message.contract;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Delegate>, I>>(base?: I): Delegate {
    return Delegate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Delegate>, I>>(object: I): Delegate {
    const message = createBaseDelegate();
    message.type = object.type ?? DelegationType.DELEGATION_TYPE_UNSPECIFIED;
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.contract = object.contract ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseReceipt(): Receipt {
  return {
    status: ReceiptStatus.RECEIPT_STATUS_FAILED,
    transactionHash: "",
    blockHash: "",
    blockNumber: "",
    cumulativeGasUsed: 0,
    gasUsed: 0,
    contractAddress: "",
  };
}

export const Receipt: MessageFns<Receipt> = {
  encode(message: Receipt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== ReceiptStatus.RECEIPT_STATUS_FAILED) {
      writer.uint32(8).int32(receiptStatusToNumber(message.status));
    }
    if (message.transactionHash !== "") {
      writer.uint32(18).string(message.transactionHash);
    }
    if (message.blockHash !== "") {
      writer.uint32(26).string(message.blockHash);
    }
    if (message.blockNumber !== "") {
      writer.uint32(34).string(message.blockNumber);
    }
    if (message.cumulativeGasUsed !== 0) {
      writer.uint32(40).uint64(message.cumulativeGasUsed);
    }
    if (message.gasUsed !== 0) {
      writer.uint32(48).uint64(message.gasUsed);
    }
    if (message.contractAddress !== "") {
      writer.uint32(58).string(message.contractAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = receiptStatusFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactionHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.blockNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.cumulativeGasUsed = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gasUsed = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt {
    return {
      status: isSet(object.status) ? receiptStatusFromJSON(object.status) : ReceiptStatus.RECEIPT_STATUS_FAILED,
      transactionHash: isSet(object.transactionHash) ? globalThis.String(object.transactionHash) : "",
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      blockNumber: isSet(object.blockNumber) ? globalThis.String(object.blockNumber) : "",
      cumulativeGasUsed: isSet(object.cumulativeGasUsed) ? globalThis.Number(object.cumulativeGasUsed) : 0,
      gasUsed: isSet(object.gasUsed) ? globalThis.Number(object.gasUsed) : 0,
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
    };
  },

  toJSON(message: Receipt): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = receiptStatusToJSON(message.status);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = message.transactionHash;
    }
    if (message.blockHash !== undefined) {
      obj.blockHash = message.blockHash;
    }
    if (message.blockNumber !== undefined) {
      obj.blockNumber = message.blockNumber;
    }
    if (message.cumulativeGasUsed !== undefined) {
      obj.cumulativeGasUsed = Math.round(message.cumulativeGasUsed);
    }
    if (message.gasUsed !== undefined) {
      obj.gasUsed = Math.round(message.gasUsed);
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = message.contractAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt>, I>>(base?: I): Receipt {
    return Receipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt>, I>>(object: I): Receipt {
    const message = createBaseReceipt();
    message.status = object.status ?? ReceiptStatus.RECEIPT_STATUS_FAILED;
    message.transactionHash = object.transactionHash ?? "";
    message.blockHash = object.blockHash ?? "";
    message.blockNumber = object.blockNumber ?? "";
    message.cumulativeGasUsed = object.cumulativeGasUsed ?? 0;
    message.gasUsed = object.gasUsed ?? 0;
    message.contractAddress = object.contractAddress ?? "";
    return message;
  },
};

function createBaseMintScoreEvent(): MintScoreEvent {
  return { category: undefined, score: undefined, address: undefined, tokenId: undefined };
}

export const MintScoreEvent: MessageFns<MintScoreEvent> = {
  encode(message: MintScoreEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== undefined) {
      writer.uint32(8).int32(mintScoreEvent_ScoreCategoryToNumber(message.category));
    }
    if (message.score !== undefined) {
      writer.uint32(16).uint64(message.score);
    }
    if (message.address !== undefined) {
      writer.uint32(26).string(message.address);
    }
    if (message.tokenId !== undefined) {
      writer.uint32(34).string(message.tokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MintScoreEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintScoreEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.category = mintScoreEvent_ScoreCategoryFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintScoreEvent {
    return {
      category: isSet(object.category) ? mintScoreEvent_ScoreCategoryFromJSON(object.category) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : undefined,
    };
  },

  toJSON(message: MintScoreEvent): unknown {
    const obj: any = {};
    if (message.category !== undefined) {
      obj.category = mintScoreEvent_ScoreCategoryToJSON(message.category);
    }
    if (message.score !== undefined) {
      obj.score = Math.round(message.score);
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MintScoreEvent>, I>>(base?: I): MintScoreEvent {
    return MintScoreEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MintScoreEvent>, I>>(object: I): MintScoreEvent {
    const message = createBaseMintScoreEvent();
    message.category = object.category ?? undefined;
    message.score = object.score ?? undefined;
    message.address = object.address ?? undefined;
    message.tokenId = object.tokenId ?? undefined;
    return message;
  },
};

function createBaseDeployTBAAndMintProtoShipEvent(): DeployTBAAndMintProtoShipEvent {
  return { profileTba: "", tokenId: "" };
}

export const DeployTBAAndMintProtoShipEvent: MessageFns<DeployTBAAndMintProtoShipEvent> = {
  encode(message: DeployTBAAndMintProtoShipEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileTba !== "") {
      writer.uint32(10).string(message.profileTba);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployTBAAndMintProtoShipEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployTBAAndMintProtoShipEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profileTba = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployTBAAndMintProtoShipEvent {
    return {
      profileTba: isSet(object.profileTba) ? globalThis.String(object.profileTba) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: DeployTBAAndMintProtoShipEvent): unknown {
    const obj: any = {};
    if (message.profileTba !== undefined) {
      obj.profileTba = message.profileTba;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeployTBAAndMintProtoShipEvent>, I>>(base?: I): DeployTBAAndMintProtoShipEvent {
    return DeployTBAAndMintProtoShipEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeployTBAAndMintProtoShipEvent>, I>>(
    object: I,
  ): DeployTBAAndMintProtoShipEvent {
    const message = createBaseDeployTBAAndMintProtoShipEvent();
    message.profileTba = object.profileTba ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

/** ChainQueryService is the service that handles all chain requests. */
export type ChainQueryServiceService = typeof ChainQueryServiceService;
export const ChainQueryServiceService = {
  queryReceipt: {
    path: "/blast.v1.chain.ChainQueryService/QueryReceipt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryReceiptRequest) => Buffer.from(QueryReceiptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryReceiptRequest.decode(value),
    responseSerialize: (value: Receipt) => Buffer.from(Receipt.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Receipt.decode(value),
  },
  queryTransactionCount: {
    path: "/blast.v1.chain.ChainQueryService/QueryTransactionCount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryQueryTransactionCountRequest) =>
      Buffer.from(QueryQueryTransactionCountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryQueryTransactionCountRequest.decode(value),
    responseSerialize: (value: QueryQueryTransactionCountResponse) =>
      Buffer.from(QueryQueryTransactionCountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryQueryTransactionCountResponse.decode(value),
  },
  queryDelegateCash: {
    path: "/blast.v1.chain.ChainQueryService/QueryDelegateCash",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryDelegateCashRequest) => Buffer.from(QueryDelegateCashRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryDelegateCashRequest.decode(value),
    responseSerialize: (value: QueryDelegateCashResponse) =>
      Buffer.from(QueryDelegateCashResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryDelegateCashResponse.decode(value),
  },
  queryStakingContractAddress: {
    path: "/blast.v1.chain.ChainQueryService/QueryStakingContractAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryStakingContractAddressRequest) =>
      Buffer.from(QueryStakingContractAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryStakingContractAddressRequest.decode(value),
    responseSerialize: (value: QueryStakingContractAddressResponse) =>
      Buffer.from(QueryStakingContractAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryStakingContractAddressResponse.decode(value),
  },
  queryStakingAmount: {
    path: "/blast.v1.chain.ChainQueryService/QueryStakingAmount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryStakingAmountRequest) =>
      Buffer.from(QueryStakingAmountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryStakingAmountRequest.decode(value),
    responseSerialize: (value: QueryStakingAmountResponse) =>
      Buffer.from(QueryStakingAmountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryStakingAmountResponse.decode(value),
  },
  queryOwnerOf: {
    path: "/blast.v1.chain.ChainQueryService/QueryOwnerOf",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryOwnerOfRequest) => Buffer.from(QueryOwnerOfRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryOwnerOfRequest.decode(value),
    responseSerialize: (value: QueryOwnerOfResponse) => Buffer.from(QueryOwnerOfResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryOwnerOfResponse.decode(value),
  },
  queryBalanceOf: {
    path: "/blast.v1.chain.ChainQueryService/QueryBalanceOf",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryBalanceOfRequest) => Buffer.from(QueryBalanceOfRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryBalanceOfRequest.decode(value),
    responseSerialize: (value: QueryBalanceOfResponse) => Buffer.from(QueryBalanceOfResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryBalanceOfResponse.decode(value),
  },
} as const;

export interface ChainQueryServiceServer extends UntypedServiceImplementation {
  queryReceipt: handleUnaryCall<QueryReceiptRequest, Receipt>;
  queryTransactionCount: handleUnaryCall<QueryQueryTransactionCountRequest, QueryQueryTransactionCountResponse>;
  queryDelegateCash: handleUnaryCall<QueryDelegateCashRequest, QueryDelegateCashResponse>;
  queryStakingContractAddress: handleUnaryCall<QueryStakingContractAddressRequest, QueryStakingContractAddressResponse>;
  queryStakingAmount: handleUnaryCall<QueryStakingAmountRequest, QueryStakingAmountResponse>;
  queryOwnerOf: handleUnaryCall<QueryOwnerOfRequest, QueryOwnerOfResponse>;
  queryBalanceOf: handleUnaryCall<QueryBalanceOfRequest, QueryBalanceOfResponse>;
}

export interface ChainQueryServiceClient extends Client {
  queryReceipt(
    request: QueryReceiptRequest,
    callback: (error: ServiceError | null, response: Receipt) => void,
  ): ClientUnaryCall;
  queryReceipt(
    request: QueryReceiptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Receipt) => void,
  ): ClientUnaryCall;
  queryReceipt(
    request: QueryReceiptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Receipt) => void,
  ): ClientUnaryCall;
  queryTransactionCount(
    request: QueryQueryTransactionCountRequest,
    callback: (error: ServiceError | null, response: QueryQueryTransactionCountResponse) => void,
  ): ClientUnaryCall;
  queryTransactionCount(
    request: QueryQueryTransactionCountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryQueryTransactionCountResponse) => void,
  ): ClientUnaryCall;
  queryTransactionCount(
    request: QueryQueryTransactionCountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryQueryTransactionCountResponse) => void,
  ): ClientUnaryCall;
  queryDelegateCash(
    request: QueryDelegateCashRequest,
    callback: (error: ServiceError | null, response: QueryDelegateCashResponse) => void,
  ): ClientUnaryCall;
  queryDelegateCash(
    request: QueryDelegateCashRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryDelegateCashResponse) => void,
  ): ClientUnaryCall;
  queryDelegateCash(
    request: QueryDelegateCashRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryDelegateCashResponse) => void,
  ): ClientUnaryCall;
  queryStakingContractAddress(
    request: QueryStakingContractAddressRequest,
    callback: (error: ServiceError | null, response: QueryStakingContractAddressResponse) => void,
  ): ClientUnaryCall;
  queryStakingContractAddress(
    request: QueryStakingContractAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryStakingContractAddressResponse) => void,
  ): ClientUnaryCall;
  queryStakingContractAddress(
    request: QueryStakingContractAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryStakingContractAddressResponse) => void,
  ): ClientUnaryCall;
  queryStakingAmount(
    request: QueryStakingAmountRequest,
    callback: (error: ServiceError | null, response: QueryStakingAmountResponse) => void,
  ): ClientUnaryCall;
  queryStakingAmount(
    request: QueryStakingAmountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryStakingAmountResponse) => void,
  ): ClientUnaryCall;
  queryStakingAmount(
    request: QueryStakingAmountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryStakingAmountResponse) => void,
  ): ClientUnaryCall;
  queryOwnerOf(
    request: QueryOwnerOfRequest,
    callback: (error: ServiceError | null, response: QueryOwnerOfResponse) => void,
  ): ClientUnaryCall;
  queryOwnerOf(
    request: QueryOwnerOfRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryOwnerOfResponse) => void,
  ): ClientUnaryCall;
  queryOwnerOf(
    request: QueryOwnerOfRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryOwnerOfResponse) => void,
  ): ClientUnaryCall;
  queryBalanceOf(
    request: QueryBalanceOfRequest,
    callback: (error: ServiceError | null, response: QueryBalanceOfResponse) => void,
  ): ClientUnaryCall;
  queryBalanceOf(
    request: QueryBalanceOfRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryBalanceOfResponse) => void,
  ): ClientUnaryCall;
  queryBalanceOf(
    request: QueryBalanceOfRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryBalanceOfResponse) => void,
  ): ClientUnaryCall;
}

export const ChainQueryServiceClient = makeGenericClientConstructor(
  ChainQueryServiceService,
  "blast.v1.chain.ChainQueryService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ChainQueryServiceClient;
  service: typeof ChainQueryServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
