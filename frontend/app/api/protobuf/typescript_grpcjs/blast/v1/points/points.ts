// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: blast/v1/points/points.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { User } from "../user/user";

/** PointsType 을 유저의 행동군에 따라 2차 그룹핑함. */
export enum PointsTypeBehaviorGroup {
  /** GROUP_UNSPECIFIED - default value. this value is unused. */
  GROUP_UNSPECIFIED = "GROUP_UNSPECIFIED",
  REFERRAL = "REFERRAL",
  STAKING = "STAKING",
  ACTIVITY = "ACTIVITY",
  BONUS = "BONUS",
}

export function pointsTypeBehaviorGroupFromJSON(object: any): PointsTypeBehaviorGroup {
  switch (object) {
    case 0:
    case "GROUP_UNSPECIFIED":
      return PointsTypeBehaviorGroup.GROUP_UNSPECIFIED;
    case 1:
    case "REFERRAL":
      return PointsTypeBehaviorGroup.REFERRAL;
    case 2:
    case "STAKING":
      return PointsTypeBehaviorGroup.STAKING;
    case 3:
    case "ACTIVITY":
      return PointsTypeBehaviorGroup.ACTIVITY;
    case 4:
    case "BONUS":
      return PointsTypeBehaviorGroup.BONUS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PointsTypeBehaviorGroup");
  }
}

export function pointsTypeBehaviorGroupToJSON(object: PointsTypeBehaviorGroup): string {
  switch (object) {
    case PointsTypeBehaviorGroup.GROUP_UNSPECIFIED:
      return "GROUP_UNSPECIFIED";
    case PointsTypeBehaviorGroup.REFERRAL:
      return "REFERRAL";
    case PointsTypeBehaviorGroup.STAKING:
      return "STAKING";
    case PointsTypeBehaviorGroup.ACTIVITY:
      return "ACTIVITY";
    case PointsTypeBehaviorGroup.BONUS:
      return "BONUS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PointsTypeBehaviorGroup");
  }
}

export function pointsTypeBehaviorGroupToNumber(object: PointsTypeBehaviorGroup): number {
  switch (object) {
    case PointsTypeBehaviorGroup.GROUP_UNSPECIFIED:
      return 0;
    case PointsTypeBehaviorGroup.REFERRAL:
      return 1;
    case PointsTypeBehaviorGroup.STAKING:
      return 2;
    case PointsTypeBehaviorGroup.ACTIVITY:
      return 3;
    case PointsTypeBehaviorGroup.BONUS:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PointsTypeBehaviorGroup");
  }
}

export enum PointsType {
  /** TYPE_UNKNOWN - default value. this value is unused. */
  TYPE_UNKNOWN = "TYPE_UNKNOWN",
  WELCOME = "WELCOME",
  REFERRAL_REFFERED_BY = "REFERRAL_REFFERED_BY",
  REFERRAL_REFERRER_BONUS = "REFERRAL_REFERRER_BONUS",
  STAKING_INTEREST = "STAKING_INTEREST",
  ACTIVITY_DAILY_CHECKIN = "ACTIVITY_DAILY_CHECKIN",
  ACTIVITY_COMMUNITY_EVENT_WINNER = "ACTIVITY_COMMUNITY_EVENT_WINNER",
  ACTIVITY_COMMUNITY_CONTRIBUTION = "ACTIVITY_COMMUNITY_CONTRIBUTION",
  ACTIVITY_GM = "ACTIVITY_GM",
  ACTIVITY_SQUARE_BEBOB_SUMMON = "ACTIVITY_SQUARE_BEBOB_SUMMON",
  ACTIVITY_SQUARE_BEBOB_ATTACK = "ACTIVITY_SQUARE_BEBOB_ATTACK",
  ACTIVITY_SCORE_UPLOAD = "ACTIVITY_SCORE_UPLOAD",
  ACTIVITY_SCORE_LEADERBOARD_WINNER = "ACTIVITY_SCORE_LEADERBOARD_WINNER",
  ACTIVITY_SCORE_LEADERBOARD_RAFFLE = "ACTIVITY_SCORE_LEADERBOARD_RAFFLE",
  BONUS_SQUARE_OWNER = "BONUS_SQUARE_OWNER",
  BONUS_SQUARE_MEMBER = "BONUS_SQUARE_MEMBER",
}

export function pointsTypeFromJSON(object: any): PointsType {
  switch (object) {
    case 0:
    case "TYPE_UNKNOWN":
      return PointsType.TYPE_UNKNOWN;
    case 1:
    case "WELCOME":
      return PointsType.WELCOME;
    case 100:
    case "REFERRAL_REFFERED_BY":
      return PointsType.REFERRAL_REFFERED_BY;
    case 101:
    case "REFERRAL_REFERRER_BONUS":
      return PointsType.REFERRAL_REFERRER_BONUS;
    case 200:
    case "STAKING_INTEREST":
      return PointsType.STAKING_INTEREST;
    case 300:
    case "ACTIVITY_DAILY_CHECKIN":
      return PointsType.ACTIVITY_DAILY_CHECKIN;
    case 301:
    case "ACTIVITY_COMMUNITY_EVENT_WINNER":
      return PointsType.ACTIVITY_COMMUNITY_EVENT_WINNER;
    case 302:
    case "ACTIVITY_COMMUNITY_CONTRIBUTION":
      return PointsType.ACTIVITY_COMMUNITY_CONTRIBUTION;
    case 303:
    case "ACTIVITY_GM":
      return PointsType.ACTIVITY_GM;
    case 304:
    case "ACTIVITY_SQUARE_BEBOB_SUMMON":
      return PointsType.ACTIVITY_SQUARE_BEBOB_SUMMON;
    case 305:
    case "ACTIVITY_SQUARE_BEBOB_ATTACK":
      return PointsType.ACTIVITY_SQUARE_BEBOB_ATTACK;
    case 306:
    case "ACTIVITY_SCORE_UPLOAD":
      return PointsType.ACTIVITY_SCORE_UPLOAD;
    case 307:
    case "ACTIVITY_SCORE_LEADERBOARD_WINNER":
      return PointsType.ACTIVITY_SCORE_LEADERBOARD_WINNER;
    case 308:
    case "ACTIVITY_SCORE_LEADERBOARD_RAFFLE":
      return PointsType.ACTIVITY_SCORE_LEADERBOARD_RAFFLE;
    case 400:
    case "BONUS_SQUARE_OWNER":
      return PointsType.BONUS_SQUARE_OWNER;
    case 401:
    case "BONUS_SQUARE_MEMBER":
      return PointsType.BONUS_SQUARE_MEMBER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PointsType");
  }
}

export function pointsTypeToJSON(object: PointsType): string {
  switch (object) {
    case PointsType.TYPE_UNKNOWN:
      return "TYPE_UNKNOWN";
    case PointsType.WELCOME:
      return "WELCOME";
    case PointsType.REFERRAL_REFFERED_BY:
      return "REFERRAL_REFFERED_BY";
    case PointsType.REFERRAL_REFERRER_BONUS:
      return "REFERRAL_REFERRER_BONUS";
    case PointsType.STAKING_INTEREST:
      return "STAKING_INTEREST";
    case PointsType.ACTIVITY_DAILY_CHECKIN:
      return "ACTIVITY_DAILY_CHECKIN";
    case PointsType.ACTIVITY_COMMUNITY_EVENT_WINNER:
      return "ACTIVITY_COMMUNITY_EVENT_WINNER";
    case PointsType.ACTIVITY_COMMUNITY_CONTRIBUTION:
      return "ACTIVITY_COMMUNITY_CONTRIBUTION";
    case PointsType.ACTIVITY_GM:
      return "ACTIVITY_GM";
    case PointsType.ACTIVITY_SQUARE_BEBOB_SUMMON:
      return "ACTIVITY_SQUARE_BEBOB_SUMMON";
    case PointsType.ACTIVITY_SQUARE_BEBOB_ATTACK:
      return "ACTIVITY_SQUARE_BEBOB_ATTACK";
    case PointsType.ACTIVITY_SCORE_UPLOAD:
      return "ACTIVITY_SCORE_UPLOAD";
    case PointsType.ACTIVITY_SCORE_LEADERBOARD_WINNER:
      return "ACTIVITY_SCORE_LEADERBOARD_WINNER";
    case PointsType.ACTIVITY_SCORE_LEADERBOARD_RAFFLE:
      return "ACTIVITY_SCORE_LEADERBOARD_RAFFLE";
    case PointsType.BONUS_SQUARE_OWNER:
      return "BONUS_SQUARE_OWNER";
    case PointsType.BONUS_SQUARE_MEMBER:
      return "BONUS_SQUARE_MEMBER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PointsType");
  }
}

export function pointsTypeToNumber(object: PointsType): number {
  switch (object) {
    case PointsType.TYPE_UNKNOWN:
      return 0;
    case PointsType.WELCOME:
      return 1;
    case PointsType.REFERRAL_REFFERED_BY:
      return 100;
    case PointsType.REFERRAL_REFERRER_BONUS:
      return 101;
    case PointsType.STAKING_INTEREST:
      return 200;
    case PointsType.ACTIVITY_DAILY_CHECKIN:
      return 300;
    case PointsType.ACTIVITY_COMMUNITY_EVENT_WINNER:
      return 301;
    case PointsType.ACTIVITY_COMMUNITY_CONTRIBUTION:
      return 302;
    case PointsType.ACTIVITY_GM:
      return 303;
    case PointsType.ACTIVITY_SQUARE_BEBOB_SUMMON:
      return 304;
    case PointsType.ACTIVITY_SQUARE_BEBOB_ATTACK:
      return 305;
    case PointsType.ACTIVITY_SCORE_UPLOAD:
      return 306;
    case PointsType.ACTIVITY_SCORE_LEADERBOARD_WINNER:
      return 307;
    case PointsType.ACTIVITY_SCORE_LEADERBOARD_RAFFLE:
      return 308;
    case PointsType.BONUS_SQUARE_OWNER:
      return 400;
    case PointsType.BONUS_SQUARE_MEMBER:
      return 401;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PointsType");
  }
}

export enum MultiplierType {
  /** MULTIPLIER_TYPE_UNSPECIFIED - default value. this value is unused. */
  MULTIPLIER_TYPE_UNSPECIFIED = "MULTIPLIER_TYPE_UNSPECIFIED",
  SQUARE_OWNER_BONUS = "SQUARE_OWNER_BONUS",
  SQUARE_MULTIPLIER = "SQUARE_MULTIPLIER",
  SQUARE_PFP_COLLECTION_BOOST = "SQUARE_PFP_COLLECTION_BOOST",
}

export function multiplierTypeFromJSON(object: any): MultiplierType {
  switch (object) {
    case 0:
    case "MULTIPLIER_TYPE_UNSPECIFIED":
      return MultiplierType.MULTIPLIER_TYPE_UNSPECIFIED;
    case 1:
    case "SQUARE_OWNER_BONUS":
      return MultiplierType.SQUARE_OWNER_BONUS;
    case 2:
    case "SQUARE_MULTIPLIER":
      return MultiplierType.SQUARE_MULTIPLIER;
    case 3:
    case "SQUARE_PFP_COLLECTION_BOOST":
      return MultiplierType.SQUARE_PFP_COLLECTION_BOOST;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MultiplierType");
  }
}

export function multiplierTypeToJSON(object: MultiplierType): string {
  switch (object) {
    case MultiplierType.MULTIPLIER_TYPE_UNSPECIFIED:
      return "MULTIPLIER_TYPE_UNSPECIFIED";
    case MultiplierType.SQUARE_OWNER_BONUS:
      return "SQUARE_OWNER_BONUS";
    case MultiplierType.SQUARE_MULTIPLIER:
      return "SQUARE_MULTIPLIER";
    case MultiplierType.SQUARE_PFP_COLLECTION_BOOST:
      return "SQUARE_PFP_COLLECTION_BOOST";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MultiplierType");
  }
}

export function multiplierTypeToNumber(object: MultiplierType): number {
  switch (object) {
    case MultiplierType.MULTIPLIER_TYPE_UNSPECIFIED:
      return 0;
    case MultiplierType.SQUARE_OWNER_BONUS:
      return 1;
    case MultiplierType.SQUARE_MULTIPLIER:
      return 2;
    case MultiplierType.SQUARE_PFP_COLLECTION_BOOST:
      return 3;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MultiplierType");
  }
}

export interface GetPointsRequest {
  /**
   * The name of the points to retrieve.
   * Format: users/{address}/points
   */
  points: string;
}

export interface ListPointsRequest {
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPoints` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Available Sequence and Operator
   * * name
   *   * `=`
   * * user_address
   *   * `=`
   *
   * Examples
   * * name="points/0x6F11EF2c07f2E381CbE514198DdE87A0c0a19442"
   * * user_address="0x6F11EF2c07f2E381CbE514198DdE87A0c0a19442"
   */
  filter: string;
  /**
   * One or more fields to compare and use to sort the output. (optional)
   * Default order for a field is descending by id
   * To specify ascending or descending order, append " asc" or " desc" to the field name. If not specified, the order is ascending.
   *
   * Reference
   * * https://google.aip.dev/132#ordering.
   *
   * Supported Fields
   * * "id", "user_address", "points"
   *
   * Examples
   * * order_by=points desc
   */
  orderBy: string;
}

/**
 * ListPointsResponse
 * (-- api-linter: core::0158::response-next-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 */
export interface ListPointsResponse {
  /** The list of rows that matched the query. */
  points: Points[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface EarnStakingInterestRequest {
  /**
   * The name of the points to retrieve.
   * Format: users/{address}/points
   */
  points: string;
}

export interface ListPointsReferralBonusesRequest {
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 10 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPointsReferralBonuses` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

/**
 * ListPointsReferralBonusResponse
 * (-- api-linter: core::0158::response-next-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 */
export interface ListPointsReferralBonusesResponse {
  /** The list of rows that matched the query. */
  referralBonuses: PointsReferralBonus[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface Points {
  /**
   * The resource name of the Points.
   * Format: users/{address}/points
   */
  name: string;
  /**  */
  userAddress: string;
  /**  */
  totalPoints: number;
  referral: Referral | undefined;
  staking: Staking | undefined;
  activity: Activity | undefined;
  bonus: Bonus | undefined;
  multipliers: Multiplier[];
}

export interface Referral {
  referredByPoints: number;
  referredPoints: number;
  points: number;
}

export interface Staking {
  points: number;
}

export interface Activity {
  points: number;
  dailyCheckin: number;
  gm: number;
}

export interface Bonus {
  /** Owner bonus */
  squareOwner: number;
}

export interface Multiplier {
  type: MultiplierType;
  percentage: number;
}

export interface PointsHistory {
  userAddress: string;
  amount: number;
  pointsType: PointsType;
  pointsTypeBehaviorGroup: PointsTypeBehaviorGroup;
}

export interface PointsReferralBonus {
  referred: User | undefined;
  sameCollection: boolean;
  amount: number;
}

function createBaseGetPointsRequest(): GetPointsRequest {
  return { points: "" };
}

export const GetPointsRequest: MessageFns<GetPointsRequest> = {
  encode(message: GetPointsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.points !== "") {
      writer.uint32(10).string(message.points);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPointsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.points = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPointsRequest {
    return { points: isSet(object.points) ? globalThis.String(object.points) : "" };
  },

  toJSON(message: GetPointsRequest): unknown {
    const obj: any = {};
    if (message.points !== undefined) {
      obj.points = message.points;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPointsRequest>, I>>(base?: I): GetPointsRequest {
    return GetPointsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPointsRequest>, I>>(object: I): GetPointsRequest {
    const message = createBaseGetPointsRequest();
    message.points = object.points ?? "";
    return message;
  },
};

function createBaseListPointsRequest(): ListPointsRequest {
  return { pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListPointsRequest: MessageFns<ListPointsRequest> = {
  encode(message: ListPointsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPointsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPointsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListPointsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    if (message.orderBy !== undefined) {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPointsRequest>, I>>(base?: I): ListPointsRequest {
    return ListPointsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPointsRequest>, I>>(object: I): ListPointsRequest {
    const message = createBaseListPointsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListPointsResponse(): ListPointsResponse {
  return { points: [], nextPageToken: "" };
}

export const ListPointsResponse: MessageFns<ListPointsResponse> = {
  encode(message: ListPointsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.points) {
      Points.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPointsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.points.push(Points.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPointsResponse {
    return {
      points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Points.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPointsResponse): unknown {
    const obj: any = {};
    if (message.points?.length) {
      obj.points = message.points.map((e) => Points.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPointsResponse>, I>>(base?: I): ListPointsResponse {
    return ListPointsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPointsResponse>, I>>(object: I): ListPointsResponse {
    const message = createBaseListPointsResponse();
    message.points = object.points?.map((e) => Points.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseEarnStakingInterestRequest(): EarnStakingInterestRequest {
  return { points: "" };
}

export const EarnStakingInterestRequest: MessageFns<EarnStakingInterestRequest> = {
  encode(message: EarnStakingInterestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.points !== "") {
      writer.uint32(10).string(message.points);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EarnStakingInterestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEarnStakingInterestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.points = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EarnStakingInterestRequest {
    return { points: isSet(object.points) ? globalThis.String(object.points) : "" };
  },

  toJSON(message: EarnStakingInterestRequest): unknown {
    const obj: any = {};
    if (message.points !== undefined) {
      obj.points = message.points;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EarnStakingInterestRequest>, I>>(base?: I): EarnStakingInterestRequest {
    return EarnStakingInterestRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EarnStakingInterestRequest>, I>>(object: I): EarnStakingInterestRequest {
    const message = createBaseEarnStakingInterestRequest();
    message.points = object.points ?? "";
    return message;
  },
};

function createBaseListPointsReferralBonusesRequest(): ListPointsReferralBonusesRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListPointsReferralBonusesRequest: MessageFns<ListPointsReferralBonusesRequest> = {
  encode(message: ListPointsReferralBonusesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPointsReferralBonusesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPointsReferralBonusesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPointsReferralBonusesRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListPointsReferralBonusesRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPointsReferralBonusesRequest>, I>>(
    base?: I,
  ): ListPointsReferralBonusesRequest {
    return ListPointsReferralBonusesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPointsReferralBonusesRequest>, I>>(
    object: I,
  ): ListPointsReferralBonusesRequest {
    const message = createBaseListPointsReferralBonusesRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListPointsReferralBonusesResponse(): ListPointsReferralBonusesResponse {
  return { referralBonuses: [], nextPageToken: "" };
}

export const ListPointsReferralBonusesResponse: MessageFns<ListPointsReferralBonusesResponse> = {
  encode(message: ListPointsReferralBonusesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.referralBonuses) {
      PointsReferralBonus.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPointsReferralBonusesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPointsReferralBonusesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referralBonuses.push(PointsReferralBonus.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPointsReferralBonusesResponse {
    return {
      referralBonuses: globalThis.Array.isArray(object?.referralBonuses)
        ? object.referralBonuses.map((e: any) => PointsReferralBonus.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPointsReferralBonusesResponse): unknown {
    const obj: any = {};
    if (message.referralBonuses?.length) {
      obj.referralBonuses = message.referralBonuses.map((e) => PointsReferralBonus.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPointsReferralBonusesResponse>, I>>(
    base?: I,
  ): ListPointsReferralBonusesResponse {
    return ListPointsReferralBonusesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPointsReferralBonusesResponse>, I>>(
    object: I,
  ): ListPointsReferralBonusesResponse {
    const message = createBaseListPointsReferralBonusesResponse();
    message.referralBonuses = object.referralBonuses?.map((e) => PointsReferralBonus.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBasePoints(): Points {
  return {
    name: "",
    userAddress: "",
    totalPoints: 0,
    referral: undefined,
    staking: undefined,
    activity: undefined,
    bonus: undefined,
    multipliers: [],
  };
}

export const Points: MessageFns<Points> = {
  encode(message: Points, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.userAddress !== "") {
      writer.uint32(18).string(message.userAddress);
    }
    if (message.totalPoints !== 0) {
      writer.uint32(24).uint32(message.totalPoints);
    }
    if (message.referral !== undefined) {
      Referral.encode(message.referral, writer.uint32(42).fork()).join();
    }
    if (message.staking !== undefined) {
      Staking.encode(message.staking, writer.uint32(50).fork()).join();
    }
    if (message.activity !== undefined) {
      Activity.encode(message.activity, writer.uint32(58).fork()).join();
    }
    if (message.bonus !== undefined) {
      Bonus.encode(message.bonus, writer.uint32(66).fork()).join();
    }
    for (const v of message.multipliers) {
      Multiplier.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Points {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalPoints = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referral = Referral.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.staking = Staking.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.activity = Activity.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bonus = Bonus.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.multipliers.push(Multiplier.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Points {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
      referral: isSet(object.referral) ? Referral.fromJSON(object.referral) : undefined,
      staking: isSet(object.staking) ? Staking.fromJSON(object.staking) : undefined,
      activity: isSet(object.activity) ? Activity.fromJSON(object.activity) : undefined,
      bonus: isSet(object.bonus) ? Bonus.fromJSON(object.bonus) : undefined,
      multipliers: globalThis.Array.isArray(object?.multipliers)
        ? object.multipliers.map((e: any) => Multiplier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Points): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.userAddress !== undefined) {
      obj.userAddress = message.userAddress;
    }
    if (message.totalPoints !== undefined) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    if (message.referral !== undefined) {
      obj.referral = Referral.toJSON(message.referral);
    }
    if (message.staking !== undefined) {
      obj.staking = Staking.toJSON(message.staking);
    }
    if (message.activity !== undefined) {
      obj.activity = Activity.toJSON(message.activity);
    }
    if (message.bonus !== undefined) {
      obj.bonus = Bonus.toJSON(message.bonus);
    }
    if (message.multipliers?.length) {
      obj.multipliers = message.multipliers.map((e) => Multiplier.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Points>, I>>(base?: I): Points {
    return Points.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Points>, I>>(object: I): Points {
    const message = createBasePoints();
    message.name = object.name ?? "";
    message.userAddress = object.userAddress ?? "";
    message.totalPoints = object.totalPoints ?? 0;
    message.referral = (object.referral !== undefined && object.referral !== null)
      ? Referral.fromPartial(object.referral)
      : undefined;
    message.staking = (object.staking !== undefined && object.staking !== null)
      ? Staking.fromPartial(object.staking)
      : undefined;
    message.activity = (object.activity !== undefined && object.activity !== null)
      ? Activity.fromPartial(object.activity)
      : undefined;
    message.bonus = (object.bonus !== undefined && object.bonus !== null) ? Bonus.fromPartial(object.bonus) : undefined;
    message.multipliers = object.multipliers?.map((e) => Multiplier.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReferral(): Referral {
  return { referredByPoints: 0, referredPoints: 0, points: 0 };
}

export const Referral: MessageFns<Referral> = {
  encode(message: Referral, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referredByPoints !== 0) {
      writer.uint32(8).uint32(message.referredByPoints);
    }
    if (message.referredPoints !== 0) {
      writer.uint32(16).uint32(message.referredPoints);
    }
    if (message.points !== 0) {
      writer.uint32(24).uint32(message.points);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Referral {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReferral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.referredByPoints = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.referredPoints = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.points = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Referral {
    return {
      referredByPoints: isSet(object.referredByPoints) ? globalThis.Number(object.referredByPoints) : 0,
      referredPoints: isSet(object.referredPoints) ? globalThis.Number(object.referredPoints) : 0,
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
    };
  },

  toJSON(message: Referral): unknown {
    const obj: any = {};
    if (message.referredByPoints !== undefined) {
      obj.referredByPoints = Math.round(message.referredByPoints);
    }
    if (message.referredPoints !== undefined) {
      obj.referredPoints = Math.round(message.referredPoints);
    }
    if (message.points !== undefined) {
      obj.points = Math.round(message.points);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Referral>, I>>(base?: I): Referral {
    return Referral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Referral>, I>>(object: I): Referral {
    const message = createBaseReferral();
    message.referredByPoints = object.referredByPoints ?? 0;
    message.referredPoints = object.referredPoints ?? 0;
    message.points = object.points ?? 0;
    return message;
  },
};

function createBaseStaking(): Staking {
  return { points: 0 };
}

export const Staking: MessageFns<Staking> = {
  encode(message: Staking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.points !== 0) {
      writer.uint32(8).uint32(message.points);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Staking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStaking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.points = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Staking {
    return { points: isSet(object.points) ? globalThis.Number(object.points) : 0 };
  },

  toJSON(message: Staking): unknown {
    const obj: any = {};
    if (message.points !== undefined) {
      obj.points = Math.round(message.points);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Staking>, I>>(base?: I): Staking {
    return Staking.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Staking>, I>>(object: I): Staking {
    const message = createBaseStaking();
    message.points = object.points ?? 0;
    return message;
  },
};

function createBaseActivity(): Activity {
  return { points: 0, dailyCheckin: 0, gm: 0 };
}

export const Activity: MessageFns<Activity> = {
  encode(message: Activity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.points !== 0) {
      writer.uint32(8).uint32(message.points);
    }
    if (message.dailyCheckin !== 0) {
      writer.uint32(16).uint32(message.dailyCheckin);
    }
    if (message.gm !== 0) {
      writer.uint32(24).uint32(message.gm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Activity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.points = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dailyCheckin = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gm = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Activity {
    return {
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
      dailyCheckin: isSet(object.dailyCheckin) ? globalThis.Number(object.dailyCheckin) : 0,
      gm: isSet(object.gm) ? globalThis.Number(object.gm) : 0,
    };
  },

  toJSON(message: Activity): unknown {
    const obj: any = {};
    if (message.points !== undefined) {
      obj.points = Math.round(message.points);
    }
    if (message.dailyCheckin !== undefined) {
      obj.dailyCheckin = Math.round(message.dailyCheckin);
    }
    if (message.gm !== undefined) {
      obj.gm = Math.round(message.gm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Activity>, I>>(base?: I): Activity {
    return Activity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Activity>, I>>(object: I): Activity {
    const message = createBaseActivity();
    message.points = object.points ?? 0;
    message.dailyCheckin = object.dailyCheckin ?? 0;
    message.gm = object.gm ?? 0;
    return message;
  },
};

function createBaseBonus(): Bonus {
  return { squareOwner: 0 };
}

export const Bonus: MessageFns<Bonus> = {
  encode(message: Bonus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.squareOwner !== 0) {
      writer.uint32(8).uint32(message.squareOwner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bonus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBonus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.squareOwner = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bonus {
    return { squareOwner: isSet(object.squareOwner) ? globalThis.Number(object.squareOwner) : 0 };
  },

  toJSON(message: Bonus): unknown {
    const obj: any = {};
    if (message.squareOwner !== undefined) {
      obj.squareOwner = Math.round(message.squareOwner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bonus>, I>>(base?: I): Bonus {
    return Bonus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bonus>, I>>(object: I): Bonus {
    const message = createBaseBonus();
    message.squareOwner = object.squareOwner ?? 0;
    return message;
  },
};

function createBaseMultiplier(): Multiplier {
  return { type: MultiplierType.MULTIPLIER_TYPE_UNSPECIFIED, percentage: 0 };
}

export const Multiplier: MessageFns<Multiplier> = {
  encode(message: Multiplier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== MultiplierType.MULTIPLIER_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(multiplierTypeToNumber(message.type));
    }
    if (message.percentage !== 0) {
      writer.uint32(21).float(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Multiplier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiplier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = multiplierTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.percentage = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Multiplier {
    return {
      type: isSet(object.type) ? multiplierTypeFromJSON(object.type) : MultiplierType.MULTIPLIER_TYPE_UNSPECIFIED,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : 0,
    };
  },

  toJSON(message: Multiplier): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = multiplierTypeToJSON(message.type);
    }
    if (message.percentage !== undefined) {
      obj.percentage = message.percentage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Multiplier>, I>>(base?: I): Multiplier {
    return Multiplier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Multiplier>, I>>(object: I): Multiplier {
    const message = createBaseMultiplier();
    message.type = object.type ?? MultiplierType.MULTIPLIER_TYPE_UNSPECIFIED;
    message.percentage = object.percentage ?? 0;
    return message;
  },
};

function createBasePointsHistory(): PointsHistory {
  return {
    userAddress: "",
    amount: 0,
    pointsType: PointsType.TYPE_UNKNOWN,
    pointsTypeBehaviorGroup: PointsTypeBehaviorGroup.GROUP_UNSPECIFIED,
  };
}

export const PointsHistory: MessageFns<PointsHistory> = {
  encode(message: PointsHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userAddress !== "") {
      writer.uint32(10).string(message.userAddress);
    }
    if (message.amount !== 0) {
      writer.uint32(21).float(message.amount);
    }
    if (message.pointsType !== PointsType.TYPE_UNKNOWN) {
      writer.uint32(24).int32(pointsTypeToNumber(message.pointsType));
    }
    if (message.pointsTypeBehaviorGroup !== PointsTypeBehaviorGroup.GROUP_UNSPECIFIED) {
      writer.uint32(32).int32(pointsTypeBehaviorGroupToNumber(message.pointsTypeBehaviorGroup));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PointsHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointsHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.amount = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pointsType = pointsTypeFromJSON(reader.int32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pointsTypeBehaviorGroup = pointsTypeBehaviorGroupFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointsHistory {
    return {
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      pointsType: isSet(object.pointsType) ? pointsTypeFromJSON(object.pointsType) : PointsType.TYPE_UNKNOWN,
      pointsTypeBehaviorGroup: isSet(object.pointsTypeBehaviorGroup)
        ? pointsTypeBehaviorGroupFromJSON(object.pointsTypeBehaviorGroup)
        : PointsTypeBehaviorGroup.GROUP_UNSPECIFIED,
    };
  },

  toJSON(message: PointsHistory): unknown {
    const obj: any = {};
    if (message.userAddress !== undefined) {
      obj.userAddress = message.userAddress;
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.pointsType !== undefined) {
      obj.pointsType = pointsTypeToJSON(message.pointsType);
    }
    if (message.pointsTypeBehaviorGroup !== undefined) {
      obj.pointsTypeBehaviorGroup = pointsTypeBehaviorGroupToJSON(message.pointsTypeBehaviorGroup);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PointsHistory>, I>>(base?: I): PointsHistory {
    return PointsHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PointsHistory>, I>>(object: I): PointsHistory {
    const message = createBasePointsHistory();
    message.userAddress = object.userAddress ?? "";
    message.amount = object.amount ?? 0;
    message.pointsType = object.pointsType ?? PointsType.TYPE_UNKNOWN;
    message.pointsTypeBehaviorGroup = object.pointsTypeBehaviorGroup ?? PointsTypeBehaviorGroup.GROUP_UNSPECIFIED;
    return message;
  },
};

function createBasePointsReferralBonus(): PointsReferralBonus {
  return { referred: undefined, sameCollection: false, amount: 0 };
}

export const PointsReferralBonus: MessageFns<PointsReferralBonus> = {
  encode(message: PointsReferralBonus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referred !== undefined) {
      User.encode(message.referred, writer.uint32(10).fork()).join();
    }
    if (message.sameCollection !== false) {
      writer.uint32(16).bool(message.sameCollection);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint32(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PointsReferralBonus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePointsReferralBonus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referred = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sameCollection = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PointsReferralBonus {
    return {
      referred: isSet(object.referred) ? User.fromJSON(object.referred) : undefined,
      sameCollection: isSet(object.sameCollection) ? globalThis.Boolean(object.sameCollection) : false,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: PointsReferralBonus): unknown {
    const obj: any = {};
    if (message.referred !== undefined) {
      obj.referred = User.toJSON(message.referred);
    }
    if (message.sameCollection !== undefined) {
      obj.sameCollection = message.sameCollection;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PointsReferralBonus>, I>>(base?: I): PointsReferralBonus {
    return PointsReferralBonus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PointsReferralBonus>, I>>(object: I): PointsReferralBonus {
    const message = createBasePointsReferralBonus();
    message.referred = (object.referred !== undefined && object.referred !== null)
      ? User.fromPartial(object.referred)
      : undefined;
    message.sameCollection = object.sameCollection ?? false;
    message.amount = object.amount ?? 0;
    return message;
  },
};

/** PointsService contains the function to interact with the Points of the spacebar */
export type PointsServiceService = typeof PointsServiceService;
export const PointsServiceService = {
  /** GetPoints will return Points. */
  getPoints: {
    path: "/blast.v1.points.PointsService/GetPoints",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPointsRequest) => Buffer.from(GetPointsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPointsRequest.decode(value),
    responseSerialize: (value: Points) => Buffer.from(Points.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Points.decode(value),
  },
  /**
   * ListPoints will return Points.
   * reads across collections, reference: https://google.aip.dev/159
   */
  listPoints: {
    path: "/blast.v1.points.PointsService/ListPoints",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPointsRequest) => Buffer.from(ListPointsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListPointsRequest.decode(value),
    responseSerialize: (value: ListPointsResponse) => Buffer.from(ListPointsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListPointsResponse.decode(value),
  },
  /**
   * EarnStakingInterestPoints will earn Staking Interest Points.
   * This function will be called by internal service and not open to the public.
   */
  earnStakingInterest: {
    path: "/blast.v1.points.PointsService/EarnStakingInterest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EarnStakingInterestRequest) =>
      Buffer.from(EarnStakingInterestRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EarnStakingInterestRequest.decode(value),
    responseSerialize: (value: Points) => Buffer.from(Points.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Points.decode(value),
  },
} as const;

export interface PointsServiceServer extends UntypedServiceImplementation {
  /** GetPoints will return Points. */
  getPoints: handleUnaryCall<GetPointsRequest, Points>;
  /**
   * ListPoints will return Points.
   * reads across collections, reference: https://google.aip.dev/159
   */
  listPoints: handleUnaryCall<ListPointsRequest, ListPointsResponse>;
  /**
   * EarnStakingInterestPoints will earn Staking Interest Points.
   * This function will be called by internal service and not open to the public.
   */
  earnStakingInterest: handleUnaryCall<EarnStakingInterestRequest, Points>;
}

export interface PointsServiceClient extends Client {
  /** GetPoints will return Points. */
  getPoints(
    request: GetPointsRequest,
    callback: (error: ServiceError | null, response: Points) => void,
  ): ClientUnaryCall;
  getPoints(
    request: GetPointsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Points) => void,
  ): ClientUnaryCall;
  getPoints(
    request: GetPointsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Points) => void,
  ): ClientUnaryCall;
  /**
   * ListPoints will return Points.
   * reads across collections, reference: https://google.aip.dev/159
   */
  listPoints(
    request: ListPointsRequest,
    callback: (error: ServiceError | null, response: ListPointsResponse) => void,
  ): ClientUnaryCall;
  listPoints(
    request: ListPointsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPointsResponse) => void,
  ): ClientUnaryCall;
  listPoints(
    request: ListPointsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPointsResponse) => void,
  ): ClientUnaryCall;
  /**
   * EarnStakingInterestPoints will earn Staking Interest Points.
   * This function will be called by internal service and not open to the public.
   */
  earnStakingInterest(
    request: EarnStakingInterestRequest,
    callback: (error: ServiceError | null, response: Points) => void,
  ): ClientUnaryCall;
  earnStakingInterest(
    request: EarnStakingInterestRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Points) => void,
  ): ClientUnaryCall;
  earnStakingInterest(
    request: EarnStakingInterestRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Points) => void,
  ): ClientUnaryCall;
}

export const PointsServiceClient = makeGenericClientConstructor(
  PointsServiceService,
  "blast.v1.points.PointsService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PointsServiceClient;
  service: typeof PointsServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
