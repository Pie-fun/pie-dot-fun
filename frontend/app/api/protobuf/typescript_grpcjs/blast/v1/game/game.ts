// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: blast/v1/game/game.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../../../google/protobuf/timestamp";

export enum ClientMessageType {
  CLIENT_MESSAGE_TYPE_UNSPECIFIED = "CLIENT_MESSAGE_TYPE_UNSPECIFIED",
  CLIENT_CONNECT = "CLIENT_CONNECT",
  /** CLIENT_DISCONNECT - DEPRECATED - Use CLIENT_TERMINATE instead for permanent disconnection */
  CLIENT_DISCONNECT = "CLIENT_DISCONNECT",
  /**
   * CLIENT_TERMINATE - Terminate the connection which means delete session permanently
   * The client should send this message when the client wants to terminate the connection
   * Disconnected connections other than this message will be considered as a temporary disconnection (soft delete) and can be reonnectable
   * If want to reconnect, the client should connect with the same auth token that was used to create the session (CLIENT_CONNECT)
   */
  CLIENT_TERMINATE = "CLIENT_TERMINATE",
  CLIENT_START_GAME = "CLIENT_START_GAME",
  CLIENT_END_GAME = "CLIENT_END_GAME",
  CLIENT_TAKE_STAR = "CLIENT_TAKE_STAR",
  CLIENT_TAKE_BLAST_GOLD = "CLIENT_TAKE_BLAST_GOLD",
  CLIENT_DESTROY_CAPSULE = "CLIENT_DESTROY_CAPSULE",
  CLIENT_DESTROY_METEOR = "CLIENT_DESTROY_METEOR",
  CLIENT_SHOOT_BULLET = "CLIENT_SHOOT_BULLET",
  CLIENT_EMPLOY_BOOST = "CLIENT_EMPLOY_BOOST",
  CLIENT_SPACESHIP_POSITION = "CLIENT_SPACESHIP_POSITION",
  CLIENT_SPACESHIP_EVENT = "CLIENT_SPACESHIP_EVENT",
  CLIENT_KEYBOARD_EVENT = "CLIENT_KEYBOARD_EVENT",
  CLIENT_ALERT_SUSPICIOUS_USER = "CLIENT_ALERT_SUSPICIOUS_USER",
}

export function clientMessageTypeFromJSON(object: any): ClientMessageType {
  switch (object) {
    case 0:
    case "CLIENT_MESSAGE_TYPE_UNSPECIFIED":
      return ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED;
    case 1:
    case "CLIENT_CONNECT":
      return ClientMessageType.CLIENT_CONNECT;
    case 2:
    case "CLIENT_DISCONNECT":
      return ClientMessageType.CLIENT_DISCONNECT;
    case 3:
    case "CLIENT_TERMINATE":
      return ClientMessageType.CLIENT_TERMINATE;
    case 20:
    case "CLIENT_START_GAME":
      return ClientMessageType.CLIENT_START_GAME;
    case 21:
    case "CLIENT_END_GAME":
      return ClientMessageType.CLIENT_END_GAME;
    case 22:
    case "CLIENT_TAKE_STAR":
      return ClientMessageType.CLIENT_TAKE_STAR;
    case 23:
    case "CLIENT_TAKE_BLAST_GOLD":
      return ClientMessageType.CLIENT_TAKE_BLAST_GOLD;
    case 24:
    case "CLIENT_DESTROY_CAPSULE":
      return ClientMessageType.CLIENT_DESTROY_CAPSULE;
    case 25:
    case "CLIENT_DESTROY_METEOR":
      return ClientMessageType.CLIENT_DESTROY_METEOR;
    case 26:
    case "CLIENT_SHOOT_BULLET":
      return ClientMessageType.CLIENT_SHOOT_BULLET;
    case 27:
    case "CLIENT_EMPLOY_BOOST":
      return ClientMessageType.CLIENT_EMPLOY_BOOST;
    case 40:
    case "CLIENT_SPACESHIP_POSITION":
      return ClientMessageType.CLIENT_SPACESHIP_POSITION;
    case 41:
    case "CLIENT_SPACESHIP_EVENT":
      return ClientMessageType.CLIENT_SPACESHIP_EVENT;
    case 42:
    case "CLIENT_KEYBOARD_EVENT":
      return ClientMessageType.CLIENT_KEYBOARD_EVENT;
    case 60:
    case "CLIENT_ALERT_SUSPICIOUS_USER":
      return ClientMessageType.CLIENT_ALERT_SUSPICIOUS_USER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientMessageType");
  }
}

export function clientMessageTypeToJSON(object: ClientMessageType): string {
  switch (object) {
    case ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED:
      return "CLIENT_MESSAGE_TYPE_UNSPECIFIED";
    case ClientMessageType.CLIENT_CONNECT:
      return "CLIENT_CONNECT";
    case ClientMessageType.CLIENT_DISCONNECT:
      return "CLIENT_DISCONNECT";
    case ClientMessageType.CLIENT_TERMINATE:
      return "CLIENT_TERMINATE";
    case ClientMessageType.CLIENT_START_GAME:
      return "CLIENT_START_GAME";
    case ClientMessageType.CLIENT_END_GAME:
      return "CLIENT_END_GAME";
    case ClientMessageType.CLIENT_TAKE_STAR:
      return "CLIENT_TAKE_STAR";
    case ClientMessageType.CLIENT_TAKE_BLAST_GOLD:
      return "CLIENT_TAKE_BLAST_GOLD";
    case ClientMessageType.CLIENT_DESTROY_CAPSULE:
      return "CLIENT_DESTROY_CAPSULE";
    case ClientMessageType.CLIENT_DESTROY_METEOR:
      return "CLIENT_DESTROY_METEOR";
    case ClientMessageType.CLIENT_SHOOT_BULLET:
      return "CLIENT_SHOOT_BULLET";
    case ClientMessageType.CLIENT_EMPLOY_BOOST:
      return "CLIENT_EMPLOY_BOOST";
    case ClientMessageType.CLIENT_SPACESHIP_POSITION:
      return "CLIENT_SPACESHIP_POSITION";
    case ClientMessageType.CLIENT_SPACESHIP_EVENT:
      return "CLIENT_SPACESHIP_EVENT";
    case ClientMessageType.CLIENT_KEYBOARD_EVENT:
      return "CLIENT_KEYBOARD_EVENT";
    case ClientMessageType.CLIENT_ALERT_SUSPICIOUS_USER:
      return "CLIENT_ALERT_SUSPICIOUS_USER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientMessageType");
  }
}

export function clientMessageTypeToNumber(object: ClientMessageType): number {
  switch (object) {
    case ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED:
      return 0;
    case ClientMessageType.CLIENT_CONNECT:
      return 1;
    case ClientMessageType.CLIENT_DISCONNECT:
      return 2;
    case ClientMessageType.CLIENT_TERMINATE:
      return 3;
    case ClientMessageType.CLIENT_START_GAME:
      return 20;
    case ClientMessageType.CLIENT_END_GAME:
      return 21;
    case ClientMessageType.CLIENT_TAKE_STAR:
      return 22;
    case ClientMessageType.CLIENT_TAKE_BLAST_GOLD:
      return 23;
    case ClientMessageType.CLIENT_DESTROY_CAPSULE:
      return 24;
    case ClientMessageType.CLIENT_DESTROY_METEOR:
      return 25;
    case ClientMessageType.CLIENT_SHOOT_BULLET:
      return 26;
    case ClientMessageType.CLIENT_EMPLOY_BOOST:
      return 27;
    case ClientMessageType.CLIENT_SPACESHIP_POSITION:
      return 40;
    case ClientMessageType.CLIENT_SPACESHIP_EVENT:
      return 41;
    case ClientMessageType.CLIENT_KEYBOARD_EVENT:
      return 42;
    case ClientMessageType.CLIENT_ALERT_SUSPICIOUS_USER:
      return 60;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ClientMessageType");
  }
}

export enum ServerMessageType {
  SERVER_MESSAGE_TYPE_UNSPECIFIED = "SERVER_MESSAGE_TYPE_UNSPECIFIED",
  SERVER_CONNECT = "SERVER_CONNECT",
  SERVER_TERMINATE = "SERVER_TERMINATE",
  SERVER_RECONNECT = "SERVER_RECONNECT",
  SERVER_START_GAME = "SERVER_START_GAME",
  SERVER_END_GAME = "SERVER_END_GAME",
  SERVER_TAKE_STAR = "SERVER_TAKE_STAR",
  SERVER_TAKE_BLAST_GOLD = "SERVER_TAKE_BLAST_GOLD",
  SERVER_DESTROY_CAPSULE = "SERVER_DESTROY_CAPSULE",
  SERVER_DESTROY_METEOR = "SERVER_DESTROY_METEOR",
  SERVER_SHOOT_BULLET = "SERVER_SHOOT_BULLET",
  SERVER_EMPLOY_BOOST = "SERVER_EMPLOY_BOOST",
  SERVER_SPACESHIP_POSITION = "SERVER_SPACESHIP_POSITION",
  SERVER_SPACESHIP_EVENT = "SERVER_SPACESHIP_EVENT",
  SERVER_KEYBOARD_EVENT = "SERVER_KEYBOARD_EVENT",
  SERVER_ALERT_SUSPICIOUS_USER = "SERVER_ALERT_SUSPICIOUS_USER",
}

export function serverMessageTypeFromJSON(object: any): ServerMessageType {
  switch (object) {
    case 0:
    case "SERVER_MESSAGE_TYPE_UNSPECIFIED":
      return ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED;
    case 1:
    case "SERVER_CONNECT":
      return ServerMessageType.SERVER_CONNECT;
    case 2:
    case "SERVER_TERMINATE":
      return ServerMessageType.SERVER_TERMINATE;
    case 3:
    case "SERVER_RECONNECT":
      return ServerMessageType.SERVER_RECONNECT;
    case 20:
    case "SERVER_START_GAME":
      return ServerMessageType.SERVER_START_GAME;
    case 21:
    case "SERVER_END_GAME":
      return ServerMessageType.SERVER_END_GAME;
    case 22:
    case "SERVER_TAKE_STAR":
      return ServerMessageType.SERVER_TAKE_STAR;
    case 23:
    case "SERVER_TAKE_BLAST_GOLD":
      return ServerMessageType.SERVER_TAKE_BLAST_GOLD;
    case 24:
    case "SERVER_DESTROY_CAPSULE":
      return ServerMessageType.SERVER_DESTROY_CAPSULE;
    case 25:
    case "SERVER_DESTROY_METEOR":
      return ServerMessageType.SERVER_DESTROY_METEOR;
    case 26:
    case "SERVER_SHOOT_BULLET":
      return ServerMessageType.SERVER_SHOOT_BULLET;
    case 27:
    case "SERVER_EMPLOY_BOOST":
      return ServerMessageType.SERVER_EMPLOY_BOOST;
    case 40:
    case "SERVER_SPACESHIP_POSITION":
      return ServerMessageType.SERVER_SPACESHIP_POSITION;
    case 41:
    case "SERVER_SPACESHIP_EVENT":
      return ServerMessageType.SERVER_SPACESHIP_EVENT;
    case 42:
    case "SERVER_KEYBOARD_EVENT":
      return ServerMessageType.SERVER_KEYBOARD_EVENT;
    case 60:
    case "SERVER_ALERT_SUSPICIOUS_USER":
      return ServerMessageType.SERVER_ALERT_SUSPICIOUS_USER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerMessageType");
  }
}

export function serverMessageTypeToJSON(object: ServerMessageType): string {
  switch (object) {
    case ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED:
      return "SERVER_MESSAGE_TYPE_UNSPECIFIED";
    case ServerMessageType.SERVER_CONNECT:
      return "SERVER_CONNECT";
    case ServerMessageType.SERVER_TERMINATE:
      return "SERVER_TERMINATE";
    case ServerMessageType.SERVER_RECONNECT:
      return "SERVER_RECONNECT";
    case ServerMessageType.SERVER_START_GAME:
      return "SERVER_START_GAME";
    case ServerMessageType.SERVER_END_GAME:
      return "SERVER_END_GAME";
    case ServerMessageType.SERVER_TAKE_STAR:
      return "SERVER_TAKE_STAR";
    case ServerMessageType.SERVER_TAKE_BLAST_GOLD:
      return "SERVER_TAKE_BLAST_GOLD";
    case ServerMessageType.SERVER_DESTROY_CAPSULE:
      return "SERVER_DESTROY_CAPSULE";
    case ServerMessageType.SERVER_DESTROY_METEOR:
      return "SERVER_DESTROY_METEOR";
    case ServerMessageType.SERVER_SHOOT_BULLET:
      return "SERVER_SHOOT_BULLET";
    case ServerMessageType.SERVER_EMPLOY_BOOST:
      return "SERVER_EMPLOY_BOOST";
    case ServerMessageType.SERVER_SPACESHIP_POSITION:
      return "SERVER_SPACESHIP_POSITION";
    case ServerMessageType.SERVER_SPACESHIP_EVENT:
      return "SERVER_SPACESHIP_EVENT";
    case ServerMessageType.SERVER_KEYBOARD_EVENT:
      return "SERVER_KEYBOARD_EVENT";
    case ServerMessageType.SERVER_ALERT_SUSPICIOUS_USER:
      return "SERVER_ALERT_SUSPICIOUS_USER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerMessageType");
  }
}

export function serverMessageTypeToNumber(object: ServerMessageType): number {
  switch (object) {
    case ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED:
      return 0;
    case ServerMessageType.SERVER_CONNECT:
      return 1;
    case ServerMessageType.SERVER_TERMINATE:
      return 2;
    case ServerMessageType.SERVER_RECONNECT:
      return 3;
    case ServerMessageType.SERVER_START_GAME:
      return 20;
    case ServerMessageType.SERVER_END_GAME:
      return 21;
    case ServerMessageType.SERVER_TAKE_STAR:
      return 22;
    case ServerMessageType.SERVER_TAKE_BLAST_GOLD:
      return 23;
    case ServerMessageType.SERVER_DESTROY_CAPSULE:
      return 24;
    case ServerMessageType.SERVER_DESTROY_METEOR:
      return 25;
    case ServerMessageType.SERVER_SHOOT_BULLET:
      return 26;
    case ServerMessageType.SERVER_EMPLOY_BOOST:
      return 27;
    case ServerMessageType.SERVER_SPACESHIP_POSITION:
      return 40;
    case ServerMessageType.SERVER_SPACESHIP_EVENT:
      return 41;
    case ServerMessageType.SERVER_KEYBOARD_EVENT:
      return 42;
    case ServerMessageType.SERVER_ALERT_SUSPICIOUS_USER:
      return 60;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerMessageType");
  }
}

export enum ServerAckType {
  SERVER_RESPONSE_TYPE_UNSPECIFIED = "SERVER_RESPONSE_TYPE_UNSPECIFIED",
  /** ACK - Message sent to client when message from client is accepted */
  ACK = "ACK",
  /** NACK - Message sent to client when message from client is rejected */
  NACK = "NACK",
  /** NACK_UNAUTHENTICATED -  */
  NACK_UNAUTHENTICATED = "NACK_UNAUTHENTICATED",
  /** NACK_UNAUTORIZAED -  */
  NACK_UNAUTORIZAED = "NACK_UNAUTORIZAED",
  /** NACK_SESSION_ALREADY_EXISTS -  */
  NACK_SESSION_ALREADY_EXISTS = "NACK_SESSION_ALREADY_EXISTS",
  /** NACK_DAILY_ROUND_EXCEEDED -  */
  NACK_DAILY_ROUND_EXCEEDED = "NACK_DAILY_ROUND_EXCEEDED",
  /** NACK_BLAST_GOLD_NOT_ACQUIRABLE -  */
  NACK_BLAST_GOLD_NOT_ACQUIRABLE = "NACK_BLAST_GOLD_NOT_ACQUIRABLE",
  /** NACK_PLAYTIME_OUT -  */
  NACK_PLAYTIME_OUT = "NACK_PLAYTIME_OUT",
  /** NACK_SYBIL_USER -  */
  NACK_SYBIL_USER = "NACK_SYBIL_USER",
  /** NACK_SESSION_NOT_FOUND -  */
  NACK_SESSION_NOT_FOUND = "NACK_SESSION_NOT_FOUND",
  /** ERR - Message sent to client when internal server error occurs */
  ERR = "ERR",
}

export function serverAckTypeFromJSON(object: any): ServerAckType {
  switch (object) {
    case 0:
    case "SERVER_RESPONSE_TYPE_UNSPECIFIED":
      return ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED;
    case 100:
    case "ACK":
      return ServerAckType.ACK;
    case 200:
    case "NACK":
      return ServerAckType.NACK;
    case 201:
    case "NACK_UNAUTHENTICATED":
      return ServerAckType.NACK_UNAUTHENTICATED;
    case 202:
    case "NACK_UNAUTORIZAED":
      return ServerAckType.NACK_UNAUTORIZAED;
    case 203:
    case "NACK_SESSION_ALREADY_EXISTS":
      return ServerAckType.NACK_SESSION_ALREADY_EXISTS;
    case 204:
    case "NACK_DAILY_ROUND_EXCEEDED":
      return ServerAckType.NACK_DAILY_ROUND_EXCEEDED;
    case 205:
    case "NACK_BLAST_GOLD_NOT_ACQUIRABLE":
      return ServerAckType.NACK_BLAST_GOLD_NOT_ACQUIRABLE;
    case 206:
    case "NACK_PLAYTIME_OUT":
      return ServerAckType.NACK_PLAYTIME_OUT;
    case 207:
    case "NACK_SYBIL_USER":
      return ServerAckType.NACK_SYBIL_USER;
    case 208:
    case "NACK_SESSION_NOT_FOUND":
      return ServerAckType.NACK_SESSION_NOT_FOUND;
    case 300:
    case "ERR":
      return ServerAckType.ERR;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerAckType");
  }
}

export function serverAckTypeToJSON(object: ServerAckType): string {
  switch (object) {
    case ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED:
      return "SERVER_RESPONSE_TYPE_UNSPECIFIED";
    case ServerAckType.ACK:
      return "ACK";
    case ServerAckType.NACK:
      return "NACK";
    case ServerAckType.NACK_UNAUTHENTICATED:
      return "NACK_UNAUTHENTICATED";
    case ServerAckType.NACK_UNAUTORIZAED:
      return "NACK_UNAUTORIZAED";
    case ServerAckType.NACK_SESSION_ALREADY_EXISTS:
      return "NACK_SESSION_ALREADY_EXISTS";
    case ServerAckType.NACK_DAILY_ROUND_EXCEEDED:
      return "NACK_DAILY_ROUND_EXCEEDED";
    case ServerAckType.NACK_BLAST_GOLD_NOT_ACQUIRABLE:
      return "NACK_BLAST_GOLD_NOT_ACQUIRABLE";
    case ServerAckType.NACK_PLAYTIME_OUT:
      return "NACK_PLAYTIME_OUT";
    case ServerAckType.NACK_SYBIL_USER:
      return "NACK_SYBIL_USER";
    case ServerAckType.NACK_SESSION_NOT_FOUND:
      return "NACK_SESSION_NOT_FOUND";
    case ServerAckType.ERR:
      return "ERR";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerAckType");
  }
}

export function serverAckTypeToNumber(object: ServerAckType): number {
  switch (object) {
    case ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED:
      return 0;
    case ServerAckType.ACK:
      return 100;
    case ServerAckType.NACK:
      return 200;
    case ServerAckType.NACK_UNAUTHENTICATED:
      return 201;
    case ServerAckType.NACK_UNAUTORIZAED:
      return 202;
    case ServerAckType.NACK_SESSION_ALREADY_EXISTS:
      return 203;
    case ServerAckType.NACK_DAILY_ROUND_EXCEEDED:
      return 204;
    case ServerAckType.NACK_BLAST_GOLD_NOT_ACQUIRABLE:
      return 205;
    case ServerAckType.NACK_PLAYTIME_OUT:
      return 206;
    case ServerAckType.NACK_SYBIL_USER:
      return 207;
    case ServerAckType.NACK_SESSION_NOT_FOUND:
      return 208;
    case ServerAckType.ERR:
      return 300;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ServerAckType");
  }
}

export enum CapsuleRewardType {
  CAPSULE_REWARD_TYPE_UNSPECIFIED = "CAPSULE_REWARD_TYPE_UNSPECIFIED",
  CAPSULE_REWARD_STAR = "CAPSULE_REWARD_STAR",
  CAPSULE_REWARD_BLAST_GOLD = "CAPSULE_REWARD_BLAST_GOLD",
}

export function capsuleRewardTypeFromJSON(object: any): CapsuleRewardType {
  switch (object) {
    case 0:
    case "CAPSULE_REWARD_TYPE_UNSPECIFIED":
      return CapsuleRewardType.CAPSULE_REWARD_TYPE_UNSPECIFIED;
    case 1:
    case "CAPSULE_REWARD_STAR":
      return CapsuleRewardType.CAPSULE_REWARD_STAR;
    case 2:
    case "CAPSULE_REWARD_BLAST_GOLD":
      return CapsuleRewardType.CAPSULE_REWARD_BLAST_GOLD;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CapsuleRewardType");
  }
}

export function capsuleRewardTypeToJSON(object: CapsuleRewardType): string {
  switch (object) {
    case CapsuleRewardType.CAPSULE_REWARD_TYPE_UNSPECIFIED:
      return "CAPSULE_REWARD_TYPE_UNSPECIFIED";
    case CapsuleRewardType.CAPSULE_REWARD_STAR:
      return "CAPSULE_REWARD_STAR";
    case CapsuleRewardType.CAPSULE_REWARD_BLAST_GOLD:
      return "CAPSULE_REWARD_BLAST_GOLD";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CapsuleRewardType");
  }
}

export function capsuleRewardTypeToNumber(object: CapsuleRewardType): number {
  switch (object) {
    case CapsuleRewardType.CAPSULE_REWARD_TYPE_UNSPECIFIED:
      return 0;
    case CapsuleRewardType.CAPSULE_REWARD_STAR:
      return 1;
    case CapsuleRewardType.CAPSULE_REWARD_BLAST_GOLD:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum CapsuleRewardType");
  }
}

export enum SuspiciousReason {
  SUSPICIOUS_REASON_UNSPECIFIED = "SUSPICIOUS_REASON_UNSPECIFIED",
  SUSPICIOUS_REASON_DEBUG_CONSOLE_OPENED = "SUSPICIOUS_REASON_DEBUG_CONSOLE_OPENED",
}

export function suspiciousReasonFromJSON(object: any): SuspiciousReason {
  switch (object) {
    case 0:
    case "SUSPICIOUS_REASON_UNSPECIFIED":
      return SuspiciousReason.SUSPICIOUS_REASON_UNSPECIFIED;
    case 1:
    case "SUSPICIOUS_REASON_DEBUG_CONSOLE_OPENED":
      return SuspiciousReason.SUSPICIOUS_REASON_DEBUG_CONSOLE_OPENED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SuspiciousReason");
  }
}

export function suspiciousReasonToJSON(object: SuspiciousReason): string {
  switch (object) {
    case SuspiciousReason.SUSPICIOUS_REASON_UNSPECIFIED:
      return "SUSPICIOUS_REASON_UNSPECIFIED";
    case SuspiciousReason.SUSPICIOUS_REASON_DEBUG_CONSOLE_OPENED:
      return "SUSPICIOUS_REASON_DEBUG_CONSOLE_OPENED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SuspiciousReason");
  }
}

export function suspiciousReasonToNumber(object: SuspiciousReason): number {
  switch (object) {
    case SuspiciousReason.SUSPICIOUS_REASON_UNSPECIFIED:
      return 0;
    case SuspiciousReason.SUSPICIOUS_REASON_DEBUG_CONSOLE_OPENED:
      return 1;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SuspiciousReason");
  }
}

export interface GetDailyPlayCountRequest {
  /** Format: users/{address} */
  user: string;
}

export interface GetDailyPlayCountResponse {
  /** The daily play count of the user. */
  dailyPlayCount: number;
  /** The daily play count of the user. */
  dailyPlayCountQuota: number;
}

export interface ClientMessage {
  msgType: ClientMessageType;
  payload: string;
}

export interface ServerMessage {
  msgType: ServerMessageType;
  ackType: ServerAckType;
  payload: string;
}

export interface ConnectServerPayload {
  sessionId: string;
  game: Game | undefined;
}

export interface ReconnectServerPayload {
  sessionId: string;
  game: Game | undefined;
}

export interface EndGameServerPayload {
  gameId: string;
  score: number;
  blastGold: number;
}

export interface TakeStarClientPayload {
  starId: string;
}

export interface TakeStarServerPayload {
  starId: string;
  totalScore: number;
}

export interface TakeBlastGoldClientPayload {
  blastGoldId: string;
}

export interface DestroyCapsuleClientPayload {
  capsuleId: string;
}

export interface DestroyMeteorClientPayload {
  position: Position | undefined;
}

export interface SpceshipPosiitionClientPayload {
  position: Position | undefined;
}

export interface SpaceshipEventClientPayload {
  event: string;
}

export interface KeyboardEventClientPayload {
  event: string;
}

export interface ShootBulletClientPayload {
  remainingBullets: number;
}

export interface EmployBoostClientPayload {
  remainingBoosts: number;
}

export interface LifeStatusClientPayload {
  remainingLives: number;
}

export interface AlertSuspiciousUserClientPayload {
  reason: SuspiciousReason;
}

export interface Star {
  id: string;
  capsuleId?: string | undefined;
  position: Position | undefined;
  score: number;
}

export interface Capsule {
  id: string;
  position: Position | undefined;
  rewardType: CapsuleRewardType;
}

export interface BlastGold {
  id: string;
  capsuleId: string;
  amount: number;
}

export interface Meteor {
  id: string;
  position: Position | undefined;
}

export interface Position {
  x: number;
  y: number;
}

export interface Map {
  stars: Star[];
  capsules: Capsule[];
  blastGolds: BlastGold[];
  meteors: Meteor[];
}

export interface Spaceship {
  position: Position | undefined;
  booster: number;
  bullet: number;
}

export interface Game {
  id: string;
  map: Map | undefined;
  spaceship: Spaceship | undefined;
  score: number;
  createTime: string | undefined;
  startTime: string | undefined;
}

function createBaseGetDailyPlayCountRequest(): GetDailyPlayCountRequest {
  return { user: "" };
}

export const GetDailyPlayCountRequest: MessageFns<GetDailyPlayCountRequest> = {
  encode(message: GetDailyPlayCountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDailyPlayCountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDailyPlayCountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDailyPlayCountRequest {
    return { user: isSet(object.user) ? globalThis.String(object.user) : "" };
  },

  toJSON(message: GetDailyPlayCountRequest): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDailyPlayCountRequest>, I>>(base?: I): GetDailyPlayCountRequest {
    return GetDailyPlayCountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDailyPlayCountRequest>, I>>(object: I): GetDailyPlayCountRequest {
    const message = createBaseGetDailyPlayCountRequest();
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseGetDailyPlayCountResponse(): GetDailyPlayCountResponse {
  return { dailyPlayCount: 0, dailyPlayCountQuota: 0 };
}

export const GetDailyPlayCountResponse: MessageFns<GetDailyPlayCountResponse> = {
  encode(message: GetDailyPlayCountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dailyPlayCount !== 0) {
      writer.uint32(8).uint32(message.dailyPlayCount);
    }
    if (message.dailyPlayCountQuota !== 0) {
      writer.uint32(16).uint32(message.dailyPlayCountQuota);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDailyPlayCountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDailyPlayCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dailyPlayCount = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dailyPlayCountQuota = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDailyPlayCountResponse {
    return {
      dailyPlayCount: isSet(object.dailyPlayCount) ? globalThis.Number(object.dailyPlayCount) : 0,
      dailyPlayCountQuota: isSet(object.dailyPlayCountQuota) ? globalThis.Number(object.dailyPlayCountQuota) : 0,
    };
  },

  toJSON(message: GetDailyPlayCountResponse): unknown {
    const obj: any = {};
    if (message.dailyPlayCount !== undefined) {
      obj.dailyPlayCount = Math.round(message.dailyPlayCount);
    }
    if (message.dailyPlayCountQuota !== undefined) {
      obj.dailyPlayCountQuota = Math.round(message.dailyPlayCountQuota);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDailyPlayCountResponse>, I>>(base?: I): GetDailyPlayCountResponse {
    return GetDailyPlayCountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDailyPlayCountResponse>, I>>(object: I): GetDailyPlayCountResponse {
    const message = createBaseGetDailyPlayCountResponse();
    message.dailyPlayCount = object.dailyPlayCount ?? 0;
    message.dailyPlayCountQuota = object.dailyPlayCountQuota ?? 0;
    return message;
  },
};

function createBaseClientMessage(): ClientMessage {
  return { msgType: ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED, payload: "" };
}

export const ClientMessage: MessageFns<ClientMessage> = {
  encode(message: ClientMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgType !== ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(clientMessageTypeToNumber(message.msgType));
    }
    if (message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgType = clientMessageTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMessage {
    return {
      msgType: isSet(object.msgType)
        ? clientMessageTypeFromJSON(object.msgType)
        : ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED,
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
    };
  },

  toJSON(message: ClientMessage): unknown {
    const obj: any = {};
    if (message.msgType !== undefined) {
      obj.msgType = clientMessageTypeToJSON(message.msgType);
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMessage>, I>>(base?: I): ClientMessage {
    return ClientMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMessage>, I>>(object: I): ClientMessage {
    const message = createBaseClientMessage();
    message.msgType = object.msgType ?? ClientMessageType.CLIENT_MESSAGE_TYPE_UNSPECIFIED;
    message.payload = object.payload ?? "";
    return message;
  },
};

function createBaseServerMessage(): ServerMessage {
  return {
    msgType: ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED,
    ackType: ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED,
    payload: "",
  };
}

export const ServerMessage: MessageFns<ServerMessage> = {
  encode(message: ServerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgType !== ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED) {
      writer.uint32(8).int32(serverMessageTypeToNumber(message.msgType));
    }
    if (message.ackType !== ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED) {
      writer.uint32(16).int32(serverAckTypeToNumber(message.ackType));
    }
    if (message.payload !== "") {
      writer.uint32(26).string(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgType = serverMessageTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ackType = serverAckTypeFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMessage {
    return {
      msgType: isSet(object.msgType)
        ? serverMessageTypeFromJSON(object.msgType)
        : ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED,
      ackType: isSet(object.ackType)
        ? serverAckTypeFromJSON(object.ackType)
        : ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED,
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
    };
  },

  toJSON(message: ServerMessage): unknown {
    const obj: any = {};
    if (message.msgType !== undefined) {
      obj.msgType = serverMessageTypeToJSON(message.msgType);
    }
    if (message.ackType !== undefined) {
      obj.ackType = serverAckTypeToJSON(message.ackType);
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMessage>, I>>(base?: I): ServerMessage {
    return ServerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMessage>, I>>(object: I): ServerMessage {
    const message = createBaseServerMessage();
    message.msgType = object.msgType ?? ServerMessageType.SERVER_MESSAGE_TYPE_UNSPECIFIED;
    message.ackType = object.ackType ?? ServerAckType.SERVER_RESPONSE_TYPE_UNSPECIFIED;
    message.payload = object.payload ?? "";
    return message;
  },
};

function createBaseConnectServerPayload(): ConnectServerPayload {
  return { sessionId: "", game: undefined };
}

export const ConnectServerPayload: MessageFns<ConnectServerPayload> = {
  encode(message: ConnectServerPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectServerPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectServerPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectServerPayload {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
    };
  },

  toJSON(message: ConnectServerPayload): unknown {
    const obj: any = {};
    if (message.sessionId !== undefined) {
      obj.sessionId = message.sessionId;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectServerPayload>, I>>(base?: I): ConnectServerPayload {
    return ConnectServerPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectServerPayload>, I>>(object: I): ConnectServerPayload {
    const message = createBaseConnectServerPayload();
    message.sessionId = object.sessionId ?? "";
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    return message;
  },
};

function createBaseReconnectServerPayload(): ReconnectServerPayload {
  return { sessionId: "", game: undefined };
}

export const ReconnectServerPayload: MessageFns<ReconnectServerPayload> = {
  encode(message: ReconnectServerPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.game !== undefined) {
      Game.encode(message.game, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconnectServerPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconnectServerPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.game = Game.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconnectServerPayload {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      game: isSet(object.game) ? Game.fromJSON(object.game) : undefined,
    };
  },

  toJSON(message: ReconnectServerPayload): unknown {
    const obj: any = {};
    if (message.sessionId !== undefined) {
      obj.sessionId = message.sessionId;
    }
    if (message.game !== undefined) {
      obj.game = Game.toJSON(message.game);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReconnectServerPayload>, I>>(base?: I): ReconnectServerPayload {
    return ReconnectServerPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReconnectServerPayload>, I>>(object: I): ReconnectServerPayload {
    const message = createBaseReconnectServerPayload();
    message.sessionId = object.sessionId ?? "";
    message.game = (object.game !== undefined && object.game !== null) ? Game.fromPartial(object.game) : undefined;
    return message;
  },
};

function createBaseEndGameServerPayload(): EndGameServerPayload {
  return { gameId: "", score: 0, blastGold: 0 };
}

export const EndGameServerPayload: MessageFns<EndGameServerPayload> = {
  encode(message: EndGameServerPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameId !== "") {
      writer.uint32(10).string(message.gameId);
    }
    if (message.score !== 0) {
      writer.uint32(16).int32(message.score);
    }
    if (message.blastGold !== 0) {
      writer.uint32(29).float(message.blastGold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndGameServerPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndGameServerPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gameId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.blastGold = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndGameServerPayload {
    return {
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      blastGold: isSet(object.blastGold) ? globalThis.Number(object.blastGold) : 0,
    };
  },

  toJSON(message: EndGameServerPayload): unknown {
    const obj: any = {};
    if (message.gameId !== undefined) {
      obj.gameId = message.gameId;
    }
    if (message.score !== undefined) {
      obj.score = Math.round(message.score);
    }
    if (message.blastGold !== undefined) {
      obj.blastGold = message.blastGold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndGameServerPayload>, I>>(base?: I): EndGameServerPayload {
    return EndGameServerPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndGameServerPayload>, I>>(object: I): EndGameServerPayload {
    const message = createBaseEndGameServerPayload();
    message.gameId = object.gameId ?? "";
    message.score = object.score ?? 0;
    message.blastGold = object.blastGold ?? 0;
    return message;
  },
};

function createBaseTakeStarClientPayload(): TakeStarClientPayload {
  return { starId: "" };
}

export const TakeStarClientPayload: MessageFns<TakeStarClientPayload> = {
  encode(message: TakeStarClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.starId !== "") {
      writer.uint32(10).string(message.starId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TakeStarClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeStarClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.starId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TakeStarClientPayload {
    return { starId: isSet(object.starId) ? globalThis.String(object.starId) : "" };
  },

  toJSON(message: TakeStarClientPayload): unknown {
    const obj: any = {};
    if (message.starId !== undefined) {
      obj.starId = message.starId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TakeStarClientPayload>, I>>(base?: I): TakeStarClientPayload {
    return TakeStarClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TakeStarClientPayload>, I>>(object: I): TakeStarClientPayload {
    const message = createBaseTakeStarClientPayload();
    message.starId = object.starId ?? "";
    return message;
  },
};

function createBaseTakeStarServerPayload(): TakeStarServerPayload {
  return { starId: "", totalScore: 0 };
}

export const TakeStarServerPayload: MessageFns<TakeStarServerPayload> = {
  encode(message: TakeStarServerPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.starId !== "") {
      writer.uint32(10).string(message.starId);
    }
    if (message.totalScore !== 0) {
      writer.uint32(16).int32(message.totalScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TakeStarServerPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeStarServerPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.starId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalScore = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TakeStarServerPayload {
    return {
      starId: isSet(object.starId) ? globalThis.String(object.starId) : "",
      totalScore: isSet(object.totalScore) ? globalThis.Number(object.totalScore) : 0,
    };
  },

  toJSON(message: TakeStarServerPayload): unknown {
    const obj: any = {};
    if (message.starId !== undefined) {
      obj.starId = message.starId;
    }
    if (message.totalScore !== undefined) {
      obj.totalScore = Math.round(message.totalScore);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TakeStarServerPayload>, I>>(base?: I): TakeStarServerPayload {
    return TakeStarServerPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TakeStarServerPayload>, I>>(object: I): TakeStarServerPayload {
    const message = createBaseTakeStarServerPayload();
    message.starId = object.starId ?? "";
    message.totalScore = object.totalScore ?? 0;
    return message;
  },
};

function createBaseTakeBlastGoldClientPayload(): TakeBlastGoldClientPayload {
  return { blastGoldId: "" };
}

export const TakeBlastGoldClientPayload: MessageFns<TakeBlastGoldClientPayload> = {
  encode(message: TakeBlastGoldClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blastGoldId !== "") {
      writer.uint32(10).string(message.blastGoldId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TakeBlastGoldClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeBlastGoldClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blastGoldId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TakeBlastGoldClientPayload {
    return { blastGoldId: isSet(object.blastGoldId) ? globalThis.String(object.blastGoldId) : "" };
  },

  toJSON(message: TakeBlastGoldClientPayload): unknown {
    const obj: any = {};
    if (message.blastGoldId !== undefined) {
      obj.blastGoldId = message.blastGoldId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TakeBlastGoldClientPayload>, I>>(base?: I): TakeBlastGoldClientPayload {
    return TakeBlastGoldClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TakeBlastGoldClientPayload>, I>>(object: I): TakeBlastGoldClientPayload {
    const message = createBaseTakeBlastGoldClientPayload();
    message.blastGoldId = object.blastGoldId ?? "";
    return message;
  },
};

function createBaseDestroyCapsuleClientPayload(): DestroyCapsuleClientPayload {
  return { capsuleId: "" };
}

export const DestroyCapsuleClientPayload: MessageFns<DestroyCapsuleClientPayload> = {
  encode(message: DestroyCapsuleClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.capsuleId !== "") {
      writer.uint32(10).string(message.capsuleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroyCapsuleClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroyCapsuleClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.capsuleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroyCapsuleClientPayload {
    return { capsuleId: isSet(object.capsuleId) ? globalThis.String(object.capsuleId) : "" };
  },

  toJSON(message: DestroyCapsuleClientPayload): unknown {
    const obj: any = {};
    if (message.capsuleId !== undefined) {
      obj.capsuleId = message.capsuleId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestroyCapsuleClientPayload>, I>>(base?: I): DestroyCapsuleClientPayload {
    return DestroyCapsuleClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestroyCapsuleClientPayload>, I>>(object: I): DestroyCapsuleClientPayload {
    const message = createBaseDestroyCapsuleClientPayload();
    message.capsuleId = object.capsuleId ?? "";
    return message;
  },
};

function createBaseDestroyMeteorClientPayload(): DestroyMeteorClientPayload {
  return { position: undefined };
}

export const DestroyMeteorClientPayload: MessageFns<DestroyMeteorClientPayload> = {
  encode(message: DestroyMeteorClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestroyMeteorClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroyMeteorClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroyMeteorClientPayload {
    return { position: isSet(object.position) ? Position.fromJSON(object.position) : undefined };
  },

  toJSON(message: DestroyMeteorClientPayload): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestroyMeteorClientPayload>, I>>(base?: I): DestroyMeteorClientPayload {
    return DestroyMeteorClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestroyMeteorClientPayload>, I>>(object: I): DestroyMeteorClientPayload {
    const message = createBaseDestroyMeteorClientPayload();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseSpceshipPosiitionClientPayload(): SpceshipPosiitionClientPayload {
  return { position: undefined };
}

export const SpceshipPosiitionClientPayload: MessageFns<SpceshipPosiitionClientPayload> = {
  encode(message: SpceshipPosiitionClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpceshipPosiitionClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpceshipPosiitionClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpceshipPosiitionClientPayload {
    return { position: isSet(object.position) ? Position.fromJSON(object.position) : undefined };
  },

  toJSON(message: SpceshipPosiitionClientPayload): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpceshipPosiitionClientPayload>, I>>(base?: I): SpceshipPosiitionClientPayload {
    return SpceshipPosiitionClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpceshipPosiitionClientPayload>, I>>(
    object: I,
  ): SpceshipPosiitionClientPayload {
    const message = createBaseSpceshipPosiitionClientPayload();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseSpaceshipEventClientPayload(): SpaceshipEventClientPayload {
  return { event: "" };
}

export const SpaceshipEventClientPayload: MessageFns<SpaceshipEventClientPayload> = {
  encode(message: SpaceshipEventClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== "") {
      writer.uint32(10).string(message.event);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpaceshipEventClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpaceshipEventClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpaceshipEventClientPayload {
    return { event: isSet(object.event) ? globalThis.String(object.event) : "" };
  },

  toJSON(message: SpaceshipEventClientPayload): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = message.event;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpaceshipEventClientPayload>, I>>(base?: I): SpaceshipEventClientPayload {
    return SpaceshipEventClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpaceshipEventClientPayload>, I>>(object: I): SpaceshipEventClientPayload {
    const message = createBaseSpaceshipEventClientPayload();
    message.event = object.event ?? "";
    return message;
  },
};

function createBaseKeyboardEventClientPayload(): KeyboardEventClientPayload {
  return { event: "" };
}

export const KeyboardEventClientPayload: MessageFns<KeyboardEventClientPayload> = {
  encode(message: KeyboardEventClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== "") {
      writer.uint32(10).string(message.event);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyboardEventClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyboardEventClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyboardEventClientPayload {
    return { event: isSet(object.event) ? globalThis.String(object.event) : "" };
  },

  toJSON(message: KeyboardEventClientPayload): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = message.event;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyboardEventClientPayload>, I>>(base?: I): KeyboardEventClientPayload {
    return KeyboardEventClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyboardEventClientPayload>, I>>(object: I): KeyboardEventClientPayload {
    const message = createBaseKeyboardEventClientPayload();
    message.event = object.event ?? "";
    return message;
  },
};

function createBaseShootBulletClientPayload(): ShootBulletClientPayload {
  return { remainingBullets: 0 };
}

export const ShootBulletClientPayload: MessageFns<ShootBulletClientPayload> = {
  encode(message: ShootBulletClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.remainingBullets !== 0) {
      writer.uint32(8).int32(message.remainingBullets);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShootBulletClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShootBulletClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.remainingBullets = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShootBulletClientPayload {
    return { remainingBullets: isSet(object.remainingBullets) ? globalThis.Number(object.remainingBullets) : 0 };
  },

  toJSON(message: ShootBulletClientPayload): unknown {
    const obj: any = {};
    if (message.remainingBullets !== undefined) {
      obj.remainingBullets = Math.round(message.remainingBullets);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShootBulletClientPayload>, I>>(base?: I): ShootBulletClientPayload {
    return ShootBulletClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShootBulletClientPayload>, I>>(object: I): ShootBulletClientPayload {
    const message = createBaseShootBulletClientPayload();
    message.remainingBullets = object.remainingBullets ?? 0;
    return message;
  },
};

function createBaseEmployBoostClientPayload(): EmployBoostClientPayload {
  return { remainingBoosts: 0 };
}

export const EmployBoostClientPayload: MessageFns<EmployBoostClientPayload> = {
  encode(message: EmployBoostClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.remainingBoosts !== 0) {
      writer.uint32(8).int32(message.remainingBoosts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmployBoostClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmployBoostClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.remainingBoosts = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmployBoostClientPayload {
    return { remainingBoosts: isSet(object.remainingBoosts) ? globalThis.Number(object.remainingBoosts) : 0 };
  },

  toJSON(message: EmployBoostClientPayload): unknown {
    const obj: any = {};
    if (message.remainingBoosts !== undefined) {
      obj.remainingBoosts = Math.round(message.remainingBoosts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmployBoostClientPayload>, I>>(base?: I): EmployBoostClientPayload {
    return EmployBoostClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmployBoostClientPayload>, I>>(object: I): EmployBoostClientPayload {
    const message = createBaseEmployBoostClientPayload();
    message.remainingBoosts = object.remainingBoosts ?? 0;
    return message;
  },
};

function createBaseLifeStatusClientPayload(): LifeStatusClientPayload {
  return { remainingLives: 0 };
}

export const LifeStatusClientPayload: MessageFns<LifeStatusClientPayload> = {
  encode(message: LifeStatusClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.remainingLives !== 0) {
      writer.uint32(8).int32(message.remainingLives);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LifeStatusClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLifeStatusClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.remainingLives = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LifeStatusClientPayload {
    return { remainingLives: isSet(object.remainingLives) ? globalThis.Number(object.remainingLives) : 0 };
  },

  toJSON(message: LifeStatusClientPayload): unknown {
    const obj: any = {};
    if (message.remainingLives !== undefined) {
      obj.remainingLives = Math.round(message.remainingLives);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LifeStatusClientPayload>, I>>(base?: I): LifeStatusClientPayload {
    return LifeStatusClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LifeStatusClientPayload>, I>>(object: I): LifeStatusClientPayload {
    const message = createBaseLifeStatusClientPayload();
    message.remainingLives = object.remainingLives ?? 0;
    return message;
  },
};

function createBaseAlertSuspiciousUserClientPayload(): AlertSuspiciousUserClientPayload {
  return { reason: SuspiciousReason.SUSPICIOUS_REASON_UNSPECIFIED };
}

export const AlertSuspiciousUserClientPayload: MessageFns<AlertSuspiciousUserClientPayload> = {
  encode(message: AlertSuspiciousUserClientPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== SuspiciousReason.SUSPICIOUS_REASON_UNSPECIFIED) {
      writer.uint32(8).int32(suspiciousReasonToNumber(message.reason));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertSuspiciousUserClientPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertSuspiciousUserClientPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reason = suspiciousReasonFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertSuspiciousUserClientPayload {
    return {
      reason: isSet(object.reason)
        ? suspiciousReasonFromJSON(object.reason)
        : SuspiciousReason.SUSPICIOUS_REASON_UNSPECIFIED,
    };
  },

  toJSON(message: AlertSuspiciousUserClientPayload): unknown {
    const obj: any = {};
    if (message.reason !== undefined) {
      obj.reason = suspiciousReasonToJSON(message.reason);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlertSuspiciousUserClientPayload>, I>>(
    base?: I,
  ): AlertSuspiciousUserClientPayload {
    return AlertSuspiciousUserClientPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlertSuspiciousUserClientPayload>, I>>(
    object: I,
  ): AlertSuspiciousUserClientPayload {
    const message = createBaseAlertSuspiciousUserClientPayload();
    message.reason = object.reason ?? SuspiciousReason.SUSPICIOUS_REASON_UNSPECIFIED;
    return message;
  },
};

function createBaseStar(): Star {
  return { id: "", capsuleId: undefined, position: undefined, score: 0 };
}

export const Star: MessageFns<Star> = {
  encode(message: Star, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.capsuleId !== undefined) {
      writer.uint32(18).string(message.capsuleId);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(26).fork()).join();
    }
    if (message.score !== 0) {
      writer.uint32(32).int32(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Star {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.capsuleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Star {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      capsuleId: isSet(object.capsuleId) ? globalThis.String(object.capsuleId) : undefined,
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: Star): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.capsuleId !== undefined) {
      obj.capsuleId = message.capsuleId;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.score !== undefined) {
      obj.score = Math.round(message.score);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Star>, I>>(base?: I): Star {
    return Star.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Star>, I>>(object: I): Star {
    const message = createBaseStar();
    message.id = object.id ?? "";
    message.capsuleId = object.capsuleId ?? undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseCapsule(): Capsule {
  return { id: "", position: undefined, rewardType: CapsuleRewardType.CAPSULE_REWARD_TYPE_UNSPECIFIED };
}

export const Capsule: MessageFns<Capsule> = {
  encode(message: Capsule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(18).fork()).join();
    }
    if (message.rewardType !== CapsuleRewardType.CAPSULE_REWARD_TYPE_UNSPECIFIED) {
      writer.uint32(24).int32(capsuleRewardTypeToNumber(message.rewardType));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Capsule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapsule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rewardType = capsuleRewardTypeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Capsule {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      rewardType: isSet(object.rewardType)
        ? capsuleRewardTypeFromJSON(object.rewardType)
        : CapsuleRewardType.CAPSULE_REWARD_TYPE_UNSPECIFIED,
    };
  },

  toJSON(message: Capsule): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.rewardType !== undefined) {
      obj.rewardType = capsuleRewardTypeToJSON(message.rewardType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Capsule>, I>>(base?: I): Capsule {
    return Capsule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Capsule>, I>>(object: I): Capsule {
    const message = createBaseCapsule();
    message.id = object.id ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.rewardType = object.rewardType ?? CapsuleRewardType.CAPSULE_REWARD_TYPE_UNSPECIFIED;
    return message;
  },
};

function createBaseBlastGold(): BlastGold {
  return { id: "", capsuleId: "", amount: 0 };
}

export const BlastGold: MessageFns<BlastGold> = {
  encode(message: BlastGold, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.capsuleId !== "") {
      writer.uint32(18).string(message.capsuleId);
    }
    if (message.amount !== 0) {
      writer.uint32(29).float(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlastGold {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlastGold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.capsuleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.amount = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlastGold {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      capsuleId: isSet(object.capsuleId) ? globalThis.String(object.capsuleId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: BlastGold): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.capsuleId !== undefined) {
      obj.capsuleId = message.capsuleId;
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlastGold>, I>>(base?: I): BlastGold {
    return BlastGold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlastGold>, I>>(object: I): BlastGold {
    const message = createBaseBlastGold();
    message.id = object.id ?? "";
    message.capsuleId = object.capsuleId ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseMeteor(): Meteor {
  return { id: "", position: undefined };
}

export const Meteor: MessageFns<Meteor> = {
  encode(message: Meteor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Meteor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeteor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Meteor {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: Meteor): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Meteor>, I>>(base?: I): Meteor {
    return Meteor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Meteor>, I>>(object: I): Meteor {
    const message = createBaseMeteor();
    message.id = object.id ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBasePosition(): Position {
  return { x: 0, y: 0 };
}

export const Position: MessageFns<Position> = {
  encode(message: Position, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Position {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Position {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Position): unknown {
    const obj: any = {};
    if (message.x !== undefined) {
      obj.x = message.x;
    }
    if (message.y !== undefined) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Position>, I>>(base?: I): Position {
    return Position.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Position>, I>>(object: I): Position {
    const message = createBasePosition();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseMap(): Map {
  return { stars: [], capsules: [], blastGolds: [], meteors: [] };
}

export const Map: MessageFns<Map> = {
  encode(message: Map, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.stars) {
      Star.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.capsules) {
      Capsule.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.blastGolds) {
      BlastGold.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.meteors) {
      Meteor.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Map {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stars.push(Star.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.capsules.push(Capsule.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blastGolds.push(BlastGold.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.meteors.push(Meteor.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Map {
    return {
      stars: globalThis.Array.isArray(object?.stars) ? object.stars.map((e: any) => Star.fromJSON(e)) : [],
      capsules: globalThis.Array.isArray(object?.capsules) ? object.capsules.map((e: any) => Capsule.fromJSON(e)) : [],
      blastGolds: globalThis.Array.isArray(object?.blastGolds)
        ? object.blastGolds.map((e: any) => BlastGold.fromJSON(e))
        : [],
      meteors: globalThis.Array.isArray(object?.meteors) ? object.meteors.map((e: any) => Meteor.fromJSON(e)) : [],
    };
  },

  toJSON(message: Map): unknown {
    const obj: any = {};
    if (message.stars?.length) {
      obj.stars = message.stars.map((e) => Star.toJSON(e));
    }
    if (message.capsules?.length) {
      obj.capsules = message.capsules.map((e) => Capsule.toJSON(e));
    }
    if (message.blastGolds?.length) {
      obj.blastGolds = message.blastGolds.map((e) => BlastGold.toJSON(e));
    }
    if (message.meteors?.length) {
      obj.meteors = message.meteors.map((e) => Meteor.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Map>, I>>(base?: I): Map {
    return Map.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Map>, I>>(object: I): Map {
    const message = createBaseMap();
    message.stars = object.stars?.map((e) => Star.fromPartial(e)) || [];
    message.capsules = object.capsules?.map((e) => Capsule.fromPartial(e)) || [];
    message.blastGolds = object.blastGolds?.map((e) => BlastGold.fromPartial(e)) || [];
    message.meteors = object.meteors?.map((e) => Meteor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpaceship(): Spaceship {
  return { position: undefined, booster: 0, bullet: 0 };
}

export const Spaceship: MessageFns<Spaceship> = {
  encode(message: Spaceship, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(10).fork()).join();
    }
    if (message.booster !== 0) {
      writer.uint32(16).int32(message.booster);
    }
    if (message.bullet !== 0) {
      writer.uint32(24).int32(message.bullet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spaceship {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpaceship();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.booster = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bullet = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spaceship {
    return {
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      booster: isSet(object.booster) ? globalThis.Number(object.booster) : 0,
      bullet: isSet(object.bullet) ? globalThis.Number(object.bullet) : 0,
    };
  },

  toJSON(message: Spaceship): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.booster !== undefined) {
      obj.booster = Math.round(message.booster);
    }
    if (message.bullet !== undefined) {
      obj.bullet = Math.round(message.bullet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Spaceship>, I>>(base?: I): Spaceship {
    return Spaceship.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Spaceship>, I>>(object: I): Spaceship {
    const message = createBaseSpaceship();
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.booster = object.booster ?? 0;
    message.bullet = object.bullet ?? 0;
    return message;
  },
};

function createBaseGame(): Game {
  return { id: "", map: undefined, spaceship: undefined, score: 0, createTime: undefined, startTime: undefined };
}

export const Game: MessageFns<Game> = {
  encode(message: Game, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.map !== undefined) {
      Map.encode(message.map, writer.uint32(18).fork()).join();
    }
    if (message.spaceship !== undefined) {
      Spaceship.encode(message.spaceship, writer.uint32(26).fork()).join();
    }
    if (message.score !== 0) {
      writer.uint32(32).int32(message.score);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Game {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.map = Map.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.spaceship = Spaceship.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Game {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      map: isSet(object.map) ? Map.fromJSON(object.map) : undefined,
      spaceship: isSet(object.spaceship) ? Spaceship.fromJSON(object.spaceship) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : undefined,
    };
  },

  toJSON(message: Game): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.map !== undefined) {
      obj.map = Map.toJSON(message.map);
    }
    if (message.spaceship !== undefined) {
      obj.spaceship = Spaceship.toJSON(message.spaceship);
    }
    if (message.score !== undefined) {
      obj.score = Math.round(message.score);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Game>, I>>(base?: I): Game {
    return Game.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Game>, I>>(object: I): Game {
    const message = createBaseGame();
    message.id = object.id ?? "";
    message.map = (object.map !== undefined && object.map !== null) ? Map.fromPartial(object.map) : undefined;
    message.spaceship = (object.spaceship !== undefined && object.spaceship !== null)
      ? Spaceship.fromPartial(object.spaceship)
      : undefined;
    message.score = object.score ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    return message;
  },
};

/** GameService contains the function to interact with the Game of the spacebar */
export type GameServiceService = typeof GameServiceService;
export const GameServiceService = {
  /** GetUserDailyPlayCount will return the User's daily play count. */
  getDailyPlayCount: {
    path: "/blast.v1.game.GameService/GetDailyPlayCount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDailyPlayCountRequest) => Buffer.from(GetDailyPlayCountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetDailyPlayCountRequest.decode(value),
    responseSerialize: (value: GetDailyPlayCountResponse) =>
      Buffer.from(GetDailyPlayCountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetDailyPlayCountResponse.decode(value),
  },
} as const;

export interface GameServiceServer extends UntypedServiceImplementation {
  /** GetUserDailyPlayCount will return the User's daily play count. */
  getDailyPlayCount: handleUnaryCall<GetDailyPlayCountRequest, GetDailyPlayCountResponse>;
}

export interface GameServiceClient extends Client {
  /** GetUserDailyPlayCount will return the User's daily play count. */
  getDailyPlayCount(
    request: GetDailyPlayCountRequest,
    callback: (error: ServiceError | null, response: GetDailyPlayCountResponse) => void,
  ): ClientUnaryCall;
  getDailyPlayCount(
    request: GetDailyPlayCountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetDailyPlayCountResponse) => void,
  ): ClientUnaryCall;
  getDailyPlayCount(
    request: GetDailyPlayCountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetDailyPlayCountResponse) => void,
  ): ClientUnaryCall;
}

export const GameServiceClient = makeGenericClientConstructor(
  GameServiceService,
  "blast.v1.game.GameService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): GameServiceClient;
  service: typeof GameServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
