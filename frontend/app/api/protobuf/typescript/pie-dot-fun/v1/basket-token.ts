// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: pie-dot-fun/v1/basket-token.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { ChainType, chainTypeFromJSON, chainTypeToJSON, chainTypeToNumber, Percentage, Quantity } from "./common";

export const protobufPackage = "piedotfun.v1";

export enum BasketTokenState {
  BASKET_TOKEN_STATE_UNSPECIFIED = "BASKET_TOKEN_STATE_UNSPECIFIED",
  /** CREATED - 온체인 상에서만 생성되고, 아직 우리 서비스에서 리스팅은 되지 않은 상태 */
  CREATED = "CREATED",
  /** LISTED - 우리 서비스에서 리스팅된 상태 */
  LISTED = "LISTED",
}

export function basketTokenStateFromJSON(object: any): BasketTokenState {
  switch (object) {
    case 0:
    case "BASKET_TOKEN_STATE_UNSPECIFIED":
      return BasketTokenState.BASKET_TOKEN_STATE_UNSPECIFIED;
    case 1:
    case "CREATED":
      return BasketTokenState.CREATED;
    case 2:
    case "LISTED":
      return BasketTokenState.LISTED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BasketTokenState");
  }
}

export function basketTokenStateToJSON(object: BasketTokenState): string {
  switch (object) {
    case BasketTokenState.BASKET_TOKEN_STATE_UNSPECIFIED:
      return "BASKET_TOKEN_STATE_UNSPECIFIED";
    case BasketTokenState.CREATED:
      return "CREATED";
    case BasketTokenState.LISTED:
      return "LISTED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BasketTokenState");
  }
}

export function basketTokenStateToNumber(object: BasketTokenState): number {
  switch (object) {
    case BasketTokenState.BASKET_TOKEN_STATE_UNSPECIFIED:
      return 0;
    case BasketTokenState.CREATED:
      return 1;
    case BasketTokenState.LISTED:
      return 2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BasketTokenState");
  }
}

export enum TokenStrategy {
  TOKEN_STRATEGY_UNSPECIFIED = "TOKEN_STRATEGY_UNSPECIFIED",
  MARKET_CAP_WEIGHTED = "MARKET_CAP_WEIGHTED",
  EQUAL_WEIGHTED = "EQUAL_WEIGHTED",
  FACTOR_WEIGHTED = "FACTOR_WEIGHTED",
  FUNDAMENTAL_WEIGHTED = "FUNDAMENTAL_WEIGHTED",
  RISK_WEIGHTED = "RISK_WEIGHTED",
  MOMENTUM_WEIGHTED = "MOMENTUM_WEIGHTED",
  CUSTOM_WEIGHTED = "CUSTOM_WEIGHTED",
}

export function tokenStrategyFromJSON(object: any): TokenStrategy {
  switch (object) {
    case 0:
    case "TOKEN_STRATEGY_UNSPECIFIED":
      return TokenStrategy.TOKEN_STRATEGY_UNSPECIFIED;
    case 1:
    case "MARKET_CAP_WEIGHTED":
      return TokenStrategy.MARKET_CAP_WEIGHTED;
    case 2:
    case "EQUAL_WEIGHTED":
      return TokenStrategy.EQUAL_WEIGHTED;
    case 3:
    case "FACTOR_WEIGHTED":
      return TokenStrategy.FACTOR_WEIGHTED;
    case 4:
    case "FUNDAMENTAL_WEIGHTED":
      return TokenStrategy.FUNDAMENTAL_WEIGHTED;
    case 5:
    case "RISK_WEIGHTED":
      return TokenStrategy.RISK_WEIGHTED;
    case 6:
    case "MOMENTUM_WEIGHTED":
      return TokenStrategy.MOMENTUM_WEIGHTED;
    case 7:
    case "CUSTOM_WEIGHTED":
      return TokenStrategy.CUSTOM_WEIGHTED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TokenStrategy");
  }
}

export function tokenStrategyToJSON(object: TokenStrategy): string {
  switch (object) {
    case TokenStrategy.TOKEN_STRATEGY_UNSPECIFIED:
      return "TOKEN_STRATEGY_UNSPECIFIED";
    case TokenStrategy.MARKET_CAP_WEIGHTED:
      return "MARKET_CAP_WEIGHTED";
    case TokenStrategy.EQUAL_WEIGHTED:
      return "EQUAL_WEIGHTED";
    case TokenStrategy.FACTOR_WEIGHTED:
      return "FACTOR_WEIGHTED";
    case TokenStrategy.FUNDAMENTAL_WEIGHTED:
      return "FUNDAMENTAL_WEIGHTED";
    case TokenStrategy.RISK_WEIGHTED:
      return "RISK_WEIGHTED";
    case TokenStrategy.MOMENTUM_WEIGHTED:
      return "MOMENTUM_WEIGHTED";
    case TokenStrategy.CUSTOM_WEIGHTED:
      return "CUSTOM_WEIGHTED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TokenStrategy");
  }
}

export function tokenStrategyToNumber(object: TokenStrategy): number {
  switch (object) {
    case TokenStrategy.TOKEN_STRATEGY_UNSPECIFIED:
      return 0;
    case TokenStrategy.MARKET_CAP_WEIGHTED:
      return 1;
    case TokenStrategy.EQUAL_WEIGHTED:
      return 2;
    case TokenStrategy.FACTOR_WEIGHTED:
      return 3;
    case TokenStrategy.FUNDAMENTAL_WEIGHTED:
      return 4;
    case TokenStrategy.RISK_WEIGHTED:
      return 5;
    case TokenStrategy.MOMENTUM_WEIGHTED:
      return 6;
    case TokenStrategy.CUSTOM_WEIGHTED:
      return 7;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TokenStrategy");
  }
}

export enum RebalanceFrequency {
  REBALANCE_FREQUENCY_UNSPECIFIED = "REBALANCE_FREQUENCY_UNSPECIFIED",
  MANUAL = "MANUAL",
  DAILY = "DAILY",
  WEEKLY = "WEEKLY",
  MONTHLY = "MONTHLY",
}

export function rebalanceFrequencyFromJSON(object: any): RebalanceFrequency {
  switch (object) {
    case 0:
    case "REBALANCE_FREQUENCY_UNSPECIFIED":
      return RebalanceFrequency.REBALANCE_FREQUENCY_UNSPECIFIED;
    case 1:
    case "MANUAL":
      return RebalanceFrequency.MANUAL;
    case 2:
    case "DAILY":
      return RebalanceFrequency.DAILY;
    case 3:
    case "WEEKLY":
      return RebalanceFrequency.WEEKLY;
    case 4:
    case "MONTHLY":
      return RebalanceFrequency.MONTHLY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RebalanceFrequency");
  }
}

export function rebalanceFrequencyToJSON(object: RebalanceFrequency): string {
  switch (object) {
    case RebalanceFrequency.REBALANCE_FREQUENCY_UNSPECIFIED:
      return "REBALANCE_FREQUENCY_UNSPECIFIED";
    case RebalanceFrequency.MANUAL:
      return "MANUAL";
    case RebalanceFrequency.DAILY:
      return "DAILY";
    case RebalanceFrequency.WEEKLY:
      return "WEEKLY";
    case RebalanceFrequency.MONTHLY:
      return "MONTHLY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RebalanceFrequency");
  }
}

export function rebalanceFrequencyToNumber(object: RebalanceFrequency): number {
  switch (object) {
    case RebalanceFrequency.REBALANCE_FREQUENCY_UNSPECIFIED:
      return 0;
    case RebalanceFrequency.MANUAL:
      return 1;
    case RebalanceFrequency.DAILY:
      return 2;
    case RebalanceFrequency.WEEKLY:
      return 3;
    case RebalanceFrequency.MONTHLY:
      return 4;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RebalanceFrequency");
  }
}

export interface GetBasketTokenRequest {
  /**
   * The name of the basket token to retrieve.
   * Format : "basketTokens/{chain}/{token_address}"
   */
  basketToken: string;
}

/**
 * ListBasketTokensRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface ListBasketTokensRequest {
  /**
   * The maximum number of basket tokens to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListBasketTokens` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Available Sequence and Operator
   * * name
   *   * `=`
   * * chain
   *   * `=`
   * * display_name
   *   * `=`
   * * symbol
   *   * `=`
   * * state
   *   * `=` (CREATED, LISTED)
   * * onchain_id
   *   * `=`
   * * market_cap_sol
   *   * `=`, `>`, `<`, `>=`, `<=`
   * * market_cap_usdc
   *   * `=`, `>`, `<`, `>=`, `<=`
   *
   * Examples
   * * name="basketTokens/SOLANA/FZ4MT1HYJHd9GK8D5mJ9f3r7irLaDL5NxBNLjGqrLqs9"
   * * chain=SOLANA
   * * symbol="MURAD"
   * * state=LISTED
   * * onchain_id="10"
   * * market_cap_sol>=1000000
   */
  filter: string;
  /**
   * One or more fields to compare and use to sort the output. (optional)
   * Default order for a field is descending by id
   * To specify ascending or descending order, append " asc" or " desc" to the field name. If not specified, the order is ascending.
   *
   * Reference
   * * https://google.aip.dev/132#ordering.
   *
   * Supported Fields
   * * "create_time", "market_cap_sol", "market_cap_usdc"
   *
   * Examples
   * * order_by=create_time desc
   * * order_by=market_cap_sol desc
   */
  orderBy: string;
}

export interface ListBasketTokensResponse {
  basketTokens: BasketToken[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface ListRebalancingHistoriesRequest {
  /**
   * The name of the basket token to retrieve.
   * Format : "basketTokens/{chain}/{token_address}"
   */
  basketToken: string;
  /**
   * The maximum number of histories to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListUsers` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Available Sequence and Operator
   * * components_changed
   *   * `negation`
   *
   * Examples
   * * filter=components_changed
   * * filter=NOT components_changed
   */
  filter: string;
}

export interface ListRebalancingHistoriesResponse {
  rebalancingHistories: BasketTokenRebanlancingHistory[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface BasketToken {
  /** Format : "basketTokens/{chain}/{token_address}" */
  name: string;
  chain: ChainType;
  address: string;
  displayName: string;
  symbol: string;
  iconImageUri: string;
  description: string;
  oneLineDescription: string;
  state: BasketTokenState;
  strategy: TokenStrategy;
  rebalanceFrequency: RebalanceFrequency;
  isRebalancing: boolean;
  components: Component[];
  /**
   * The creator of the basket token
   * Format : "users/{user_id}"
   */
  creator: string;
  createTime: string | undefined;
  expireTime: string | undefined;
  lastRebalanceTime: string | undefined;
  totalSupply: Quantity | undefined;
  totalHolders: number;
  onchainId: string;
}

export interface Component {
  /** Format : "fungibleTokens/{chain}/{token_address}" */
  fungibleToken: string;
  chain: ChainType;
  address: string;
  /**
   * The weight of the component in the basket token.
   * The weight is a percentage of the total value within the basket token. (0.0 ~ 100.0 %)
   */
  weight: Percentage | undefined;
}

export interface BasketTokenRebanlancingHistory {
  txSignatures: string[];
  beforeComponents: Component[];
  afterComponents: Component[];
  rebalanceTime: string | undefined;
  componentsChanged: boolean;
}

function createBaseGetBasketTokenRequest(): GetBasketTokenRequest {
  return { basketToken: "" };
}

export const GetBasketTokenRequest = {
  encode(message: GetBasketTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketToken !== "") {
      writer.uint32(10).string(message.basketToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBasketTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketTokenRequest {
    return { basketToken: isSet(object.basketToken) ? globalThis.String(object.basketToken) : "" };
  },

  toJSON(message: GetBasketTokenRequest): unknown {
    const obj: any = {};
    if (message.basketToken !== undefined) {
      obj.basketToken = message.basketToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketTokenRequest>, I>>(base?: I): GetBasketTokenRequest {
    return GetBasketTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketTokenRequest>, I>>(object: I): GetBasketTokenRequest {
    const message = createBaseGetBasketTokenRequest();
    message.basketToken = object.basketToken ?? "";
    return message;
  },
};

function createBaseListBasketTokensRequest(): ListBasketTokensRequest {
  return { pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListBasketTokensRequest = {
  encode(message: ListBasketTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBasketTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBasketTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBasketTokensRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListBasketTokensRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    if (message.orderBy !== undefined) {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBasketTokensRequest>, I>>(base?: I): ListBasketTokensRequest {
    return ListBasketTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBasketTokensRequest>, I>>(object: I): ListBasketTokensRequest {
    const message = createBaseListBasketTokensRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListBasketTokensResponse(): ListBasketTokensResponse {
  return { basketTokens: [], nextPageToken: "" };
}

export const ListBasketTokensResponse = {
  encode(message: ListBasketTokensResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.basketTokens) {
      BasketToken.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBasketTokensResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBasketTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketTokens.push(BasketToken.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBasketTokensResponse {
    return {
      basketTokens: globalThis.Array.isArray(object?.basketTokens)
        ? object.basketTokens.map((e: any) => BasketToken.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListBasketTokensResponse): unknown {
    const obj: any = {};
    if (message.basketTokens?.length) {
      obj.basketTokens = message.basketTokens.map((e) => BasketToken.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBasketTokensResponse>, I>>(base?: I): ListBasketTokensResponse {
    return ListBasketTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBasketTokensResponse>, I>>(object: I): ListBasketTokensResponse {
    const message = createBaseListBasketTokensResponse();
    message.basketTokens = object.basketTokens?.map((e) => BasketToken.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListRebalancingHistoriesRequest(): ListRebalancingHistoriesRequest {
  return { basketToken: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListRebalancingHistoriesRequest = {
  encode(message: ListRebalancingHistoriesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketToken !== "") {
      writer.uint32(10).string(message.basketToken);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListRebalancingHistoriesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRebalancingHistoriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketToken = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRebalancingHistoriesRequest {
    return {
      basketToken: isSet(object.basketToken) ? globalThis.String(object.basketToken) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListRebalancingHistoriesRequest): unknown {
    const obj: any = {};
    if (message.basketToken !== undefined) {
      obj.basketToken = message.basketToken;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRebalancingHistoriesRequest>, I>>(base?: I): ListRebalancingHistoriesRequest {
    return ListRebalancingHistoriesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRebalancingHistoriesRequest>, I>>(
    object: I,
  ): ListRebalancingHistoriesRequest {
    const message = createBaseListRebalancingHistoriesRequest();
    message.basketToken = object.basketToken ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListRebalancingHistoriesResponse(): ListRebalancingHistoriesResponse {
  return { rebalancingHistories: [], nextPageToken: "" };
}

export const ListRebalancingHistoriesResponse = {
  encode(message: ListRebalancingHistoriesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rebalancingHistories) {
      BasketTokenRebanlancingHistory.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListRebalancingHistoriesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRebalancingHistoriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rebalancingHistories.push(BasketTokenRebanlancingHistory.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRebalancingHistoriesResponse {
    return {
      rebalancingHistories: globalThis.Array.isArray(object?.rebalancingHistories)
        ? object.rebalancingHistories.map((e: any) => BasketTokenRebanlancingHistory.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRebalancingHistoriesResponse): unknown {
    const obj: any = {};
    if (message.rebalancingHistories?.length) {
      obj.rebalancingHistories = message.rebalancingHistories.map((e) => BasketTokenRebanlancingHistory.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRebalancingHistoriesResponse>, I>>(
    base?: I,
  ): ListRebalancingHistoriesResponse {
    return ListRebalancingHistoriesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRebalancingHistoriesResponse>, I>>(
    object: I,
  ): ListRebalancingHistoriesResponse {
    const message = createBaseListRebalancingHistoriesResponse();
    message.rebalancingHistories =
      object.rebalancingHistories?.map((e) => BasketTokenRebanlancingHistory.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseBasketToken(): BasketToken {
  return {
    name: "",
    chain: ChainType.CHAIN_UNSPECIFIED,
    address: "",
    displayName: "",
    symbol: "",
    iconImageUri: "",
    description: "",
    oneLineDescription: "",
    state: BasketTokenState.BASKET_TOKEN_STATE_UNSPECIFIED,
    strategy: TokenStrategy.TOKEN_STRATEGY_UNSPECIFIED,
    rebalanceFrequency: RebalanceFrequency.REBALANCE_FREQUENCY_UNSPECIFIED,
    isRebalancing: false,
    components: [],
    creator: "",
    createTime: undefined,
    expireTime: undefined,
    lastRebalanceTime: undefined,
    totalSupply: undefined,
    totalHolders: 0,
    onchainId: "",
  };
}

export const BasketToken = {
  encode(message: BasketToken, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.chain !== ChainType.CHAIN_UNSPECIFIED) {
      writer.uint32(16).int32(chainTypeToNumber(message.chain));
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.symbol !== "") {
      writer.uint32(42).string(message.symbol);
    }
    if (message.iconImageUri !== "") {
      writer.uint32(50).string(message.iconImageUri);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    if (message.oneLineDescription !== "") {
      writer.uint32(66).string(message.oneLineDescription);
    }
    if (message.state !== BasketTokenState.BASKET_TOKEN_STATE_UNSPECIFIED) {
      writer.uint32(72).int32(basketTokenStateToNumber(message.state));
    }
    if (message.strategy !== TokenStrategy.TOKEN_STRATEGY_UNSPECIFIED) {
      writer.uint32(80).int32(tokenStrategyToNumber(message.strategy));
    }
    if (message.rebalanceFrequency !== RebalanceFrequency.REBALANCE_FREQUENCY_UNSPECIFIED) {
      writer.uint32(88).int32(rebalanceFrequencyToNumber(message.rebalanceFrequency));
    }
    if (message.isRebalancing !== false) {
      writer.uint32(96).bool(message.isRebalancing);
    }
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    if (message.creator !== "") {
      writer.uint32(130).string(message.creator);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(138).fork()).ldelim();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(146).fork()).ldelim();
    }
    if (message.lastRebalanceTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastRebalanceTime), writer.uint32(154).fork()).ldelim();
    }
    if (message.totalSupply !== undefined) {
      Quantity.encode(message.totalSupply, writer.uint32(162).fork()).ldelim();
    }
    if (message.totalHolders !== 0) {
      writer.uint32(168).uint64(message.totalHolders);
    }
    if (message.onchainId !== "") {
      writer.uint32(178).string(message.onchainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasketToken {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.chain = chainTypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.iconImageUri = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.oneLineDescription = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.state = basketTokenStateFromJSON(reader.int32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.strategy = tokenStrategyFromJSON(reader.int32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.rebalanceFrequency = rebalanceFrequencyFromJSON(reader.int32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.isRebalancing = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.lastRebalanceTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.totalSupply = Quantity.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.totalHolders = longToNumber(reader.uint64() as Long);
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.onchainId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketToken {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      chain: isSet(object.chain) ? chainTypeFromJSON(object.chain) : ChainType.CHAIN_UNSPECIFIED,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      iconImageUri: isSet(object.iconImageUri) ? globalThis.String(object.iconImageUri) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      oneLineDescription: isSet(object.oneLineDescription) ? globalThis.String(object.oneLineDescription) : "",
      state: isSet(object.state)
        ? basketTokenStateFromJSON(object.state)
        : BasketTokenState.BASKET_TOKEN_STATE_UNSPECIFIED,
      strategy: isSet(object.strategy)
        ? tokenStrategyFromJSON(object.strategy)
        : TokenStrategy.TOKEN_STRATEGY_UNSPECIFIED,
      rebalanceFrequency: isSet(object.rebalanceFrequency)
        ? rebalanceFrequencyFromJSON(object.rebalanceFrequency)
        : RebalanceFrequency.REBALANCE_FREQUENCY_UNSPECIFIED,
      isRebalancing: isSet(object.isRebalancing) ? globalThis.Boolean(object.isRebalancing) : false,
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Component.fromJSON(e))
        : [],
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      expireTime: isSet(object.expireTime) ? globalThis.String(object.expireTime) : undefined,
      lastRebalanceTime: isSet(object.lastRebalanceTime) ? globalThis.String(object.lastRebalanceTime) : undefined,
      totalSupply: isSet(object.totalSupply) ? Quantity.fromJSON(object.totalSupply) : undefined,
      totalHolders: isSet(object.totalHolders) ? globalThis.Number(object.totalHolders) : 0,
      onchainId: isSet(object.onchainId) ? globalThis.String(object.onchainId) : "",
    };
  },

  toJSON(message: BasketToken): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.chain !== undefined) {
      obj.chain = chainTypeToJSON(message.chain);
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.iconImageUri !== undefined) {
      obj.iconImageUri = message.iconImageUri;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.oneLineDescription !== undefined) {
      obj.oneLineDescription = message.oneLineDescription;
    }
    if (message.state !== undefined) {
      obj.state = basketTokenStateToJSON(message.state);
    }
    if (message.strategy !== undefined) {
      obj.strategy = tokenStrategyToJSON(message.strategy);
    }
    if (message.rebalanceFrequency !== undefined) {
      obj.rebalanceFrequency = rebalanceFrequencyToJSON(message.rebalanceFrequency);
    }
    if (message.isRebalancing !== undefined) {
      obj.isRebalancing = message.isRebalancing;
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Component.toJSON(e));
    }
    if (message.creator !== undefined) {
      obj.creator = message.creator;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime;
    }
    if (message.lastRebalanceTime !== undefined) {
      obj.lastRebalanceTime = message.lastRebalanceTime;
    }
    if (message.totalSupply !== undefined) {
      obj.totalSupply = Quantity.toJSON(message.totalSupply);
    }
    if (message.totalHolders !== undefined) {
      obj.totalHolders = Math.round(message.totalHolders);
    }
    if (message.onchainId !== undefined) {
      obj.onchainId = message.onchainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketToken>, I>>(base?: I): BasketToken {
    return BasketToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketToken>, I>>(object: I): BasketToken {
    const message = createBaseBasketToken();
    message.name = object.name ?? "";
    message.chain = object.chain ?? ChainType.CHAIN_UNSPECIFIED;
    message.address = object.address ?? "";
    message.displayName = object.displayName ?? "";
    message.symbol = object.symbol ?? "";
    message.iconImageUri = object.iconImageUri ?? "";
    message.description = object.description ?? "";
    message.oneLineDescription = object.oneLineDescription ?? "";
    message.state = object.state ?? BasketTokenState.BASKET_TOKEN_STATE_UNSPECIFIED;
    message.strategy = object.strategy ?? TokenStrategy.TOKEN_STRATEGY_UNSPECIFIED;
    message.rebalanceFrequency = object.rebalanceFrequency ?? RebalanceFrequency.REBALANCE_FREQUENCY_UNSPECIFIED;
    message.isRebalancing = object.isRebalancing ?? false;
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    message.creator = object.creator ?? "";
    message.createTime = object.createTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.lastRebalanceTime = object.lastRebalanceTime ?? undefined;
    message.totalSupply = (object.totalSupply !== undefined && object.totalSupply !== null)
      ? Quantity.fromPartial(object.totalSupply)
      : undefined;
    message.totalHolders = object.totalHolders ?? 0;
    message.onchainId = object.onchainId ?? "";
    return message;
  },
};

function createBaseComponent(): Component {
  return { fungibleToken: "", chain: ChainType.CHAIN_UNSPECIFIED, address: "", weight: undefined };
}

export const Component = {
  encode(message: Component, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fungibleToken !== "") {
      writer.uint32(10).string(message.fungibleToken);
    }
    if (message.chain !== ChainType.CHAIN_UNSPECIFIED) {
      writer.uint32(16).int32(chainTypeToNumber(message.chain));
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.weight !== undefined) {
      Percentage.encode(message.weight, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Component {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fungibleToken = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.chain = chainTypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.weight = Percentage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Component {
    return {
      fungibleToken: isSet(object.fungibleToken) ? globalThis.String(object.fungibleToken) : "",
      chain: isSet(object.chain) ? chainTypeFromJSON(object.chain) : ChainType.CHAIN_UNSPECIFIED,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      weight: isSet(object.weight) ? Percentage.fromJSON(object.weight) : undefined,
    };
  },

  toJSON(message: Component): unknown {
    const obj: any = {};
    if (message.fungibleToken !== undefined) {
      obj.fungibleToken = message.fungibleToken;
    }
    if (message.chain !== undefined) {
      obj.chain = chainTypeToJSON(message.chain);
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.weight !== undefined) {
      obj.weight = Percentage.toJSON(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Component>, I>>(base?: I): Component {
    return Component.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Component>, I>>(object: I): Component {
    const message = createBaseComponent();
    message.fungibleToken = object.fungibleToken ?? "";
    message.chain = object.chain ?? ChainType.CHAIN_UNSPECIFIED;
    message.address = object.address ?? "";
    message.weight = (object.weight !== undefined && object.weight !== null)
      ? Percentage.fromPartial(object.weight)
      : undefined;
    return message;
  },
};

function createBaseBasketTokenRebanlancingHistory(): BasketTokenRebanlancingHistory {
  return {
    txSignatures: [],
    beforeComponents: [],
    afterComponents: [],
    rebalanceTime: undefined,
    componentsChanged: false,
  };
}

export const BasketTokenRebanlancingHistory = {
  encode(message: BasketTokenRebanlancingHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.txSignatures) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.beforeComponents) {
      Component.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.afterComponents) {
      Component.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.rebalanceTime !== undefined) {
      Timestamp.encode(toTimestamp(message.rebalanceTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.componentsChanged !== false) {
      writer.uint32(40).bool(message.componentsChanged);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasketTokenRebanlancingHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketTokenRebanlancingHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txSignatures.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.beforeComponents.push(Component.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.afterComponents.push(Component.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rebalanceTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.componentsChanged = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketTokenRebanlancingHistory {
    return {
      txSignatures: globalThis.Array.isArray(object?.txSignatures)
        ? object.txSignatures.map((e: any) => globalThis.String(e))
        : [],
      beforeComponents: globalThis.Array.isArray(object?.beforeComponents)
        ? object.beforeComponents.map((e: any) => Component.fromJSON(e))
        : [],
      afterComponents: globalThis.Array.isArray(object?.afterComponents)
        ? object.afterComponents.map((e: any) => Component.fromJSON(e))
        : [],
      rebalanceTime: isSet(object.rebalanceTime) ? globalThis.String(object.rebalanceTime) : undefined,
      componentsChanged: isSet(object.componentsChanged) ? globalThis.Boolean(object.componentsChanged) : false,
    };
  },

  toJSON(message: BasketTokenRebanlancingHistory): unknown {
    const obj: any = {};
    if (message.txSignatures?.length) {
      obj.txSignatures = message.txSignatures;
    }
    if (message.beforeComponents?.length) {
      obj.beforeComponents = message.beforeComponents.map((e) => Component.toJSON(e));
    }
    if (message.afterComponents?.length) {
      obj.afterComponents = message.afterComponents.map((e) => Component.toJSON(e));
    }
    if (message.rebalanceTime !== undefined) {
      obj.rebalanceTime = message.rebalanceTime;
    }
    if (message.componentsChanged !== undefined) {
      obj.componentsChanged = message.componentsChanged;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketTokenRebanlancingHistory>, I>>(base?: I): BasketTokenRebanlancingHistory {
    return BasketTokenRebanlancingHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketTokenRebanlancingHistory>, I>>(
    object: I,
  ): BasketTokenRebanlancingHistory {
    const message = createBaseBasketTokenRebanlancingHistory();
    message.txSignatures = object.txSignatures?.map((e) => e) || [];
    message.beforeComponents = object.beforeComponents?.map((e) => Component.fromPartial(e)) || [];
    message.afterComponents = object.afterComponents?.map((e) => Component.fromPartial(e)) || [];
    message.rebalanceTime = object.rebalanceTime ?? undefined;
    message.componentsChanged = object.componentsChanged ?? false;
    return message;
  },
};

/** BasketTokenService contains the function to interact with the BasketToken of the spacebar */
export interface BasketTokenService {
  GetBasketToken(request: GetBasketTokenRequest): Promise<BasketToken>;
  ListBasketTokens(request: ListBasketTokensRequest): Promise<ListBasketTokensResponse>;
  ListBasketTokenRebalancingHistories(
    request: ListRebalancingHistoriesRequest,
  ): Promise<ListRebalancingHistoriesResponse>;
}

export const BasketTokenServiceServiceName = "piedotfun.v1.BasketTokenService";
export class BasketTokenServiceClientImpl implements BasketTokenService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || BasketTokenServiceServiceName;
    this.rpc = rpc;
    this.GetBasketToken = this.GetBasketToken.bind(this);
    this.ListBasketTokens = this.ListBasketTokens.bind(this);
    this.ListBasketTokenRebalancingHistories = this.ListBasketTokenRebalancingHistories.bind(this);
  }
  GetBasketToken(request: GetBasketTokenRequest): Promise<BasketToken> {
    const data = GetBasketTokenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBasketToken", data);
    return promise.then((data) => BasketToken.decode(_m0.Reader.create(data)));
  }

  ListBasketTokens(request: ListBasketTokensRequest): Promise<ListBasketTokensResponse> {
    const data = ListBasketTokensRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListBasketTokens", data);
    return promise.then((data) => ListBasketTokensResponse.decode(_m0.Reader.create(data)));
  }

  ListBasketTokenRebalancingHistories(
    request: ListRebalancingHistoriesRequest,
  ): Promise<ListRebalancingHistoriesResponse> {
    const data = ListRebalancingHistoriesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListBasketTokenRebalancingHistories", data);
    return promise.then((data) => ListRebalancingHistoriesResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
