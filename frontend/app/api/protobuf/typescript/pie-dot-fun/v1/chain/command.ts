// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: pie-dot-fun/v1/chain/command.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "piedotfun.v1.chain";

export interface RebalanceCommand {
  strategy?:
    | { $case: "equalWeight"; equalWeight: RebalanceCommand_EqualMarketCapWeight }
    | { $case: "manualWeight"; manualWeight: RebalanceCommand_ManualMarketCapWeight }
    | { $case: "trade"; trade: RebalanceCommand_Trade }
    | undefined;
}

/** Equal Market Cap Weight Strategy */
export interface RebalanceCommand_EqualMarketCapWeight {
}

/** Manual Market Cap Weight Strategy */
export interface RebalanceCommand_ManualMarketCapWeight {
  /** sum of weights should be 1 */
  requests: RebalanceCommand_ManualMarketCapWeight_Request[];
}

export interface RebalanceCommand_ManualMarketCapWeight_Request {
  fungibleToken: string;
  /** Weigh limits: 0 - 1.0 */
  weight: number;
}

/** Trade Strategy */
export interface RebalanceCommand_Trade {
  requests: RebalanceCommand_Trade_Request[];
}

export interface RebalanceCommand_Trade_Request {
  fungibleToken: string;
  isBuy: boolean;
  formattedAmount: string;
}

export interface RebalanceBasketTokenRequest {
  basketToken: string;
  /** if false, it will perform a dry run. */
  execute: boolean;
  command: RebalanceCommand | undefined;
  executionOption: ExecutionOption | undefined;
}

export interface RebalanceBasketTokenResponse {
  resultHtml: string;
}

export interface ExecutionOption {
  sellRatioPerIteration: number;
  slippage: number;
  /** Exit condition */
  maxIterationCount: number;
  exitRemainingExecutionValue: number;
  exitRemainingExecutionValueRatio: number;
}

function createBaseRebalanceCommand(): RebalanceCommand {
  return { strategy: undefined };
}

export const RebalanceCommand = {
  encode(message: RebalanceCommand, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.strategy?.$case) {
      case "equalWeight":
        RebalanceCommand_EqualMarketCapWeight.encode(message.strategy.equalWeight, writer.uint32(10).fork()).ldelim();
        break;
      case "manualWeight":
        RebalanceCommand_ManualMarketCapWeight.encode(message.strategy.manualWeight, writer.uint32(18).fork()).ldelim();
        break;
      case "trade":
        RebalanceCommand_Trade.encode(message.strategy.trade, writer.uint32(26).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebalanceCommand {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.strategy = {
            $case: "equalWeight",
            equalWeight: RebalanceCommand_EqualMarketCapWeight.decode(reader, reader.uint32()),
          };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.strategy = {
            $case: "manualWeight",
            manualWeight: RebalanceCommand_ManualMarketCapWeight.decode(reader, reader.uint32()),
          };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.strategy = { $case: "trade", trade: RebalanceCommand_Trade.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebalanceCommand {
    return {
      strategy: isSet(object.equalWeight)
        ? { $case: "equalWeight", equalWeight: RebalanceCommand_EqualMarketCapWeight.fromJSON(object.equalWeight) }
        : isSet(object.manualWeight)
        ? { $case: "manualWeight", manualWeight: RebalanceCommand_ManualMarketCapWeight.fromJSON(object.manualWeight) }
        : isSet(object.trade)
        ? { $case: "trade", trade: RebalanceCommand_Trade.fromJSON(object.trade) }
        : undefined,
    };
  },

  toJSON(message: RebalanceCommand): unknown {
    const obj: any = {};
    if (message.strategy?.$case === "equalWeight") {
      obj.equalWeight = RebalanceCommand_EqualMarketCapWeight.toJSON(message.strategy.equalWeight);
    }
    if (message.strategy?.$case === "manualWeight") {
      obj.manualWeight = RebalanceCommand_ManualMarketCapWeight.toJSON(message.strategy.manualWeight);
    }
    if (message.strategy?.$case === "trade") {
      obj.trade = RebalanceCommand_Trade.toJSON(message.strategy.trade);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceCommand>, I>>(base?: I): RebalanceCommand {
    return RebalanceCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceCommand>, I>>(object: I): RebalanceCommand {
    const message = createBaseRebalanceCommand();
    if (
      object.strategy?.$case === "equalWeight" &&
      object.strategy?.equalWeight !== undefined &&
      object.strategy?.equalWeight !== null
    ) {
      message.strategy = {
        $case: "equalWeight",
        equalWeight: RebalanceCommand_EqualMarketCapWeight.fromPartial(object.strategy.equalWeight),
      };
    }
    if (
      object.strategy?.$case === "manualWeight" &&
      object.strategy?.manualWeight !== undefined &&
      object.strategy?.manualWeight !== null
    ) {
      message.strategy = {
        $case: "manualWeight",
        manualWeight: RebalanceCommand_ManualMarketCapWeight.fromPartial(object.strategy.manualWeight),
      };
    }
    if (object.strategy?.$case === "trade" && object.strategy?.trade !== undefined && object.strategy?.trade !== null) {
      message.strategy = { $case: "trade", trade: RebalanceCommand_Trade.fromPartial(object.strategy.trade) };
    }
    return message;
  },
};

function createBaseRebalanceCommand_EqualMarketCapWeight(): RebalanceCommand_EqualMarketCapWeight {
  return {};
}

export const RebalanceCommand_EqualMarketCapWeight = {
  encode(_: RebalanceCommand_EqualMarketCapWeight, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebalanceCommand_EqualMarketCapWeight {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceCommand_EqualMarketCapWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RebalanceCommand_EqualMarketCapWeight {
    return {};
  },

  toJSON(_: RebalanceCommand_EqualMarketCapWeight): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceCommand_EqualMarketCapWeight>, I>>(
    base?: I,
  ): RebalanceCommand_EqualMarketCapWeight {
    return RebalanceCommand_EqualMarketCapWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceCommand_EqualMarketCapWeight>, I>>(
    _: I,
  ): RebalanceCommand_EqualMarketCapWeight {
    const message = createBaseRebalanceCommand_EqualMarketCapWeight();
    return message;
  },
};

function createBaseRebalanceCommand_ManualMarketCapWeight(): RebalanceCommand_ManualMarketCapWeight {
  return { requests: [] };
}

export const RebalanceCommand_ManualMarketCapWeight = {
  encode(message: RebalanceCommand_ManualMarketCapWeight, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.requests) {
      RebalanceCommand_ManualMarketCapWeight_Request.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebalanceCommand_ManualMarketCapWeight {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceCommand_ManualMarketCapWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requests.push(RebalanceCommand_ManualMarketCapWeight_Request.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebalanceCommand_ManualMarketCapWeight {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => RebalanceCommand_ManualMarketCapWeight_Request.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RebalanceCommand_ManualMarketCapWeight): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => RebalanceCommand_ManualMarketCapWeight_Request.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceCommand_ManualMarketCapWeight>, I>>(
    base?: I,
  ): RebalanceCommand_ManualMarketCapWeight {
    return RebalanceCommand_ManualMarketCapWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceCommand_ManualMarketCapWeight>, I>>(
    object: I,
  ): RebalanceCommand_ManualMarketCapWeight {
    const message = createBaseRebalanceCommand_ManualMarketCapWeight();
    message.requests = object.requests?.map((e) => RebalanceCommand_ManualMarketCapWeight_Request.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRebalanceCommand_ManualMarketCapWeight_Request(): RebalanceCommand_ManualMarketCapWeight_Request {
  return { fungibleToken: "", weight: 0 };
}

export const RebalanceCommand_ManualMarketCapWeight_Request = {
  encode(
    message: RebalanceCommand_ManualMarketCapWeight_Request,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fungibleToken !== "") {
      writer.uint32(10).string(message.fungibleToken);
    }
    if (message.weight !== 0) {
      writer.uint32(17).double(message.weight);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebalanceCommand_ManualMarketCapWeight_Request {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceCommand_ManualMarketCapWeight_Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fungibleToken = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.weight = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebalanceCommand_ManualMarketCapWeight_Request {
    return {
      fungibleToken: isSet(object.fungibleToken) ? globalThis.String(object.fungibleToken) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: RebalanceCommand_ManualMarketCapWeight_Request): unknown {
    const obj: any = {};
    if (message.fungibleToken !== undefined) {
      obj.fungibleToken = message.fungibleToken;
    }
    if (message.weight !== undefined) {
      obj.weight = message.weight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceCommand_ManualMarketCapWeight_Request>, I>>(
    base?: I,
  ): RebalanceCommand_ManualMarketCapWeight_Request {
    return RebalanceCommand_ManualMarketCapWeight_Request.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceCommand_ManualMarketCapWeight_Request>, I>>(
    object: I,
  ): RebalanceCommand_ManualMarketCapWeight_Request {
    const message = createBaseRebalanceCommand_ManualMarketCapWeight_Request();
    message.fungibleToken = object.fungibleToken ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseRebalanceCommand_Trade(): RebalanceCommand_Trade {
  return { requests: [] };
}

export const RebalanceCommand_Trade = {
  encode(message: RebalanceCommand_Trade, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.requests) {
      RebalanceCommand_Trade_Request.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebalanceCommand_Trade {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceCommand_Trade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requests.push(RebalanceCommand_Trade_Request.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebalanceCommand_Trade {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => RebalanceCommand_Trade_Request.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RebalanceCommand_Trade): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => RebalanceCommand_Trade_Request.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceCommand_Trade>, I>>(base?: I): RebalanceCommand_Trade {
    return RebalanceCommand_Trade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceCommand_Trade>, I>>(object: I): RebalanceCommand_Trade {
    const message = createBaseRebalanceCommand_Trade();
    message.requests = object.requests?.map((e) => RebalanceCommand_Trade_Request.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRebalanceCommand_Trade_Request(): RebalanceCommand_Trade_Request {
  return { fungibleToken: "", isBuy: false, formattedAmount: "" };
}

export const RebalanceCommand_Trade_Request = {
  encode(message: RebalanceCommand_Trade_Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fungibleToken !== "") {
      writer.uint32(10).string(message.fungibleToken);
    }
    if (message.isBuy !== false) {
      writer.uint32(16).bool(message.isBuy);
    }
    if (message.formattedAmount !== "") {
      writer.uint32(26).string(message.formattedAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebalanceCommand_Trade_Request {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceCommand_Trade_Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fungibleToken = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isBuy = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.formattedAmount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebalanceCommand_Trade_Request {
    return {
      fungibleToken: isSet(object.fungibleToken) ? globalThis.String(object.fungibleToken) : "",
      isBuy: isSet(object.isBuy) ? globalThis.Boolean(object.isBuy) : false,
      formattedAmount: isSet(object.formattedAmount) ? globalThis.String(object.formattedAmount) : "",
    };
  },

  toJSON(message: RebalanceCommand_Trade_Request): unknown {
    const obj: any = {};
    if (message.fungibleToken !== undefined) {
      obj.fungibleToken = message.fungibleToken;
    }
    if (message.isBuy !== undefined) {
      obj.isBuy = message.isBuy;
    }
    if (message.formattedAmount !== undefined) {
      obj.formattedAmount = message.formattedAmount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceCommand_Trade_Request>, I>>(base?: I): RebalanceCommand_Trade_Request {
    return RebalanceCommand_Trade_Request.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceCommand_Trade_Request>, I>>(
    object: I,
  ): RebalanceCommand_Trade_Request {
    const message = createBaseRebalanceCommand_Trade_Request();
    message.fungibleToken = object.fungibleToken ?? "";
    message.isBuy = object.isBuy ?? false;
    message.formattedAmount = object.formattedAmount ?? "";
    return message;
  },
};

function createBaseRebalanceBasketTokenRequest(): RebalanceBasketTokenRequest {
  return { basketToken: "", execute: false, command: undefined, executionOption: undefined };
}

export const RebalanceBasketTokenRequest = {
  encode(message: RebalanceBasketTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketToken !== "") {
      writer.uint32(10).string(message.basketToken);
    }
    if (message.execute !== false) {
      writer.uint32(16).bool(message.execute);
    }
    if (message.command !== undefined) {
      RebalanceCommand.encode(message.command, writer.uint32(26).fork()).ldelim();
    }
    if (message.executionOption !== undefined) {
      ExecutionOption.encode(message.executionOption, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebalanceBasketTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceBasketTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketToken = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.execute = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.command = RebalanceCommand.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.executionOption = ExecutionOption.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebalanceBasketTokenRequest {
    return {
      basketToken: isSet(object.basketToken) ? globalThis.String(object.basketToken) : "",
      execute: isSet(object.execute) ? globalThis.Boolean(object.execute) : false,
      command: isSet(object.command) ? RebalanceCommand.fromJSON(object.command) : undefined,
      executionOption: isSet(object.executionOption) ? ExecutionOption.fromJSON(object.executionOption) : undefined,
    };
  },

  toJSON(message: RebalanceBasketTokenRequest): unknown {
    const obj: any = {};
    if (message.basketToken !== undefined) {
      obj.basketToken = message.basketToken;
    }
    if (message.execute !== undefined) {
      obj.execute = message.execute;
    }
    if (message.command !== undefined) {
      obj.command = RebalanceCommand.toJSON(message.command);
    }
    if (message.executionOption !== undefined) {
      obj.executionOption = ExecutionOption.toJSON(message.executionOption);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceBasketTokenRequest>, I>>(base?: I): RebalanceBasketTokenRequest {
    return RebalanceBasketTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceBasketTokenRequest>, I>>(object: I): RebalanceBasketTokenRequest {
    const message = createBaseRebalanceBasketTokenRequest();
    message.basketToken = object.basketToken ?? "";
    message.execute = object.execute ?? false;
    message.command = (object.command !== undefined && object.command !== null)
      ? RebalanceCommand.fromPartial(object.command)
      : undefined;
    message.executionOption = (object.executionOption !== undefined && object.executionOption !== null)
      ? ExecutionOption.fromPartial(object.executionOption)
      : undefined;
    return message;
  },
};

function createBaseRebalanceBasketTokenResponse(): RebalanceBasketTokenResponse {
  return { resultHtml: "" };
}

export const RebalanceBasketTokenResponse = {
  encode(message: RebalanceBasketTokenResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resultHtml !== "") {
      writer.uint32(10).string(message.resultHtml);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebalanceBasketTokenResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceBasketTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resultHtml = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebalanceBasketTokenResponse {
    return { resultHtml: isSet(object.resultHtml) ? globalThis.String(object.resultHtml) : "" };
  },

  toJSON(message: RebalanceBasketTokenResponse): unknown {
    const obj: any = {};
    if (message.resultHtml !== undefined) {
      obj.resultHtml = message.resultHtml;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceBasketTokenResponse>, I>>(base?: I): RebalanceBasketTokenResponse {
    return RebalanceBasketTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceBasketTokenResponse>, I>>(object: I): RebalanceBasketTokenResponse {
    const message = createBaseRebalanceBasketTokenResponse();
    message.resultHtml = object.resultHtml ?? "";
    return message;
  },
};

function createBaseExecutionOption(): ExecutionOption {
  return {
    sellRatioPerIteration: 0,
    slippage: 0,
    maxIterationCount: 0,
    exitRemainingExecutionValue: 0,
    exitRemainingExecutionValueRatio: 0,
  };
}

export const ExecutionOption = {
  encode(message: ExecutionOption, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sellRatioPerIteration !== 0) {
      writer.uint32(9).double(message.sellRatioPerIteration);
    }
    if (message.slippage !== 0) {
      writer.uint32(17).double(message.slippage);
    }
    if (message.maxIterationCount !== 0) {
      writer.uint32(24).int32(message.maxIterationCount);
    }
    if (message.exitRemainingExecutionValue !== 0) {
      writer.uint32(33).double(message.exitRemainingExecutionValue);
    }
    if (message.exitRemainingExecutionValueRatio !== 0) {
      writer.uint32(41).double(message.exitRemainingExecutionValueRatio);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecutionOption {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.sellRatioPerIteration = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.slippage = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxIterationCount = reader.int32();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.exitRemainingExecutionValue = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.exitRemainingExecutionValueRatio = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionOption {
    return {
      sellRatioPerIteration: isSet(object.sellRatioPerIteration) ? globalThis.Number(object.sellRatioPerIteration) : 0,
      slippage: isSet(object.slippage) ? globalThis.Number(object.slippage) : 0,
      maxIterationCount: isSet(object.maxIterationCount) ? globalThis.Number(object.maxIterationCount) : 0,
      exitRemainingExecutionValue: isSet(object.exitRemainingExecutionValue)
        ? globalThis.Number(object.exitRemainingExecutionValue)
        : 0,
      exitRemainingExecutionValueRatio: isSet(object.exitRemainingExecutionValueRatio)
        ? globalThis.Number(object.exitRemainingExecutionValueRatio)
        : 0,
    };
  },

  toJSON(message: ExecutionOption): unknown {
    const obj: any = {};
    if (message.sellRatioPerIteration !== undefined) {
      obj.sellRatioPerIteration = message.sellRatioPerIteration;
    }
    if (message.slippage !== undefined) {
      obj.slippage = message.slippage;
    }
    if (message.maxIterationCount !== undefined) {
      obj.maxIterationCount = Math.round(message.maxIterationCount);
    }
    if (message.exitRemainingExecutionValue !== undefined) {
      obj.exitRemainingExecutionValue = message.exitRemainingExecutionValue;
    }
    if (message.exitRemainingExecutionValueRatio !== undefined) {
      obj.exitRemainingExecutionValueRatio = message.exitRemainingExecutionValueRatio;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionOption>, I>>(base?: I): ExecutionOption {
    return ExecutionOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionOption>, I>>(object: I): ExecutionOption {
    const message = createBaseExecutionOption();
    message.sellRatioPerIteration = object.sellRatioPerIteration ?? 0;
    message.slippage = object.slippage ?? 0;
    message.maxIterationCount = object.maxIterationCount ?? 0;
    message.exitRemainingExecutionValue = object.exitRemainingExecutionValue ?? 0;
    message.exitRemainingExecutionValueRatio = object.exitRemainingExecutionValueRatio ?? 0;
    return message;
  },
};

/** ChainCommandService is the service that handles all chain requests. */
export interface ChainCommandService {
  RebalanceBasketToken(request: RebalanceBasketTokenRequest): Promise<RebalanceBasketTokenResponse>;
}

export const ChainCommandServiceServiceName = "piedotfun.v1.chain.ChainCommandService";
export class ChainCommandServiceClientImpl implements ChainCommandService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ChainCommandServiceServiceName;
    this.rpc = rpc;
    this.RebalanceBasketToken = this.RebalanceBasketToken.bind(this);
  }
  RebalanceBasketToken(request: RebalanceBasketTokenRequest): Promise<RebalanceBasketTokenResponse> {
    const data = RebalanceBasketTokenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RebalanceBasketToken", data);
    return promise.then((data) => RebalanceBasketTokenResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
