// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: ethereum/v1/profile/my_space.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../../google/protobuf/timestamp";

export const protobufPackage = "ethereum.v1.profile";

/** MySpace message represents a profile's MySpace. */
export interface MySpace {
  /** The name of Profile of the MySpace */
  profile: string;
  /** The profile's assets. */
  assets:
    | Assets
    | undefined;
  /** The profile's StarDoodles. */
  starDoodles: StarDoodles | undefined;
}

/** Assets message represents a profile's assets. */
export interface Assets {
  /** The profile's Spaceships assets. */
  spaceships: SpaceshipAsset[];
  /** The profile's Badges assets. */
  badges: BadgeAsset[];
  /** The profile's Scores assets. */
  scores: ScoreAsset[];
  /** The profile's Alphabets assets. */
  alphabets: AlphabetAsset[];
  /** The profile's Blocks assets. */
  blocks: BlockAsset[];
}

/** SpaceshipReference message represents a Spaceship. */
export interface SpaceshipReference {
  /** The resource name of the Spaceship. */
  name: string;
  /** The nickname of the Spaceship. */
  nickname: string;
  /** The token_id of Spaceship NFT. */
  tokenId: string;
  /** The image uri of Spaceship NFT. */
  imageUri: string;
}

/** BadgeReference message represents a Badge. */
export interface BadgeReference {
  /** The resource name of the Badge. */
  name: string;
}

/** ScoreReference message represents a Score. */
export interface ScoreReference {
  /** The resource name of the Score. */
  name: string;
  /** The token_id of Score NFT. */
  tokenId: string;
  /** The image uri of Score NFT. */
  imageUri: string;
}

/** SpaceshipAsset message represents a Spaceship asset. */
export interface SpaceshipAsset {
  /** The ID of the Spaceship asset. */
  id: number;
  /** The URI of the Spaceship asset image. */
  imageUri: string;
  /** The position of the Spaceship asset. */
  position:
    | Position
    | undefined;
  /**
   * The timestamp of the Spaceship asset creation.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  createTime:
    | string
    | undefined;
  /**
   * The timestamp of the Spaceship asset update.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  updateTime:
    | string
    | undefined;
  /** The reference to the Spaceship. */
  reference: SpaceshipReference | undefined;
}

/** BadgeAsset message represents a Badge asset. */
export interface BadgeAsset {
  /** The ID of the Badge asset. */
  id: number;
  /** The URI of the Badge asset image. */
  imageUri: string;
  /** The position of the Badge asset. */
  position:
    | Position
    | undefined;
  /**
   * The timestamp of the Badge asset creation.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  createTime:
    | string
    | undefined;
  /**
   * The timestamp of the Badge asset update.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  updateTime:
    | string
    | undefined;
  /** The reference to the Badge. */
  reference: BadgeReference | undefined;
}

/** ScoreAsset message represents a Score asset. */
export interface ScoreAsset {
  /** The ID of the Score asset. */
  id: number;
  /** The URI of the Score asset image. */
  imageUri: string;
  /** The position of the Score asset. */
  position:
    | Position
    | undefined;
  /**
   * The timestamp of the Score asset creation.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  createTime:
    | string
    | undefined;
  /**
   * The timestamp of the Score asset update.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  updateTime:
    | string
    | undefined;
  /** The reference to the Score. */
  reference: ScoreReference | undefined;
}

/** AlphabetAsset message represents an Alphabet asset. */
export interface AlphabetAsset {
  /** The ID of the Alphabet asset. */
  id: number;
  /** The URI of the Alphabet asset image. */
  imageUri: string;
  /** The position of the Alphabet asset. */
  position:
    | Position
    | undefined;
  /**
   * The timestamp of the Alphabet asset creation.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  createTime:
    | string
    | undefined;
  /**
   * The timestamp of the Alphabet asset update.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  updateTime:
    | string
    | undefined;
  /** The character of the Alphabet asset. */
  character: number;
}

/** BlockAsset message represents a Block asset. */
export interface BlockAsset {
  /** The ID of the Block asset. */
  id: number;
  /** The URI of the Block asset image. */
  imageUri: string;
  /** The position of the Block asset. */
  position:
    | Position
    | undefined;
  /**
   * The timestamp of the Alphabet block creation.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  createTime:
    | string
    | undefined;
  /**
   * The timestamp of the Alphabet block update.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  updateTime: string | undefined;
}

/** StarDoodles message represents a profile's StarDoodles. */
export interface StarDoodles {
  /** The URI of the StarDoodles image. */
  imageUri: string;
  /** The positions of the StarDoodles. */
  positions: Position[];
}

/** Position message represents a position. */
export interface Position {
  /** The left position. */
  left: number;
  /** The top position. */
  top: number;
  /** The right position. */
  right: number;
  /** The bottom position. */
  bottom: number;
}

function createBaseMySpace(): MySpace {
  return { profile: "", assets: undefined, starDoodles: undefined };
}

export const MySpace = {
  encode(message: MySpace, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.profile !== "") {
      writer.uint32(10).string(message.profile);
    }
    if (message.assets !== undefined) {
      Assets.encode(message.assets, writer.uint32(18).fork()).ldelim();
    }
    if (message.starDoodles !== undefined) {
      StarDoodles.encode(message.starDoodles, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MySpace {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMySpace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.profile = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assets = Assets.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.starDoodles = StarDoodles.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MySpace {
    return {
      profile: isSet(object.profile) ? globalThis.String(object.profile) : "",
      assets: isSet(object.assets) ? Assets.fromJSON(object.assets) : undefined,
      starDoodles: isSet(object.starDoodles) ? StarDoodles.fromJSON(object.starDoodles) : undefined,
    };
  },

  toJSON(message: MySpace): unknown {
    const obj: any = {};
    if (message.profile !== undefined) {
      obj.profile = message.profile;
    }
    if (message.assets !== undefined) {
      obj.assets = Assets.toJSON(message.assets);
    }
    if (message.starDoodles !== undefined) {
      obj.starDoodles = StarDoodles.toJSON(message.starDoodles);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MySpace>, I>>(base?: I): MySpace {
    return MySpace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MySpace>, I>>(object: I): MySpace {
    const message = createBaseMySpace();
    message.profile = object.profile ?? "";
    message.assets = (object.assets !== undefined && object.assets !== null)
      ? Assets.fromPartial(object.assets)
      : undefined;
    message.starDoodles = (object.starDoodles !== undefined && object.starDoodles !== null)
      ? StarDoodles.fromPartial(object.starDoodles)
      : undefined;
    return message;
  },
};

function createBaseAssets(): Assets {
  return { spaceships: [], badges: [], scores: [], alphabets: [], blocks: [] };
}

export const Assets = {
  encode(message: Assets, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.spaceships) {
      SpaceshipAsset.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.badges) {
      BadgeAsset.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.scores) {
      ScoreAsset.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.alphabets) {
      AlphabetAsset.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.blocks) {
      BlockAsset.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Assets {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.spaceships.push(SpaceshipAsset.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.badges.push(BadgeAsset.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.scores.push(ScoreAsset.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.alphabets.push(AlphabetAsset.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blocks.push(BlockAsset.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Assets {
    return {
      spaceships: globalThis.Array.isArray(object?.spaceships)
        ? object.spaceships.map((e: any) => SpaceshipAsset.fromJSON(e))
        : [],
      badges: globalThis.Array.isArray(object?.badges) ? object.badges.map((e: any) => BadgeAsset.fromJSON(e)) : [],
      scores: globalThis.Array.isArray(object?.scores) ? object.scores.map((e: any) => ScoreAsset.fromJSON(e)) : [],
      alphabets: globalThis.Array.isArray(object?.alphabets)
        ? object.alphabets.map((e: any) => AlphabetAsset.fromJSON(e))
        : [],
      blocks: globalThis.Array.isArray(object?.blocks) ? object.blocks.map((e: any) => BlockAsset.fromJSON(e)) : [],
    };
  },

  toJSON(message: Assets): unknown {
    const obj: any = {};
    if (message.spaceships?.length) {
      obj.spaceships = message.spaceships.map((e) => SpaceshipAsset.toJSON(e));
    }
    if (message.badges?.length) {
      obj.badges = message.badges.map((e) => BadgeAsset.toJSON(e));
    }
    if (message.scores?.length) {
      obj.scores = message.scores.map((e) => ScoreAsset.toJSON(e));
    }
    if (message.alphabets?.length) {
      obj.alphabets = message.alphabets.map((e) => AlphabetAsset.toJSON(e));
    }
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => BlockAsset.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Assets>, I>>(base?: I): Assets {
    return Assets.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Assets>, I>>(object: I): Assets {
    const message = createBaseAssets();
    message.spaceships = object.spaceships?.map((e) => SpaceshipAsset.fromPartial(e)) || [];
    message.badges = object.badges?.map((e) => BadgeAsset.fromPartial(e)) || [];
    message.scores = object.scores?.map((e) => ScoreAsset.fromPartial(e)) || [];
    message.alphabets = object.alphabets?.map((e) => AlphabetAsset.fromPartial(e)) || [];
    message.blocks = object.blocks?.map((e) => BlockAsset.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpaceshipReference(): SpaceshipReference {
  return { name: "", nickname: "", tokenId: "", imageUri: "" };
}

export const SpaceshipReference = {
  encode(message: SpaceshipReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.nickname !== "") {
      writer.uint32(18).string(message.nickname);
    }
    if (message.tokenId !== "") {
      writer.uint32(26).string(message.tokenId);
    }
    if (message.imageUri !== "") {
      writer.uint32(34).string(message.imageUri);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpaceshipReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpaceshipReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nickname = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.imageUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpaceshipReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
    };
  },

  toJSON(message: SpaceshipReference): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.nickname !== undefined) {
      obj.nickname = message.nickname;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpaceshipReference>, I>>(base?: I): SpaceshipReference {
    return SpaceshipReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpaceshipReference>, I>>(object: I): SpaceshipReference {
    const message = createBaseSpaceshipReference();
    message.name = object.name ?? "";
    message.nickname = object.nickname ?? "";
    message.tokenId = object.tokenId ?? "";
    message.imageUri = object.imageUri ?? "";
    return message;
  },
};

function createBaseBadgeReference(): BadgeReference {
  return { name: "" };
}

export const BadgeReference = {
  encode(message: BadgeReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BadgeReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BadgeReference {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: BadgeReference): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BadgeReference>, I>>(base?: I): BadgeReference {
    return BadgeReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeReference>, I>>(object: I): BadgeReference {
    const message = createBaseBadgeReference();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseScoreReference(): ScoreReference {
  return { name: "", tokenId: "", imageUri: "" };
}

export const ScoreReference = {
  encode(message: ScoreReference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    if (message.imageUri !== "") {
      writer.uint32(26).string(message.imageUri);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScoreReference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScoreReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.imageUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScoreReference {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
    };
  },

  toJSON(message: ScoreReference): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScoreReference>, I>>(base?: I): ScoreReference {
    return ScoreReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScoreReference>, I>>(object: I): ScoreReference {
    const message = createBaseScoreReference();
    message.name = object.name ?? "";
    message.tokenId = object.tokenId ?? "";
    message.imageUri = object.imageUri ?? "";
    return message;
  },
};

function createBaseSpaceshipAsset(): SpaceshipAsset {
  return {
    id: 0,
    imageUri: "",
    position: undefined,
    createTime: undefined,
    updateTime: undefined,
    reference: undefined,
  };
}

export const SpaceshipAsset = {
  encode(message: SpaceshipAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.imageUri !== "") {
      writer.uint32(18).string(message.imageUri);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(26).fork()).ldelim();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).ldelim();
    }
    if (message.reference !== undefined) {
      SpaceshipReference.encode(message.reference, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpaceshipAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpaceshipAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.reference = SpaceshipReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpaceshipAsset {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? globalThis.String(object.updateTime) : undefined,
      reference: isSet(object.reference) ? SpaceshipReference.fromJSON(object.reference) : undefined,
    };
  },

  toJSON(message: SpaceshipAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime;
    }
    if (message.reference !== undefined) {
      obj.reference = SpaceshipReference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpaceshipAsset>, I>>(base?: I): SpaceshipAsset {
    return SpaceshipAsset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpaceshipAsset>, I>>(object: I): SpaceshipAsset {
    const message = createBaseSpaceshipAsset();
    message.id = object.id ?? 0;
    message.imageUri = object.imageUri ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.reference = (object.reference !== undefined && object.reference !== null)
      ? SpaceshipReference.fromPartial(object.reference)
      : undefined;
    return message;
  },
};

function createBaseBadgeAsset(): BadgeAsset {
  return {
    id: 0,
    imageUri: "",
    position: undefined,
    createTime: undefined,
    updateTime: undefined,
    reference: undefined,
  };
}

export const BadgeAsset = {
  encode(message: BadgeAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.imageUri !== "") {
      writer.uint32(18).string(message.imageUri);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(26).fork()).ldelim();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).ldelim();
    }
    if (message.reference !== undefined) {
      BadgeReference.encode(message.reference, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BadgeAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadgeAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.reference = BadgeReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BadgeAsset {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? globalThis.String(object.updateTime) : undefined,
      reference: isSet(object.reference) ? BadgeReference.fromJSON(object.reference) : undefined,
    };
  },

  toJSON(message: BadgeAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime;
    }
    if (message.reference !== undefined) {
      obj.reference = BadgeReference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BadgeAsset>, I>>(base?: I): BadgeAsset {
    return BadgeAsset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadgeAsset>, I>>(object: I): BadgeAsset {
    const message = createBaseBadgeAsset();
    message.id = object.id ?? 0;
    message.imageUri = object.imageUri ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.reference = (object.reference !== undefined && object.reference !== null)
      ? BadgeReference.fromPartial(object.reference)
      : undefined;
    return message;
  },
};

function createBaseScoreAsset(): ScoreAsset {
  return {
    id: 0,
    imageUri: "",
    position: undefined,
    createTime: undefined,
    updateTime: undefined,
    reference: undefined,
  };
}

export const ScoreAsset = {
  encode(message: ScoreAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.imageUri !== "") {
      writer.uint32(18).string(message.imageUri);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(26).fork()).ldelim();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).ldelim();
    }
    if (message.reference !== undefined) {
      ScoreReference.encode(message.reference, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScoreAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScoreAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.reference = ScoreReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScoreAsset {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? globalThis.String(object.updateTime) : undefined,
      reference: isSet(object.reference) ? ScoreReference.fromJSON(object.reference) : undefined,
    };
  },

  toJSON(message: ScoreAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime;
    }
    if (message.reference !== undefined) {
      obj.reference = ScoreReference.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScoreAsset>, I>>(base?: I): ScoreAsset {
    return ScoreAsset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScoreAsset>, I>>(object: I): ScoreAsset {
    const message = createBaseScoreAsset();
    message.id = object.id ?? 0;
    message.imageUri = object.imageUri ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.reference = (object.reference !== undefined && object.reference !== null)
      ? ScoreReference.fromPartial(object.reference)
      : undefined;
    return message;
  },
};

function createBaseAlphabetAsset(): AlphabetAsset {
  return { id: 0, imageUri: "", position: undefined, createTime: undefined, updateTime: undefined, character: 0 };
}

export const AlphabetAsset = {
  encode(message: AlphabetAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.imageUri !== "") {
      writer.uint32(18).string(message.imageUri);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(26).fork()).ldelim();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).ldelim();
    }
    if (message.character !== 0) {
      writer.uint32(48).uint32(message.character);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AlphabetAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlphabetAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.character = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlphabetAsset {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? globalThis.String(object.updateTime) : undefined,
      character: isSet(object.character) ? globalThis.Number(object.character) : 0,
    };
  },

  toJSON(message: AlphabetAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime;
    }
    if (message.character !== undefined) {
      obj.character = Math.round(message.character);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlphabetAsset>, I>>(base?: I): AlphabetAsset {
    return AlphabetAsset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlphabetAsset>, I>>(object: I): AlphabetAsset {
    const message = createBaseAlphabetAsset();
    message.id = object.id ?? 0;
    message.imageUri = object.imageUri ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.character = object.character ?? 0;
    return message;
  },
};

function createBaseBlockAsset(): BlockAsset {
  return { id: 0, imageUri: "", position: undefined, createTime: undefined, updateTime: undefined };
}

export const BlockAsset = {
  encode(message: BlockAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.imageUri !== "") {
      writer.uint32(18).string(message.imageUri);
    }
    if (message.position !== undefined) {
      Position.encode(message.position, writer.uint32(26).fork()).ldelim();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.position = Position.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockAsset {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      position: isSet(object.position) ? Position.fromJSON(object.position) : undefined,
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? globalThis.String(object.updateTime) : undefined,
    };
  },

  toJSON(message: BlockAsset): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    if (message.position !== undefined) {
      obj.position = Position.toJSON(message.position);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockAsset>, I>>(base?: I): BlockAsset {
    return BlockAsset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockAsset>, I>>(object: I): BlockAsset {
    const message = createBaseBlockAsset();
    message.id = object.id ?? 0;
    message.imageUri = object.imageUri ?? "";
    message.position = (object.position !== undefined && object.position !== null)
      ? Position.fromPartial(object.position)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseStarDoodles(): StarDoodles {
  return { imageUri: "", positions: [] };
}

export const StarDoodles = {
  encode(message: StarDoodles, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.imageUri !== "") {
      writer.uint32(10).string(message.imageUri);
    }
    for (const v of message.positions) {
      Position.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StarDoodles {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStarDoodles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.positions.push(Position.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StarDoodles {
    return {
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      positions: globalThis.Array.isArray(object?.positions)
        ? object.positions.map((e: any) => Position.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StarDoodles): unknown {
    const obj: any = {};
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    if (message.positions?.length) {
      obj.positions = message.positions.map((e) => Position.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StarDoodles>, I>>(base?: I): StarDoodles {
    return StarDoodles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StarDoodles>, I>>(object: I): StarDoodles {
    const message = createBaseStarDoodles();
    message.imageUri = object.imageUri ?? "";
    message.positions = object.positions?.map((e) => Position.fromPartial(e)) || [];
    return message;
  },
};

function createBasePosition(): Position {
  return { left: 0, top: 0, right: 0, bottom: 0 };
}

export const Position = {
  encode(message: Position, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.left !== 0) {
      writer.uint32(8).int32(message.left);
    }
    if (message.top !== 0) {
      writer.uint32(16).int32(message.top);
    }
    if (message.right !== 0) {
      writer.uint32(24).int32(message.right);
    }
    if (message.bottom !== 0) {
      writer.uint32(32).int32(message.bottom);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Position {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.left = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.top = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.right = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bottom = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Position {
    return {
      left: isSet(object.left) ? globalThis.Number(object.left) : 0,
      top: isSet(object.top) ? globalThis.Number(object.top) : 0,
      right: isSet(object.right) ? globalThis.Number(object.right) : 0,
      bottom: isSet(object.bottom) ? globalThis.Number(object.bottom) : 0,
    };
  },

  toJSON(message: Position): unknown {
    const obj: any = {};
    if (message.left !== undefined) {
      obj.left = Math.round(message.left);
    }
    if (message.top !== undefined) {
      obj.top = Math.round(message.top);
    }
    if (message.right !== undefined) {
      obj.right = Math.round(message.right);
    }
    if (message.bottom !== undefined) {
      obj.bottom = Math.round(message.bottom);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Position>, I>>(base?: I): Position {
    return Position.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Position>, I>>(object: I): Position {
    const message = createBasePosition();
    message.left = object.left ?? 0;
    message.top = object.top ?? 0;
    message.right = object.right ?? 0;
    message.bottom = object.bottom ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
