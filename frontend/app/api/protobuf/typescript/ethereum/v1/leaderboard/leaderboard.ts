// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: ethereum/v1/leaderboard/leaderboard.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Profile } from "../profile/profile";
import {
  GameMode,
  gameModeFromJSON,
  gameModeToJSON,
  gameModeToNumber,
  PlayMode,
  playModeFromJSON,
  playModeToJSON,
  playModeToNumber,
  Score,
} from "../score/score";

export const protobufPackage = "ethereum.v1.leaderboard";

export interface GetTopRankerLeaderboardRequest {
  /**
   * The maximum number of scores to return. The service may return fewer than
   * this value.
   * If unspecified, at most 5 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `GetLeaderbaord` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding season of leaderboard.
   * The default value is 1
   */
  season: number;
  /**
   * The corresponding play_mode of leaderboard.
   * The default value is "TIME_ATTACK"
   */
  playMode: PlayMode;
  /**
   * The corresponding game_mode of leaderboard.
   * The default value is "SINGLE_PLAYER"
   */
  gameMode: GameMode;
}

export interface GetTopRankerLeaderboardResponse {
  topRankers: TopRanker[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
  deadline: string | undefined;
}

export interface GetTopRankerRequest {
  profileAddress: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding play_mode of leaderboard.
   * The default value is "TIME_ATTACK"
   */
  playMode: PlayMode;
  /**
   * The corresponding game_mode of leaderboard.
   * The default value is "SINGLE_PLAYER"
   */
  gameMode: GameMode;
}

export interface RenderTopRankerLeaderboardRequest {
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding season of leaderboard.
   * The default value is 1
   */
  season: number;
  /**
   * The corresponding play_mode of leaderboard.
   * The default value is "TIME_ATTACK"
   */
  playMode: PlayMode;
  /**
   * The corresponding game_mode of leaderboard.
   * The default value is "SINGLE_PLAYER"
   */
  gameMode: GameMode;
  me: string;
}

/**
 * GetWeeklyTopCollectorLeaderboardRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface GetWeeklyTopCollectorLeaderboardRequest {
  /**
   * The maximum number of scores to return. The service may return fewer than
   * this value.
   * If unspecified, at most 5 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListWeeklytimeTopCollectors` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding season of leaderboard.
   * The default value is 1
   */
  season: number;
}

export interface GetWeeklyTopCollectorLeaderboardResponse {
  topCollectors: StarHunter[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
  deadline: string | undefined;
}

export interface GetWeeklyTopCollectorRequest {
  profileAddress: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
}

/**
 * GetAllTimeTopCollectorsLeaderboardRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface GetAllTimeTopCollectorLeaderboardRequest {
  /**
   * The maximum number of scores to return. The service may return fewer than
   * this value.
   * If unspecified, at most 5 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `GetAllTimeTopCollectorLeaderboard` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface GetAllTimeTopCollectorLeaderboardResponse {
  topCollectors: StarHunter[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface RenderWeeklyStarHunterLeaderboardRequest {
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding season of leaderboard.
   * The default value is 1
   */
  season: number;
  me: string;
}

/**
 * GetWeeklyStarHunterLeaderboardRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface GetWeeklyStarHunterLeaderboardRequest {
  /**
   * The maximum number of scores to return. The service may return fewer than
   * this value.
   * If unspecified, at most 5 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListWeeklytimeTopCollectors` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
  /**
   * The corresponding season of leaderboard.
   * The default value is 1
   */
  season: number;
}

export interface GetWeeklyStarHunterLeaderboardResponse {
  starHunters: StarHunter[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
  deadline: string | undefined;
}

export interface GetWeeklyStarHunterRequest {
  profileAddress: string;
  /**
   * The corresponding week of leaderboard.
   * If unspecified, the current week will be used.
   */
  week: number;
}

/**
 * GetAllTimeStarHuntersLeaderboardRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 */
export interface GetAllTimeStarHunterLeaderboardRequest {
  /**
   * The maximum number of scores to return. The service may return fewer than
   * this value.
   * If unspecified, at most 5 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `GetAllTimeStarHunterLeaderboard` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface GetAllTimeStarHunterLeaderboardResponse {
  starHunters: StarHunter[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface ImageResponse {
  image: Uint8Array;
}

export interface TopRanker {
  rank: number;
  profile: Profile | undefined;
  score: Score | undefined;
}

export interface StarHunter {
  rank: number;
  profile: Profile | undefined;
  totalStars: number;
}

export interface RenderStarHuntersLeaderboardImageRequest {
  starHunters: StarHunterSlim[];
  me: StarHunterSlim | undefined;
}

export interface RenderTopRankerLeaderboardImageRequest {
  topRankers: TopRankerSlim[];
  me: TopRankerSlim | undefined;
}

export interface StarHunterSlim {
  rank: number;
  profile: string;
  totalStars: number;
}

export interface TopRankerSlim {
  rank: number;
  profile: string;
  scorePoint: number;
}

function createBaseGetTopRankerLeaderboardRequest(): GetTopRankerLeaderboardRequest {
  return {
    pageSize: 0,
    pageToken: "",
    week: 0,
    season: 0,
    playMode: PlayMode.PLAY_MODE_UNSPECIFIED,
    gameMode: GameMode.GAME_MODE_UNSPECIFIED,
  };
}

export const GetTopRankerLeaderboardRequest = {
  encode(message: GetTopRankerLeaderboardRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.week !== 0) {
      writer.uint32(24).uint32(message.week);
    }
    if (message.season !== 0) {
      writer.uint32(32).uint32(message.season);
    }
    if (message.playMode !== PlayMode.PLAY_MODE_UNSPECIFIED) {
      writer.uint32(40).int32(playModeToNumber(message.playMode));
    }
    if (message.gameMode !== GameMode.GAME_MODE_UNSPECIFIED) {
      writer.uint32(48).int32(gameModeToNumber(message.gameMode));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTopRankerLeaderboardRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopRankerLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.week = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.season = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.playMode = playModeFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.gameMode = gameModeFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopRankerLeaderboardRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
      playMode: isSet(object.playMode) ? playModeFromJSON(object.playMode) : PlayMode.PLAY_MODE_UNSPECIFIED,
      gameMode: isSet(object.gameMode) ? gameModeFromJSON(object.gameMode) : GameMode.GAME_MODE_UNSPECIFIED,
    };
  },

  toJSON(message: GetTopRankerLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    if (message.playMode !== undefined) {
      obj.playMode = playModeToJSON(message.playMode);
    }
    if (message.gameMode !== undefined) {
      obj.gameMode = gameModeToJSON(message.gameMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTopRankerLeaderboardRequest>, I>>(base?: I): GetTopRankerLeaderboardRequest {
    return GetTopRankerLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTopRankerLeaderboardRequest>, I>>(
    object: I,
  ): GetTopRankerLeaderboardRequest {
    const message = createBaseGetTopRankerLeaderboardRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.week = object.week ?? 0;
    message.season = object.season ?? 0;
    message.playMode = object.playMode ?? PlayMode.PLAY_MODE_UNSPECIFIED;
    message.gameMode = object.gameMode ?? GameMode.GAME_MODE_UNSPECIFIED;
    return message;
  },
};

function createBaseGetTopRankerLeaderboardResponse(): GetTopRankerLeaderboardResponse {
  return { topRankers: [], nextPageToken: "", deadline: undefined };
}

export const GetTopRankerLeaderboardResponse = {
  encode(message: GetTopRankerLeaderboardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.topRankers) {
      TopRanker.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.deadline !== undefined) {
      Timestamp.encode(toTimestamp(message.deadline), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTopRankerLeaderboardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopRankerLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topRankers.push(TopRanker.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopRankerLeaderboardResponse {
    return {
      topRankers: globalThis.Array.isArray(object?.topRankers)
        ? object.topRankers.map((e: any) => TopRanker.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      deadline: isSet(object.deadline) ? globalThis.String(object.deadline) : undefined,
    };
  },

  toJSON(message: GetTopRankerLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.topRankers?.length) {
      obj.topRankers = message.topRankers.map((e) => TopRanker.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.deadline !== undefined) {
      obj.deadline = message.deadline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTopRankerLeaderboardResponse>, I>>(base?: I): GetTopRankerLeaderboardResponse {
    return GetTopRankerLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTopRankerLeaderboardResponse>, I>>(
    object: I,
  ): GetTopRankerLeaderboardResponse {
    const message = createBaseGetTopRankerLeaderboardResponse();
    message.topRankers = object.topRankers?.map((e) => TopRanker.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.deadline = object.deadline ?? undefined;
    return message;
  },
};

function createBaseGetTopRankerRequest(): GetTopRankerRequest {
  return {
    profileAddress: "",
    week: 0,
    playMode: PlayMode.PLAY_MODE_UNSPECIFIED,
    gameMode: GameMode.GAME_MODE_UNSPECIFIED,
  };
}

export const GetTopRankerRequest = {
  encode(message: GetTopRankerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.profileAddress !== "") {
      writer.uint32(10).string(message.profileAddress);
    }
    if (message.week !== 0) {
      writer.uint32(16).uint32(message.week);
    }
    if (message.playMode !== PlayMode.PLAY_MODE_UNSPECIFIED) {
      writer.uint32(24).int32(playModeToNumber(message.playMode));
    }
    if (message.gameMode !== GameMode.GAME_MODE_UNSPECIFIED) {
      writer.uint32(32).int32(gameModeToNumber(message.gameMode));
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTopRankerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopRankerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.profileAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.week = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.playMode = playModeFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameMode = gameModeFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopRankerRequest {
    return {
      profileAddress: isSet(object.profileAddress) ? globalThis.String(object.profileAddress) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      playMode: isSet(object.playMode) ? playModeFromJSON(object.playMode) : PlayMode.PLAY_MODE_UNSPECIFIED,
      gameMode: isSet(object.gameMode) ? gameModeFromJSON(object.gameMode) : GameMode.GAME_MODE_UNSPECIFIED,
    };
  },

  toJSON(message: GetTopRankerRequest): unknown {
    const obj: any = {};
    if (message.profileAddress !== undefined) {
      obj.profileAddress = message.profileAddress;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.playMode !== undefined) {
      obj.playMode = playModeToJSON(message.playMode);
    }
    if (message.gameMode !== undefined) {
      obj.gameMode = gameModeToJSON(message.gameMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTopRankerRequest>, I>>(base?: I): GetTopRankerRequest {
    return GetTopRankerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTopRankerRequest>, I>>(object: I): GetTopRankerRequest {
    const message = createBaseGetTopRankerRequest();
    message.profileAddress = object.profileAddress ?? "";
    message.week = object.week ?? 0;
    message.playMode = object.playMode ?? PlayMode.PLAY_MODE_UNSPECIFIED;
    message.gameMode = object.gameMode ?? GameMode.GAME_MODE_UNSPECIFIED;
    return message;
  },
};

function createBaseRenderTopRankerLeaderboardRequest(): RenderTopRankerLeaderboardRequest {
  return {
    week: 0,
    season: 0,
    playMode: PlayMode.PLAY_MODE_UNSPECIFIED,
    gameMode: GameMode.GAME_MODE_UNSPECIFIED,
    me: "",
  };
}

export const RenderTopRankerLeaderboardRequest = {
  encode(message: RenderTopRankerLeaderboardRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.week !== 0) {
      writer.uint32(8).uint32(message.week);
    }
    if (message.season !== 0) {
      writer.uint32(16).uint32(message.season);
    }
    if (message.playMode !== PlayMode.PLAY_MODE_UNSPECIFIED) {
      writer.uint32(24).int32(playModeToNumber(message.playMode));
    }
    if (message.gameMode !== GameMode.GAME_MODE_UNSPECIFIED) {
      writer.uint32(32).int32(gameModeToNumber(message.gameMode));
    }
    if (message.me !== "") {
      writer.uint32(42).string(message.me);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RenderTopRankerLeaderboardRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderTopRankerLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.week = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.season = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.playMode = playModeFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.gameMode = gameModeFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.me = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderTopRankerLeaderboardRequest {
    return {
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
      playMode: isSet(object.playMode) ? playModeFromJSON(object.playMode) : PlayMode.PLAY_MODE_UNSPECIFIED,
      gameMode: isSet(object.gameMode) ? gameModeFromJSON(object.gameMode) : GameMode.GAME_MODE_UNSPECIFIED,
      me: isSet(object.me) ? globalThis.String(object.me) : "",
    };
  },

  toJSON(message: RenderTopRankerLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    if (message.playMode !== undefined) {
      obj.playMode = playModeToJSON(message.playMode);
    }
    if (message.gameMode !== undefined) {
      obj.gameMode = gameModeToJSON(message.gameMode);
    }
    if (message.me !== undefined) {
      obj.me = message.me;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenderTopRankerLeaderboardRequest>, I>>(
    base?: I,
  ): RenderTopRankerLeaderboardRequest {
    return RenderTopRankerLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenderTopRankerLeaderboardRequest>, I>>(
    object: I,
  ): RenderTopRankerLeaderboardRequest {
    const message = createBaseRenderTopRankerLeaderboardRequest();
    message.week = object.week ?? 0;
    message.season = object.season ?? 0;
    message.playMode = object.playMode ?? PlayMode.PLAY_MODE_UNSPECIFIED;
    message.gameMode = object.gameMode ?? GameMode.GAME_MODE_UNSPECIFIED;
    message.me = object.me ?? "";
    return message;
  },
};

function createBaseGetWeeklyTopCollectorLeaderboardRequest(): GetWeeklyTopCollectorLeaderboardRequest {
  return { pageSize: 0, pageToken: "", week: 0, season: 0 };
}

export const GetWeeklyTopCollectorLeaderboardRequest = {
  encode(message: GetWeeklyTopCollectorLeaderboardRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.week !== 0) {
      writer.uint32(24).uint32(message.week);
    }
    if (message.season !== 0) {
      writer.uint32(32).uint32(message.season);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWeeklyTopCollectorLeaderboardRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyTopCollectorLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.week = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.season = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyTopCollectorLeaderboardRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
    };
  },

  toJSON(message: GetWeeklyTopCollectorLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyTopCollectorLeaderboardRequest>, I>>(
    base?: I,
  ): GetWeeklyTopCollectorLeaderboardRequest {
    return GetWeeklyTopCollectorLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyTopCollectorLeaderboardRequest>, I>>(
    object: I,
  ): GetWeeklyTopCollectorLeaderboardRequest {
    const message = createBaseGetWeeklyTopCollectorLeaderboardRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.week = object.week ?? 0;
    message.season = object.season ?? 0;
    return message;
  },
};

function createBaseGetWeeklyTopCollectorLeaderboardResponse(): GetWeeklyTopCollectorLeaderboardResponse {
  return { topCollectors: [], nextPageToken: "", deadline: undefined };
}

export const GetWeeklyTopCollectorLeaderboardResponse = {
  encode(message: GetWeeklyTopCollectorLeaderboardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.topCollectors) {
      StarHunter.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.deadline !== undefined) {
      Timestamp.encode(toTimestamp(message.deadline), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWeeklyTopCollectorLeaderboardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyTopCollectorLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topCollectors.push(StarHunter.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyTopCollectorLeaderboardResponse {
    return {
      topCollectors: globalThis.Array.isArray(object?.topCollectors)
        ? object.topCollectors.map((e: any) => StarHunter.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      deadline: isSet(object.deadline) ? globalThis.String(object.deadline) : undefined,
    };
  },

  toJSON(message: GetWeeklyTopCollectorLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.topCollectors?.length) {
      obj.topCollectors = message.topCollectors.map((e) => StarHunter.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.deadline !== undefined) {
      obj.deadline = message.deadline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyTopCollectorLeaderboardResponse>, I>>(
    base?: I,
  ): GetWeeklyTopCollectorLeaderboardResponse {
    return GetWeeklyTopCollectorLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyTopCollectorLeaderboardResponse>, I>>(
    object: I,
  ): GetWeeklyTopCollectorLeaderboardResponse {
    const message = createBaseGetWeeklyTopCollectorLeaderboardResponse();
    message.topCollectors = object.topCollectors?.map((e) => StarHunter.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.deadline = object.deadline ?? undefined;
    return message;
  },
};

function createBaseGetWeeklyTopCollectorRequest(): GetWeeklyTopCollectorRequest {
  return { profileAddress: "", week: 0 };
}

export const GetWeeklyTopCollectorRequest = {
  encode(message: GetWeeklyTopCollectorRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.profileAddress !== "") {
      writer.uint32(10).string(message.profileAddress);
    }
    if (message.week !== 0) {
      writer.uint32(16).uint32(message.week);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWeeklyTopCollectorRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyTopCollectorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.profileAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.week = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyTopCollectorRequest {
    return {
      profileAddress: isSet(object.profileAddress) ? globalThis.String(object.profileAddress) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
    };
  },

  toJSON(message: GetWeeklyTopCollectorRequest): unknown {
    const obj: any = {};
    if (message.profileAddress !== undefined) {
      obj.profileAddress = message.profileAddress;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyTopCollectorRequest>, I>>(base?: I): GetWeeklyTopCollectorRequest {
    return GetWeeklyTopCollectorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyTopCollectorRequest>, I>>(object: I): GetWeeklyTopCollectorRequest {
    const message = createBaseGetWeeklyTopCollectorRequest();
    message.profileAddress = object.profileAddress ?? "";
    message.week = object.week ?? 0;
    return message;
  },
};

function createBaseGetAllTimeTopCollectorLeaderboardRequest(): GetAllTimeTopCollectorLeaderboardRequest {
  return { pageSize: 0, pageToken: "" };
}

export const GetAllTimeTopCollectorLeaderboardRequest = {
  encode(message: GetAllTimeTopCollectorLeaderboardRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllTimeTopCollectorLeaderboardRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllTimeTopCollectorLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllTimeTopCollectorLeaderboardRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: GetAllTimeTopCollectorLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllTimeTopCollectorLeaderboardRequest>, I>>(
    base?: I,
  ): GetAllTimeTopCollectorLeaderboardRequest {
    return GetAllTimeTopCollectorLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllTimeTopCollectorLeaderboardRequest>, I>>(
    object: I,
  ): GetAllTimeTopCollectorLeaderboardRequest {
    const message = createBaseGetAllTimeTopCollectorLeaderboardRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseGetAllTimeTopCollectorLeaderboardResponse(): GetAllTimeTopCollectorLeaderboardResponse {
  return { topCollectors: [], nextPageToken: "" };
}

export const GetAllTimeTopCollectorLeaderboardResponse = {
  encode(message: GetAllTimeTopCollectorLeaderboardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.topCollectors) {
      StarHunter.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllTimeTopCollectorLeaderboardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllTimeTopCollectorLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topCollectors.push(StarHunter.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllTimeTopCollectorLeaderboardResponse {
    return {
      topCollectors: globalThis.Array.isArray(object?.topCollectors)
        ? object.topCollectors.map((e: any) => StarHunter.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: GetAllTimeTopCollectorLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.topCollectors?.length) {
      obj.topCollectors = message.topCollectors.map((e) => StarHunter.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllTimeTopCollectorLeaderboardResponse>, I>>(
    base?: I,
  ): GetAllTimeTopCollectorLeaderboardResponse {
    return GetAllTimeTopCollectorLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllTimeTopCollectorLeaderboardResponse>, I>>(
    object: I,
  ): GetAllTimeTopCollectorLeaderboardResponse {
    const message = createBaseGetAllTimeTopCollectorLeaderboardResponse();
    message.topCollectors = object.topCollectors?.map((e) => StarHunter.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseRenderWeeklyStarHunterLeaderboardRequest(): RenderWeeklyStarHunterLeaderboardRequest {
  return { week: 0, season: 0, me: "" };
}

export const RenderWeeklyStarHunterLeaderboardRequest = {
  encode(message: RenderWeeklyStarHunterLeaderboardRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.week !== 0) {
      writer.uint32(8).uint32(message.week);
    }
    if (message.season !== 0) {
      writer.uint32(16).uint32(message.season);
    }
    if (message.me !== "") {
      writer.uint32(26).string(message.me);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RenderWeeklyStarHunterLeaderboardRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderWeeklyStarHunterLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.week = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.season = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.me = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderWeeklyStarHunterLeaderboardRequest {
    return {
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
      me: isSet(object.me) ? globalThis.String(object.me) : "",
    };
  },

  toJSON(message: RenderWeeklyStarHunterLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    if (message.me !== undefined) {
      obj.me = message.me;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenderWeeklyStarHunterLeaderboardRequest>, I>>(
    base?: I,
  ): RenderWeeklyStarHunterLeaderboardRequest {
    return RenderWeeklyStarHunterLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenderWeeklyStarHunterLeaderboardRequest>, I>>(
    object: I,
  ): RenderWeeklyStarHunterLeaderboardRequest {
    const message = createBaseRenderWeeklyStarHunterLeaderboardRequest();
    message.week = object.week ?? 0;
    message.season = object.season ?? 0;
    message.me = object.me ?? "";
    return message;
  },
};

function createBaseGetWeeklyStarHunterLeaderboardRequest(): GetWeeklyStarHunterLeaderboardRequest {
  return { pageSize: 0, pageToken: "", week: 0, season: 0 };
}

export const GetWeeklyStarHunterLeaderboardRequest = {
  encode(message: GetWeeklyStarHunterLeaderboardRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.week !== 0) {
      writer.uint32(24).uint32(message.week);
    }
    if (message.season !== 0) {
      writer.uint32(32).uint32(message.season);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWeeklyStarHunterLeaderboardRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyStarHunterLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.week = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.season = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyStarHunterLeaderboardRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      season: isSet(object.season) ? globalThis.Number(object.season) : 0,
    };
  },

  toJSON(message: GetWeeklyStarHunterLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.season !== undefined) {
      obj.season = Math.round(message.season);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyStarHunterLeaderboardRequest>, I>>(
    base?: I,
  ): GetWeeklyStarHunterLeaderboardRequest {
    return GetWeeklyStarHunterLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyStarHunterLeaderboardRequest>, I>>(
    object: I,
  ): GetWeeklyStarHunterLeaderboardRequest {
    const message = createBaseGetWeeklyStarHunterLeaderboardRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.week = object.week ?? 0;
    message.season = object.season ?? 0;
    return message;
  },
};

function createBaseGetWeeklyStarHunterLeaderboardResponse(): GetWeeklyStarHunterLeaderboardResponse {
  return { starHunters: [], nextPageToken: "", deadline: undefined };
}

export const GetWeeklyStarHunterLeaderboardResponse = {
  encode(message: GetWeeklyStarHunterLeaderboardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.starHunters) {
      StarHunter.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.deadline !== undefined) {
      Timestamp.encode(toTimestamp(message.deadline), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWeeklyStarHunterLeaderboardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyStarHunterLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.starHunters.push(StarHunter.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyStarHunterLeaderboardResponse {
    return {
      starHunters: globalThis.Array.isArray(object?.starHunters)
        ? object.starHunters.map((e: any) => StarHunter.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      deadline: isSet(object.deadline) ? globalThis.String(object.deadline) : undefined,
    };
  },

  toJSON(message: GetWeeklyStarHunterLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.starHunters?.length) {
      obj.starHunters = message.starHunters.map((e) => StarHunter.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.deadline !== undefined) {
      obj.deadline = message.deadline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyStarHunterLeaderboardResponse>, I>>(
    base?: I,
  ): GetWeeklyStarHunterLeaderboardResponse {
    return GetWeeklyStarHunterLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyStarHunterLeaderboardResponse>, I>>(
    object: I,
  ): GetWeeklyStarHunterLeaderboardResponse {
    const message = createBaseGetWeeklyStarHunterLeaderboardResponse();
    message.starHunters = object.starHunters?.map((e) => StarHunter.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.deadline = object.deadline ?? undefined;
    return message;
  },
};

function createBaseGetWeeklyStarHunterRequest(): GetWeeklyStarHunterRequest {
  return { profileAddress: "", week: 0 };
}

export const GetWeeklyStarHunterRequest = {
  encode(message: GetWeeklyStarHunterRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.profileAddress !== "") {
      writer.uint32(10).string(message.profileAddress);
    }
    if (message.week !== 0) {
      writer.uint32(16).uint32(message.week);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWeeklyStarHunterRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWeeklyStarHunterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.profileAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.week = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWeeklyStarHunterRequest {
    return {
      profileAddress: isSet(object.profileAddress) ? globalThis.String(object.profileAddress) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
    };
  },

  toJSON(message: GetWeeklyStarHunterRequest): unknown {
    const obj: any = {};
    if (message.profileAddress !== undefined) {
      obj.profileAddress = message.profileAddress;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWeeklyStarHunterRequest>, I>>(base?: I): GetWeeklyStarHunterRequest {
    return GetWeeklyStarHunterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWeeklyStarHunterRequest>, I>>(object: I): GetWeeklyStarHunterRequest {
    const message = createBaseGetWeeklyStarHunterRequest();
    message.profileAddress = object.profileAddress ?? "";
    message.week = object.week ?? 0;
    return message;
  },
};

function createBaseGetAllTimeStarHunterLeaderboardRequest(): GetAllTimeStarHunterLeaderboardRequest {
  return { pageSize: 0, pageToken: "" };
}

export const GetAllTimeStarHunterLeaderboardRequest = {
  encode(message: GetAllTimeStarHunterLeaderboardRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllTimeStarHunterLeaderboardRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllTimeStarHunterLeaderboardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllTimeStarHunterLeaderboardRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: GetAllTimeStarHunterLeaderboardRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllTimeStarHunterLeaderboardRequest>, I>>(
    base?: I,
  ): GetAllTimeStarHunterLeaderboardRequest {
    return GetAllTimeStarHunterLeaderboardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllTimeStarHunterLeaderboardRequest>, I>>(
    object: I,
  ): GetAllTimeStarHunterLeaderboardRequest {
    const message = createBaseGetAllTimeStarHunterLeaderboardRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseGetAllTimeStarHunterLeaderboardResponse(): GetAllTimeStarHunterLeaderboardResponse {
  return { starHunters: [], nextPageToken: "" };
}

export const GetAllTimeStarHunterLeaderboardResponse = {
  encode(message: GetAllTimeStarHunterLeaderboardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.starHunters) {
      StarHunter.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllTimeStarHunterLeaderboardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllTimeStarHunterLeaderboardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.starHunters.push(StarHunter.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllTimeStarHunterLeaderboardResponse {
    return {
      starHunters: globalThis.Array.isArray(object?.starHunters)
        ? object.starHunters.map((e: any) => StarHunter.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: GetAllTimeStarHunterLeaderboardResponse): unknown {
    const obj: any = {};
    if (message.starHunters?.length) {
      obj.starHunters = message.starHunters.map((e) => StarHunter.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllTimeStarHunterLeaderboardResponse>, I>>(
    base?: I,
  ): GetAllTimeStarHunterLeaderboardResponse {
    return GetAllTimeStarHunterLeaderboardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllTimeStarHunterLeaderboardResponse>, I>>(
    object: I,
  ): GetAllTimeStarHunterLeaderboardResponse {
    const message = createBaseGetAllTimeStarHunterLeaderboardResponse();
    message.starHunters = object.starHunters?.map((e) => StarHunter.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseImageResponse(): ImageResponse {
  return { image: new Uint8Array(0) };
}

export const ImageResponse = {
  encode(message: ImageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.image.length !== 0) {
      writer.uint32(10).bytes(message.image);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ImageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.image = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageResponse {
    return { image: isSet(object.image) ? bytesFromBase64(object.image) : new Uint8Array(0) };
  },

  toJSON(message: ImageResponse): unknown {
    const obj: any = {};
    if (message.image !== undefined) {
      obj.image = base64FromBytes(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageResponse>, I>>(base?: I): ImageResponse {
    return ImageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageResponse>, I>>(object: I): ImageResponse {
    const message = createBaseImageResponse();
    message.image = object.image ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTopRanker(): TopRanker {
  return { rank: 0, profile: undefined, score: undefined };
}

export const TopRanker = {
  encode(message: TopRanker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.profile !== undefined) {
      Profile.encode(message.profile, writer.uint32(18).fork()).ldelim();
    }
    if (message.score !== undefined) {
      Score.encode(message.score, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopRanker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopRanker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.profile = Profile.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.score = Score.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopRanker {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      profile: isSet(object.profile) ? Profile.fromJSON(object.profile) : undefined,
      score: isSet(object.score) ? Score.fromJSON(object.score) : undefined,
    };
  },

  toJSON(message: TopRanker): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.profile !== undefined) {
      obj.profile = Profile.toJSON(message.profile);
    }
    if (message.score !== undefined) {
      obj.score = Score.toJSON(message.score);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopRanker>, I>>(base?: I): TopRanker {
    return TopRanker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopRanker>, I>>(object: I): TopRanker {
    const message = createBaseTopRanker();
    message.rank = object.rank ?? 0;
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? Profile.fromPartial(object.profile)
      : undefined;
    message.score = (object.score !== undefined && object.score !== null) ? Score.fromPartial(object.score) : undefined;
    return message;
  },
};

function createBaseStarHunter(): StarHunter {
  return { rank: 0, profile: undefined, totalStars: 0 };
}

export const StarHunter = {
  encode(message: StarHunter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.profile !== undefined) {
      Profile.encode(message.profile, writer.uint32(18).fork()).ldelim();
    }
    if (message.totalStars !== 0) {
      writer.uint32(24).uint32(message.totalStars);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StarHunter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStarHunter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.profile = Profile.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalStars = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StarHunter {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      profile: isSet(object.profile) ? Profile.fromJSON(object.profile) : undefined,
      totalStars: isSet(object.totalStars) ? globalThis.Number(object.totalStars) : 0,
    };
  },

  toJSON(message: StarHunter): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.profile !== undefined) {
      obj.profile = Profile.toJSON(message.profile);
    }
    if (message.totalStars !== undefined) {
      obj.totalStars = Math.round(message.totalStars);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StarHunter>, I>>(base?: I): StarHunter {
    return StarHunter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StarHunter>, I>>(object: I): StarHunter {
    const message = createBaseStarHunter();
    message.rank = object.rank ?? 0;
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? Profile.fromPartial(object.profile)
      : undefined;
    message.totalStars = object.totalStars ?? 0;
    return message;
  },
};

function createBaseRenderStarHuntersLeaderboardImageRequest(): RenderStarHuntersLeaderboardImageRequest {
  return { starHunters: [], me: undefined };
}

export const RenderStarHuntersLeaderboardImageRequest = {
  encode(message: RenderStarHuntersLeaderboardImageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.starHunters) {
      StarHunterSlim.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.me !== undefined) {
      StarHunterSlim.encode(message.me, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RenderStarHuntersLeaderboardImageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderStarHuntersLeaderboardImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.starHunters.push(StarHunterSlim.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.me = StarHunterSlim.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderStarHuntersLeaderboardImageRequest {
    return {
      starHunters: globalThis.Array.isArray(object?.starHunters)
        ? object.starHunters.map((e: any) => StarHunterSlim.fromJSON(e))
        : [],
      me: isSet(object.me) ? StarHunterSlim.fromJSON(object.me) : undefined,
    };
  },

  toJSON(message: RenderStarHuntersLeaderboardImageRequest): unknown {
    const obj: any = {};
    if (message.starHunters?.length) {
      obj.starHunters = message.starHunters.map((e) => StarHunterSlim.toJSON(e));
    }
    if (message.me !== undefined) {
      obj.me = StarHunterSlim.toJSON(message.me);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenderStarHuntersLeaderboardImageRequest>, I>>(
    base?: I,
  ): RenderStarHuntersLeaderboardImageRequest {
    return RenderStarHuntersLeaderboardImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenderStarHuntersLeaderboardImageRequest>, I>>(
    object: I,
  ): RenderStarHuntersLeaderboardImageRequest {
    const message = createBaseRenderStarHuntersLeaderboardImageRequest();
    message.starHunters = object.starHunters?.map((e) => StarHunterSlim.fromPartial(e)) || [];
    message.me = (object.me !== undefined && object.me !== null) ? StarHunterSlim.fromPartial(object.me) : undefined;
    return message;
  },
};

function createBaseRenderTopRankerLeaderboardImageRequest(): RenderTopRankerLeaderboardImageRequest {
  return { topRankers: [], me: undefined };
}

export const RenderTopRankerLeaderboardImageRequest = {
  encode(message: RenderTopRankerLeaderboardImageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.topRankers) {
      TopRankerSlim.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.me !== undefined) {
      TopRankerSlim.encode(message.me, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RenderTopRankerLeaderboardImageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderTopRankerLeaderboardImageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topRankers.push(TopRankerSlim.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.me = TopRankerSlim.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderTopRankerLeaderboardImageRequest {
    return {
      topRankers: globalThis.Array.isArray(object?.topRankers)
        ? object.topRankers.map((e: any) => TopRankerSlim.fromJSON(e))
        : [],
      me: isSet(object.me) ? TopRankerSlim.fromJSON(object.me) : undefined,
    };
  },

  toJSON(message: RenderTopRankerLeaderboardImageRequest): unknown {
    const obj: any = {};
    if (message.topRankers?.length) {
      obj.topRankers = message.topRankers.map((e) => TopRankerSlim.toJSON(e));
    }
    if (message.me !== undefined) {
      obj.me = TopRankerSlim.toJSON(message.me);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenderTopRankerLeaderboardImageRequest>, I>>(
    base?: I,
  ): RenderTopRankerLeaderboardImageRequest {
    return RenderTopRankerLeaderboardImageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenderTopRankerLeaderboardImageRequest>, I>>(
    object: I,
  ): RenderTopRankerLeaderboardImageRequest {
    const message = createBaseRenderTopRankerLeaderboardImageRequest();
    message.topRankers = object.topRankers?.map((e) => TopRankerSlim.fromPartial(e)) || [];
    message.me = (object.me !== undefined && object.me !== null) ? TopRankerSlim.fromPartial(object.me) : undefined;
    return message;
  },
};

function createBaseStarHunterSlim(): StarHunterSlim {
  return { rank: 0, profile: "", totalStars: 0 };
}

export const StarHunterSlim = {
  encode(message: StarHunterSlim, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.profile !== "") {
      writer.uint32(18).string(message.profile);
    }
    if (message.totalStars !== 0) {
      writer.uint32(24).uint32(message.totalStars);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StarHunterSlim {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStarHunterSlim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.profile = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalStars = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StarHunterSlim {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      profile: isSet(object.profile) ? globalThis.String(object.profile) : "",
      totalStars: isSet(object.totalStars) ? globalThis.Number(object.totalStars) : 0,
    };
  },

  toJSON(message: StarHunterSlim): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.profile !== undefined) {
      obj.profile = message.profile;
    }
    if (message.totalStars !== undefined) {
      obj.totalStars = Math.round(message.totalStars);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StarHunterSlim>, I>>(base?: I): StarHunterSlim {
    return StarHunterSlim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StarHunterSlim>, I>>(object: I): StarHunterSlim {
    const message = createBaseStarHunterSlim();
    message.rank = object.rank ?? 0;
    message.profile = object.profile ?? "";
    message.totalStars = object.totalStars ?? 0;
    return message;
  },
};

function createBaseTopRankerSlim(): TopRankerSlim {
  return { rank: 0, profile: "", scorePoint: 0 };
}

export const TopRankerSlim = {
  encode(message: TopRankerSlim, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.profile !== "") {
      writer.uint32(18).string(message.profile);
    }
    if (message.scorePoint !== 0) {
      writer.uint32(24).uint32(message.scorePoint);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopRankerSlim {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopRankerSlim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.profile = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.scorePoint = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopRankerSlim {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      profile: isSet(object.profile) ? globalThis.String(object.profile) : "",
      scorePoint: isSet(object.scorePoint) ? globalThis.Number(object.scorePoint) : 0,
    };
  },

  toJSON(message: TopRankerSlim): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.profile !== undefined) {
      obj.profile = message.profile;
    }
    if (message.scorePoint !== undefined) {
      obj.scorePoint = Math.round(message.scorePoint);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TopRankerSlim>, I>>(base?: I): TopRankerSlim {
    return TopRankerSlim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TopRankerSlim>, I>>(object: I): TopRankerSlim {
    const message = createBaseTopRankerSlim();
    message.rank = object.rank ?? 0;
    message.profile = object.profile ?? "";
    message.scorePoint = object.scorePoint ?? 0;
    return message;
  },
};

/** LeaderboardService contains the function to get leaderboard */
export interface LeaderboardService {
  /** GetTopRankerLeaderboard will return best score leaderboard */
  GetTopRankerLeaderboard(request: GetTopRankerLeaderboardRequest): Promise<GetTopRankerLeaderboardResponse>;
  /** GetTopRanker will return weekly top collector. */
  GetTopRanker(request: GetTopRankerRequest): Promise<TopRanker>;
  /** RenderTopRankerLeaderboard will render weekly top collectors image. */
  RenderTopRankerLeaderboard(request: RenderTopRankerLeaderboardRequest): Promise<ImageResponse>;
  /** GetWeeklyTopCollectorLeaderboard will return weekly top collectors. */
  GetWeeklyTopCollectorLeaderboard(
    request: GetWeeklyTopCollectorLeaderboardRequest,
  ): Promise<GetWeeklyTopCollectorLeaderboardResponse>;
  /** GetWeeklyTopCollector will return weekly top collector. */
  GetWeeklyTopCollector(request: GetWeeklyTopCollectorRequest): Promise<StarHunter>;
  /** RenderWeeklyTopCollectorLeaderboard will render weekly top collectors image. */
  RenderWeeklyTopCollectorLeaderboard(request: RenderWeeklyStarHunterLeaderboardRequest): Promise<ImageResponse>;
  /** GetAllTimeTopCollectorLeaderboard will return all time top collectors. */
  GetAllTimeTopCollectorLeaderboard(
    request: GetAllTimeTopCollectorLeaderboardRequest,
  ): Promise<GetAllTimeTopCollectorLeaderboardResponse>;
  /** GetWeeklyStarHunterLeaderboard will return weekly top collectors. */
  GetWeeklyStarHunterLeaderboard(
    request: GetWeeklyStarHunterLeaderboardRequest,
  ): Promise<GetWeeklyStarHunterLeaderboardResponse>;
  /** GetWeeklyStarHunter will return weekly top collector. */
  GetWeeklyStarHunter(request: GetWeeklyStarHunterRequest): Promise<StarHunter>;
  /** RenderWeeklyStarHunterLeaderboard will render weekly top collectors image. */
  RenderWeeklyStarHunterLeaderboard(request: RenderWeeklyStarHunterLeaderboardRequest): Promise<ImageResponse>;
}

export const LeaderboardServiceServiceName = "ethereum.v1.leaderboard.LeaderboardService";
export class LeaderboardServiceClientImpl implements LeaderboardService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || LeaderboardServiceServiceName;
    this.rpc = rpc;
    this.GetTopRankerLeaderboard = this.GetTopRankerLeaderboard.bind(this);
    this.GetTopRanker = this.GetTopRanker.bind(this);
    this.RenderTopRankerLeaderboard = this.RenderTopRankerLeaderboard.bind(this);
    this.GetWeeklyTopCollectorLeaderboard = this.GetWeeklyTopCollectorLeaderboard.bind(this);
    this.GetWeeklyTopCollector = this.GetWeeklyTopCollector.bind(this);
    this.RenderWeeklyTopCollectorLeaderboard = this.RenderWeeklyTopCollectorLeaderboard.bind(this);
    this.GetAllTimeTopCollectorLeaderboard = this.GetAllTimeTopCollectorLeaderboard.bind(this);
    this.GetWeeklyStarHunterLeaderboard = this.GetWeeklyStarHunterLeaderboard.bind(this);
    this.GetWeeklyStarHunter = this.GetWeeklyStarHunter.bind(this);
    this.RenderWeeklyStarHunterLeaderboard = this.RenderWeeklyStarHunterLeaderboard.bind(this);
  }
  GetTopRankerLeaderboard(request: GetTopRankerLeaderboardRequest): Promise<GetTopRankerLeaderboardResponse> {
    const data = GetTopRankerLeaderboardRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTopRankerLeaderboard", data);
    return promise.then((data) => GetTopRankerLeaderboardResponse.decode(_m0.Reader.create(data)));
  }

  GetTopRanker(request: GetTopRankerRequest): Promise<TopRanker> {
    const data = GetTopRankerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTopRanker", data);
    return promise.then((data) => TopRanker.decode(_m0.Reader.create(data)));
  }

  RenderTopRankerLeaderboard(request: RenderTopRankerLeaderboardRequest): Promise<ImageResponse> {
    const data = RenderTopRankerLeaderboardRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RenderTopRankerLeaderboard", data);
    return promise.then((data) => ImageResponse.decode(_m0.Reader.create(data)));
  }

  GetWeeklyTopCollectorLeaderboard(
    request: GetWeeklyTopCollectorLeaderboardRequest,
  ): Promise<GetWeeklyTopCollectorLeaderboardResponse> {
    const data = GetWeeklyTopCollectorLeaderboardRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWeeklyTopCollectorLeaderboard", data);
    return promise.then((data) => GetWeeklyTopCollectorLeaderboardResponse.decode(_m0.Reader.create(data)));
  }

  GetWeeklyTopCollector(request: GetWeeklyTopCollectorRequest): Promise<StarHunter> {
    const data = GetWeeklyTopCollectorRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWeeklyTopCollector", data);
    return promise.then((data) => StarHunter.decode(_m0.Reader.create(data)));
  }

  RenderWeeklyTopCollectorLeaderboard(request: RenderWeeklyStarHunterLeaderboardRequest): Promise<ImageResponse> {
    const data = RenderWeeklyStarHunterLeaderboardRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RenderWeeklyTopCollectorLeaderboard", data);
    return promise.then((data) => ImageResponse.decode(_m0.Reader.create(data)));
  }

  GetAllTimeTopCollectorLeaderboard(
    request: GetAllTimeTopCollectorLeaderboardRequest,
  ): Promise<GetAllTimeTopCollectorLeaderboardResponse> {
    const data = GetAllTimeTopCollectorLeaderboardRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAllTimeTopCollectorLeaderboard", data);
    return promise.then((data) => GetAllTimeTopCollectorLeaderboardResponse.decode(_m0.Reader.create(data)));
  }

  GetWeeklyStarHunterLeaderboard(
    request: GetWeeklyStarHunterLeaderboardRequest,
  ): Promise<GetWeeklyStarHunterLeaderboardResponse> {
    const data = GetWeeklyStarHunterLeaderboardRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWeeklyStarHunterLeaderboard", data);
    return promise.then((data) => GetWeeklyStarHunterLeaderboardResponse.decode(_m0.Reader.create(data)));
  }

  GetWeeklyStarHunter(request: GetWeeklyStarHunterRequest): Promise<StarHunter> {
    const data = GetWeeklyStarHunterRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWeeklyStarHunter", data);
    return promise.then((data) => StarHunter.decode(_m0.Reader.create(data)));
  }

  RenderWeeklyStarHunterLeaderboard(request: RenderWeeklyStarHunterLeaderboardRequest): Promise<ImageResponse> {
    const data = RenderWeeklyStarHunterLeaderboardRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RenderWeeklyStarHunterLeaderboard", data);
    return promise.then((data) => ImageResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
