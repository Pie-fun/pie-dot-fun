// @generated by protoc-gen-es v1.6.0
// @generated from file blast/v1/user/user.proto (package blast.v1.user, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, FieldMask, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { ChainType } from "../nft/nft_pb.js";

/**
 * The state of user
 *
 * @generated from enum blast.v1.user.UserState
 */
export declare enum UserState {
  /**
   * default value. this value is unused.
   *
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * User was firstly created but nickname, nft is not set yet.
   * After nickname and nft is set, state will be changed to CREATED.
   *
   * @generated from enum value: CREATED_PENDING = 1;
   */
  CREATED_PENDING = 1,

  /**
   * User is neither owner nor member.
   *
   * @generated from enum value: CREATED = 2;
   */
  CREATED = 2,

  /**
   * User is owner.
   *
   * @generated from enum value: SQUARE_OWNED = 3;
   */
  SQUARE_OWNED = 3,

  /**
   * User is member.
   *
   * @generated from enum value: SQUARE_JOINED = 4;
   */
  SQUARE_JOINED = 4,
}

/**
 * The state of user
 *
 * @generated from enum blast.v1.user.UserType
 */
export declare enum UserType {
  /**
   * default value. this value is unused.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: INDEPENDENT = 1;
   */
  INDEPENDENT = 1,

  /**
   * @generated from enum value: SQUARE_OWNER = 2;
   */
  SQUARE_OWNER = 2,

  /**
   * @generated from enum value: SQUARE_MEMBER = 3;
   */
  SQUARE_MEMBER = 3,
}

/**
 * UserView enumeration represents the view of a user.
 * The view controls the amount of information returned.
 * The BASIC view omits the following fields:
 * star_balance, sns_connections, gm_stats
 *
 * Reference
 * https://cloud.google.com/apis/design/design_patterns#list_flattening and
 * https://google.aip.dev/157
 *
 * @generated from enum blast.v1.user.UserView
 */
export declare enum UserView {
  /**
   * The default / unset value.
   * The API will default to the FULL view.
   *
   * @generated from enum value: User_VIEW_UNSPECIFIED = 0;
   */
  User_VIEW_UNSPECIFIED = 0,

  /**
   * Include only basic info.
   * Do not include `nft`, `star_balance`, `sns_connections`, `gm_stats`
   *
   * @generated from enum value: BASIC = 1;
   */
  BASIC = 1,

  /**
   * Include everything.
   * This is the default value for both ListUsers and GetUser.
   *
   * @generated from enum value: FULL = 2;
   */
  FULL = 2,
}

/**
 * @generated from message blast.v1.user.GetUserRequest
 */
export declare class GetUserRequest extends Message<GetUserRequest> {
  /**
   * The name of the user to retrieve.
   * Format: users/{address}
   * Alias "users/me" is supported.
   *
   * @generated from field: string user = 1;
   */
  user: string;

  constructor(data?: PartialMessage<GetUserRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "blast.v1.user.GetUserRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUserRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUserRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUserRequest;

  static equals(a: GetUserRequest | PlainMessage<GetUserRequest> | undefined, b: GetUserRequest | PlainMessage<GetUserRequest> | undefined): boolean;
}

/**
 * ListUsersRequest payload
 * (-- api-linter: core::0158::request-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 * (-- api-linter: core::0132::request-unknown-fields=disabled
 *     aip.dev/not-precedent: We really need this field because reasons. --)
 *
 * @generated from message blast.v1.user.ListUsersRequest
 */
export declare class ListUsersRequest extends Message<ListUsersRequest> {
  /**
   * The maximum number of users to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListUsers` must match
   * the call that provided the page token.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * Available Sequence and Operator
   * * name
   *   * `Equal`
   * * address
   *   * Equal`
   * * nickname
   *   * Equal`
   * * state
   *   * Equal`
   *
   * Examples
   * * name="users/0x6F11EF2c07f2E381CbE514198DdE87A0c0a19442"
   * * address="0x6F11EF2c07f2E381CbE514198DdE87A0c0a19442"
   * * nickname="Alice"
   * * state=SQUARE_OWNED
   *
   * @generated from field: string filter = 3;
   */
  filter: string;

  constructor(data?: PartialMessage<ListUsersRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "blast.v1.user.ListUsersRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListUsersRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListUsersRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListUsersRequest;

  static equals(a: ListUsersRequest | PlainMessage<ListUsersRequest> | undefined, b: ListUsersRequest | PlainMessage<ListUsersRequest> | undefined): boolean;
}

/**
 * ListUsersResponse
 * (-- api-linter: core::0158::response-next-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 *
 * @generated from message blast.v1.user.ListUsersResponse
 */
export declare class ListUsersResponse extends Message<ListUsersResponse> {
  /**
   * The list of rows that matched the query.
   *
   * @generated from field: repeated blast.v1.user.User users = 1;
   */
  users: User[];

  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;

  constructor(data?: PartialMessage<ListUsersResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "blast.v1.user.ListUsersResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListUsersResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListUsersResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListUsersResponse;

  static equals(a: ListUsersResponse | PlainMessage<ListUsersResponse> | undefined, b: ListUsersResponse | PlainMessage<ListUsersResponse> | undefined): boolean;
}

/**
 * @generated from message blast.v1.user.UpdateUserRequest
 */
export declare class UpdateUserRequest extends Message<UpdateUserRequest> {
  /**
   * User to update
   * Format: users/{address}
   *
   * @generated from field: blast.v1.user.User user = 1;
   */
  user?: User;

  /**
   * Field mask that specifies the fields to update.
   * If no field mask is set, all fields will be updated.
   * Wildcards are supported.
   * Examples
   * ["*"]
   * ["nickname"]
   * ["nft"]
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateUserRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "blast.v1.user.UpdateUserRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateUserRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateUserRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateUserRequest;

  static equals(a: UpdateUserRequest | PlainMessage<UpdateUserRequest> | undefined, b: UpdateUserRequest | PlainMessage<UpdateUserRequest> | undefined): boolean;
}

/**
 * @generated from message blast.v1.user.IdentifyUserRequest
 */
export declare class IdentifyUserRequest extends Message<IdentifyUserRequest> {
  /**
   * Format: users/{address}
   *
   * @generated from field: string user = 1;
   */
  user: string;

  /**
   * The nickname of User.
   *
   * @generated from field: string nickname = 2;
   */
  nickname: string;

  /**
   * Format: nfts/{chain_type}/{contract_address}/{token_id}
   *
   * @generated from field: string nft = 3;
   */
  nft: string;

  /**
   * The referrer code of User.
   *
   * @generated from field: string referral_code = 4;
   */
  referralCode: string;

  constructor(data?: PartialMessage<IdentifyUserRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "blast.v1.user.IdentifyUserRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IdentifyUserRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IdentifyUserRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IdentifyUserRequest;

  static equals(a: IdentifyUserRequest | PlainMessage<IdentifyUserRequest> | undefined, b: IdentifyUserRequest | PlainMessage<IdentifyUserRequest> | undefined): boolean;
}

/**
 * @generated from message blast.v1.user.ValidateNicknameAvailabilityRequest
 */
export declare class ValidateNicknameAvailabilityRequest extends Message<ValidateNicknameAvailabilityRequest> {
  /**
   * The nickname of User.
   *
   * @generated from field: string nickname = 1;
   */
  nickname: string;

  constructor(data?: PartialMessage<ValidateNicknameAvailabilityRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "blast.v1.user.ValidateNicknameAvailabilityRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidateNicknameAvailabilityRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidateNicknameAvailabilityRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidateNicknameAvailabilityRequest;

  static equals(a: ValidateNicknameAvailabilityRequest | PlainMessage<ValidateNicknameAvailabilityRequest> | undefined, b: ValidateNicknameAvailabilityRequest | PlainMessage<ValidateNicknameAvailabilityRequest> | undefined): boolean;
}

/**
 * @generated from message blast.v1.user.ValidateNicknameAvailabilityResponse
 */
export declare class ValidateNicknameAvailabilityResponse extends Message<ValidateNicknameAvailabilityResponse> {
  /**
   * The nickname of User.
   *
   * @generated from field: string nickname = 1;
   */
  nickname: string;

  /**
   * The availability of the nickname.
   *
   * @generated from field: bool available = 2;
   */
  available: boolean;

  /**
   * The reason of the nickname is not available.
   * Example:
   * - nickname should be less or equal than 12 characters
   * - nickname should be more or equal than 4 characters
   * - nickname should start with alphabet
   * - nickname should be alphanumeric
   *
   * @generated from field: optional string reason = 3;
   */
  reason?: string;

  constructor(data?: PartialMessage<ValidateNicknameAvailabilityResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "blast.v1.user.ValidateNicknameAvailabilityResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidateNicknameAvailabilityResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidateNicknameAvailabilityResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidateNicknameAvailabilityResponse;

  static equals(a: ValidateNicknameAvailabilityResponse | PlainMessage<ValidateNicknameAvailabilityResponse> | undefined, b: ValidateNicknameAvailabilityResponse | PlainMessage<ValidateNicknameAvailabilityResponse> | undefined): boolean;
}

/**
 * @generated from message blast.v1.user.User
 */
export declare class User extends Message<User> {
  /**
   * The resource name of the User.
   * Format: users/{address}
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The address of User, mostly EOA address.
   *
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   * The created time of User.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   *
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;

  /**
   * The last updated time of User.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   *
   * @generated from field: google.protobuf.Timestamp update_time = 4;
   */
  updateTime?: Timestamp;

  /**
   * The last updated time of User's NFT.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   *
   * @generated from field: google.protobuf.Timestamp last_nft_update_time = 5;
   */
  lastNftUpdateTime?: Timestamp;

  /**
   * The type of User
   *
   * @generated from field: blast.v1.user.UserType type = 6;
   */
  type: UserType;

  /**
   * The state of User
   * Deprecated: Use type instead
   *
   * @generated from field: blast.v1.user.UserState state = 7;
   */
  state: UserState;

  /**
   * The current pfp nft of User.
   *
   * @generated from field: blast.v1.user.UserNFT nft = 8;
   */
  nft?: UserNFT;

  /**
   * The ens of user
   * This field is optional
   *
   * @generated from field: optional string ens = 9;
   */
  ens?: string;

  /**
   * The nickname of User.
   *
   * @generated from field: string nickname = 10;
   */
  nickname: string;

  constructor(data?: PartialMessage<User>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "blast.v1.user.User";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): User;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): User;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): User;

  static equals(a: User | PlainMessage<User> | undefined, b: User | PlainMessage<User> | undefined): boolean;
}

/**
 * UserNFT message represents an User's NFT.
 *
 * @generated from message blast.v1.user.UserNFT
 */
export declare class UserNFT extends Message<UserNFT> {
  /**
   * The resource name of the NFT asset.
   * Format: nfts/{chain_type}/{contract_address}/{token_id}
   * Examples: nfts/ETHEREUM/0x1f9090aaE28b8a3dCeaDf281B0F12828e676c326/1
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Token ID of the NFT asset.
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;

  /**
   * Token Name of the NFT asset.
   *
   * @generated from field: string token_name = 3;
   */
  tokenName: string;

  /**
   * The URI of the NFT asset's image.
   * This URI is cached version of image original URI
   * e.g. "https://cdn.spacebar.xyz/nfts/ethereum/0x79fcdef22feed20eddacbb2587640e45491b757f/609"
   *
   * @generated from field: string image_uri = 4;
   */
  imageUri: string;

  /**
   * The contract that owns the NFT asset.
   * Output only.
   *
   * @generated from field: blast.v1.user.UserNFTContract contract = 5;
   */
  contract?: UserNFTContract;

  constructor(data?: PartialMessage<UserNFT>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "blast.v1.user.UserNFT";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserNFT;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserNFT;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserNFT;

  static equals(a: UserNFT | PlainMessage<UserNFT> | undefined, b: UserNFT | PlainMessage<UserNFT> | undefined): boolean;
}

/**
 * NFTContract message represents an NFT contract.
 *
 * @generated from message blast.v1.user.UserNFTContract
 */
export declare class UserNFTContract extends Message<UserNFTContract> {
  /**
   * The address of the NFT contract.
   *
   * @generated from field: string address = 1;
   */
  address: string;

  /**
   * The name of the NFT contract schema.
   *
   * @generated from field: string display_name = 2;
   */
  displayName: string;

  /**
   * The symbol of the NFT contract.
   *
   * @generated from field: string symbol = 3;
   */
  symbol: string;

  /**
   * The blockchain on which the NFT contract resides.
   *
   * @generated from field: blast.v1.nft.ChainType chain = 4;
   */
  chain: ChainType;

  /**
   * The URI of the contract image
   *
   * @generated from field: string image_uri = 5;
   */
  imageUri: string;

  constructor(data?: PartialMessage<UserNFTContract>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "blast.v1.user.UserNFTContract";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserNFTContract;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserNFTContract;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserNFTContract;

  static equals(a: UserNFTContract | PlainMessage<UserNFTContract> | undefined, b: UserNFTContract | PlainMessage<UserNFTContract> | undefined): boolean;
}

