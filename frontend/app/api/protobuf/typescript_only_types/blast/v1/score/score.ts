// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: blast/v1/score/score.proto

/* eslint-disable */
import { type Empty } from "../../../google/protobuf/empty";
import { type Decimal } from "../../../google/type/decimal";
import { type UploadScoreParams } from "../chain/sign";

export const protobufPackage = "blast.v1.score";

export enum GameType {
  /** GAME_TYPE_UNSPECIFIED - default value. this value is unused. */
  GAME_TYPE_UNSPECIFIED = "GAME_TYPE_UNSPECIFIED",
  STAR_SWEEPERS = "STAR_SWEEPERS",
}

export enum PlayMode {
  /** PLAY_MODE_UNSPECIFIED - default value. this value is unused. */
  PLAY_MODE_UNSPECIFIED = "PLAY_MODE_UNSPECIFIED",
  /** SINGLE_PLAYER -  */
  SINGLE_PLAYER = "SINGLE_PLAYER",
}

/** The state of score */
export enum ScoreState {
  /** SCORE_STATE_UNSPECIFIED - default value. this value is unused. */
  SCORE_STATE_UNSPECIFIED = "SCORE_STATE_UNSPECIFIED",
  CREATED = "CREATED",
  /** UPLOADED - The score is uploaded to onchain. */
  UPLOADED = "UPLOADED",
}

export enum ScoreRankUserType {
  /** SCORE_RANK_USER_TYPE_UNSPECIFIED - default value. this value is unused. */
  SCORE_RANK_USER_TYPE_UNSPECIFIED = "SCORE_RANK_USER_TYPE_UNSPECIFIED",
  /**
   * ALL_USERS - All users in the spacebar.
   * Ranking persists regardless of the square.
   */
  ALL_USERS = "ALL_USERS",
  /**
   * ALL_MEMBERS - All members in the square.
   * Ranking persists only when the user is a member of the snapshot square.
   */
  ALL_MEMBERS = "ALL_MEMBERS",
  /**
   * SQUARE_MEMBERS - Members in the specific square.
   * Ranking persists only when the user is a member of the snapshot square.
   */
  SQUARE_MEMBERS = "SQUARE_MEMBERS",
  /**
   * SQUARE_USERS - All users in the specific square.
   * Ranking persists regardless of the square.
   */
  SQUARE_USERS = "SQUARE_USERS",
}

export enum ScoreRankTimePeriod {
  /** SCORE_RANK_TIME_PERIOD_UNSPECIFIED - default value. this value is unused. */
  SCORE_RANK_TIME_PERIOD_UNSPECIFIED = "SCORE_RANK_TIME_PERIOD_UNSPECIFIED",
  ALL_TIME = "ALL_TIME",
  WEEKLY = "WEEKLY",
  WEEKLY_FULL_WEEK_BASED = "WEEKLY_FULL_WEEK_BASED",
  MONTHLY_FULL_WEEK_BASED = "MONTHLY_FULL_WEEK_BASED",
}

export enum ScoreRankScoreType {
  /** SCORE_RANK_SCORE_TYPE_UNSPECIFIED - default value. this value is unused. */
  SCORE_RANK_SCORE_TYPE_UNSPECIFIED = "SCORE_RANK_SCORE_TYPE_UNSPECIFIED",
  BEST_SCORE = "BEST_SCORE",
  CUMULATIVE_SCORE = "CUMULATIVE_SCORE",
}

export enum ScoreRankEntitiyType {
  /** SCORE_RANK_ENTITY_TYPE_UNSPECIFIED - default value. this value is unused. */
  SCORE_RANK_ENTITY_TYPE_UNSPECIFIED = "SCORE_RANK_ENTITY_TYPE_UNSPECIFIED",
  USER = "USER",
  SQUARE = "SQUARE",
}

/** RewardRequest */
export interface RewardRequest {
  /** type */
  type: RewardRequest_RewardType;
}

/** RewardType */
export enum RewardRequest_RewardType {
  /** REWARD_TYPE_UNSPECIFIED - default value. */
  REWARD_TYPE_UNSPECIFIED = "REWARD_TYPE_UNSPECIFIED",
  WEEKLY_ALL_USERS_LEADERBOARD = "WEEKLY_ALL_USERS_LEADERBOARD",
  WEEKLY_SQUARE_MEMBERS_LEADERBOARD = "WEEKLY_SQUARE_MEMBERS_LEADERBOARD",
  WEEKLY_SS_CHALLENGE = "WEEKLY_SS_CHALLENGE",
  MONTHLY_SS_CHALLENGE = "MONTHLY_SS_CHALLENGE",
  MONTHLY_SQUARE_COMPETITION = "MONTHLY_SQUARE_COMPETITION",
}

/** RewardResponse */
export interface RewardResponse {
  /** user rewards */
  userRewards: RewardResponse_UserReward[];
}

/** user reward */
export interface RewardResponse_UserReward {
  /** user address */
  userAddress: string;
  /** spacebar points */
  points:
    | Decimal
    | undefined;
  /** blast points */
  blastPoints:
    | Decimal
    | undefined;
  /** blast gold */
  blastGold: Decimal | undefined;
}

export interface ValidateUploadScoreAndSignRequest {
  /**
   * The name of the score to create.
   * Format: users/{user_address}/scores/{game_id}
   */
  score: string;
  nonce: string;
}

export interface ValidateUploadScoreAndSignResponse {
  signature: string;
  params: UploadScoreParams | undefined;
}

/** CreateScoreRequest */
export interface CreateScoreRequest {
  /**
   * The name of the score to create.
   * Format: users/{user_address}/scores/{game_id}
   */
  name: string;
  /** score to create */
  score: Score | undefined;
}

export interface GetScoreRequest {
  /**
   * The name of the score to retrieve.
   * Format: users/{user_address}/scores/{game_id}
   */
  score: string;
}

export interface GetUserBestScoreRankingRequest {
  /**
   * The name of the score ranking to retrieve.
   * Format: rankings/bestScores/users/{user_address}
   */
  userBestScoreRanking: string;
  /** The user type of the ranking to retrieve. */
  userType: ScoreRankUserType;
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If rank type is one of ALL_MEMBERS, SQUARE_MEMBERS, the context should contain the square.
   * * snapshot_square="squares/{square_token_id}"
   * * snapshot_square_token_id="{square_token_id}"
   *
   * If rank type is ALL_USERS, the context should be empty.
   *
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   */
  context: string;
}

export interface ListUserBestScoreRankingsRequest {
  /** The user type of the ranking to retrieve. */
  userType: ScoreRankUserType;
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If rank type is one of ALL_MEMBERS, SQUARE_MEMBERS, the context should contain the square.
   * * snapshot_square="squares/{square_token_id}"
   * * snapshot_square_token_id="{square_token_id}"
   *
   * If rank type is ALL_USERS, the context should be empty.
   *
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   */
  context: string;
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPoints` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListUserBestScoreRankingsResponse {
  /** The list of rows that matched the query. */
  rankings: UserBestScoreRanking[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface GetUserCumulativeScoreRankingRequest {
  /**
   * The name of the score ranking to retrieve.
   * Format: rankings/cumulativeScores/users/{user_address}
   */
  userCumulativeScoreRanking: string;
  /** The type of ranking to retrieve. */
  userType: ScoreRankUserType;
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If rank type is one of ALL_MEMBERS, SQUARE_MEMBERS, the context should contain the square.
   * * snapshot_square="squares/{square_token_id}"
   * * snapshot_square_token_id="{square_token_id}"
   *
   * If rank type is ALL_USERS, the context should be empty.
   *
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   * If time period is WEEKLY_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_week="2024-08-W1"
   * If time period is MONTH_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_month="2024-08"
   */
  context: string;
}

export interface ListUserCumulativeScoreRankingsRequest {
  /** The type of ranking to retrieve. */
  userType: ScoreRankUserType;
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If rank type is one of ALL_MEMBERS, SQUARE_MEMBERS, the context should contain the square.
   * * snapshot_square="squares/{square_token_id}"
   * * snapshot_square_token_id="{square_token_id}"
   *
   * If rank type is ALL_USERS, the context should be empty.
   *
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   * If time period is WEEKLY_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_week="2024-08-W1"
   * If time period is MONTH_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_month="2024-08"
   */
  context: string;
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPoints` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListUserCumulativeScoreRankingsResponse {
  /** The list of rows that matched the query. */
  rankings: UserCumulativeScoreRanking[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface GetSquareCumulativeScoreRankingRequest {
  /**
   * The name of the score ranking to retrieve.
   * Format: rankings/cumulativeScores/squares/{square_address}
   */
  squareCumulativeScoreRanking: string;
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   * If time period is WEEKLY_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_week="2024-08-W1"
   * If time period is MONTH_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_month="2024-08"
   */
  context?: string | undefined;
}

export interface ListSquareCumulativeScoreRankingsRequest {
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   * If time period is WEEKLY_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_week="2024-08-W1"
   * If time period is MONTH_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_month="2024-08"
   */
  context?:
    | string
    | undefined;
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPoints` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListSquareCumulativeScoreRankingsResponse {
  /** The list of rows that matched the query. */
  rankings: SquareCumulativeScoreRanking[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface InvalidateScoreRankingsByUserRequest {
  /**
   * The name of the score ranking to invalidate.
   * Format: users/{user_address}
   */
  users: string[];
  /**
   * The context needed to decumulate the ranking according to the rank type.
   * Context for square is always required.
   * * snapshot_square="squares/{square_token_id}"
   * * snapshot_square_token_id="{square_token_id}"
   * Context for week is optional. If not set, the current week will be used.
   * * week=10
   * Context for full week based week is optional. If not set, the current date will be used.
   * * full_week_based_week="2024-08-W1"
   * Context for full week based month is optional. If not set, the current date will be used.
   * * full_week_based_month="2024-08"
   */
  context: string;
}

export interface Score {
  /**
   * The resource name of the Score.
   * Format: "users/{user_address}/scores/{game_id}"
   */
  name: string;
  /** The user address of the member. */
  userAddress: string;
  /** The game ID of the Score. */
  gameId: string;
  /** created time of score */
  createTime: string | undefined;
  state: ScoreState;
  /** points got from game */
  points: number;
  /** Game mode of score. */
  gameType: GameType;
  /** Play mode of score. */
  playMode: PlayMode;
  /** week of score */
  week: number;
  /**
   * The snapshot square token ID of the Score.
   * This field can be null if the score is not related to any square.
   */
  snapshotSquareTokenId?:
    | string
    | undefined;
  /** Thie field is internal use only. */
  blastGold?: number | undefined;
}

export interface UserBestScoreRanking {
  rank: number;
  userType: ScoreRankUserType;
  timePeriod: ScoreRankTimePeriod;
  score: Score | undefined;
}

export interface UserCumulativeScoreRanking {
  rank: number;
  userType: ScoreRankUserType;
  timePeriod: ScoreRankTimePeriod;
  userAddress: string;
  totalPoints: number;
}

export interface SquareCumulativeScoreRanking {
  rank: number;
  timePeriod: ScoreRankTimePeriod;
  squareTokenId: string;
  totalPoints: number;
  pointsCount: number;
  participantsCount: number;
}

/** ScoreService contains the function to interact with the Score of the spacebar */
export interface ScoreService {
  /** ValidateUploadScoreAndSign validate the upload score and then return signatrue if valid */
  ValidateUploadScoreAndSign(request: ValidateUploadScoreAndSignRequest): Promise<ValidateUploadScoreAndSignResponse>;
  /** CreateScore create Score with Score */
  CreateScore(request: CreateScoreRequest): Promise<Score>;
  /** GetScore */
  GetScore(request: GetScoreRequest): Promise<Score>;
  /** GetUserBestScoreRanking */
  GetUserBestScoreRanking(request: GetUserBestScoreRankingRequest): Promise<UserBestScoreRanking>;
  /** ListUserBestScoreRankings */
  ListUserBestScoreRankings(request: ListUserBestScoreRankingsRequest): Promise<ListUserBestScoreRankingsResponse>;
  /** GetUserCumulativeScoreRanking */
  GetUserCumulativeScoreRanking(request: GetUserCumulativeScoreRankingRequest): Promise<UserCumulativeScoreRanking>;
  /** ListUserCumulativeScoreRankings */
  ListUserCumulativeScoreRankings(
    request: ListUserCumulativeScoreRankingsRequest,
  ): Promise<ListUserCumulativeScoreRankingsResponse>;
  /** GetSquareCumulativeScoreRanking */
  GetSquareCumulativeScoreRanking(
    request: GetSquareCumulativeScoreRankingRequest,
  ): Promise<SquareCumulativeScoreRanking>;
  /** ListSquareCumulativeScoreRankings */
  ListSquareCumulativeScoreRankings(
    request: ListSquareCumulativeScoreRankingsRequest,
  ): Promise<ListSquareCumulativeScoreRankingsResponse>;
  /** InvalidateScoreRankingsByUser */
  InvalidateScoreRankingsByUser(request: InvalidateScoreRankingsByUserRequest): Promise<Empty>;
  /**
   * DryRunReward
   * for admin.
   */
  DryRunReward(request: RewardRequest): Promise<RewardResponse>;
}
