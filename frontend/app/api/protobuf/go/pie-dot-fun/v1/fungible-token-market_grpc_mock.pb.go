// Code generated by protoc-gen-go-grpc-mock. DO NOT EDIT.
// source: pie-dot-fun/v1/fungible-token-market.proto

package piedotfun

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockFungibleTokenMarketServiceClient is a mock of FungibleTokenMarketServiceClient interface.
type MockFungibleTokenMarketServiceClient struct {
	ctrl     *gomock.Controller
	recorder *MockFungibleTokenMarketServiceClientMockRecorder
}

// MockFungibleTokenMarketServiceClientMockRecorder is the mock recorder for MockFungibleTokenMarketServiceClient.
type MockFungibleTokenMarketServiceClientMockRecorder struct {
	mock *MockFungibleTokenMarketServiceClient
}

// NewMockFungibleTokenMarketServiceClient creates a new mock instance.
func NewMockFungibleTokenMarketServiceClient(ctrl *gomock.Controller) *MockFungibleTokenMarketServiceClient {
	mock := &MockFungibleTokenMarketServiceClient{ctrl: ctrl}
	mock.recorder = &MockFungibleTokenMarketServiceClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFungibleTokenMarketServiceClient) EXPECT() *MockFungibleTokenMarketServiceClientMockRecorder {
	return m.recorder
}

// GetFungibleTokenMarket mocks base method.
func (m *MockFungibleTokenMarketServiceClient) GetFungibleTokenMarket(ctx context.Context, in *GetFungibleTokenMarketRequest, opts ...grpc.CallOption) (*FungibleTokenMarket, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetFungibleTokenMarket", varargs...)
	ret0, _ := ret[0].(*FungibleTokenMarket)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFungibleTokenMarket indicates an expected call of GetFungibleTokenMarket.
func (mr *MockFungibleTokenMarketServiceClientMockRecorder) GetFungibleTokenMarket(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFungibleTokenMarket", reflect.TypeOf((*MockFungibleTokenMarketServiceClient)(nil).GetFungibleTokenMarket), varargs...)
}

// GetOrCreateFungibleTokenMarket mocks base method.
func (m *MockFungibleTokenMarketServiceClient) GetOrCreateFungibleTokenMarket(ctx context.Context, in *GetFungibleTokenMarketRequest, opts ...grpc.CallOption) (*FungibleTokenMarket, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetOrCreateFungibleTokenMarket", varargs...)
	ret0, _ := ret[0].(*FungibleTokenMarket)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrCreateFungibleTokenMarket indicates an expected call of GetOrCreateFungibleTokenMarket.
func (mr *MockFungibleTokenMarketServiceClientMockRecorder) GetOrCreateFungibleTokenMarket(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateFungibleTokenMarket", reflect.TypeOf((*MockFungibleTokenMarketServiceClient)(nil).GetOrCreateFungibleTokenMarket), varargs...)
}

// ListFungibleTokenMarkets mocks base method.
func (m *MockFungibleTokenMarketServiceClient) ListFungibleTokenMarkets(ctx context.Context, in *ListFungibleTokensMarketsRequest, opts ...grpc.CallOption) (*ListFungibleTokensMarketsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListFungibleTokenMarkets", varargs...)
	ret0, _ := ret[0].(*ListFungibleTokensMarketsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFungibleTokenMarkets indicates an expected call of ListFungibleTokenMarkets.
func (mr *MockFungibleTokenMarketServiceClientMockRecorder) ListFungibleTokenMarkets(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFungibleTokenMarkets", reflect.TypeOf((*MockFungibleTokenMarketServiceClient)(nil).ListFungibleTokenMarkets), varargs...)
}

// MockFungibleTokenMarketServiceServer is a mock of FungibleTokenMarketServiceServer interface.
type MockFungibleTokenMarketServiceServer struct {
	ctrl     *gomock.Controller
	recorder *MockFungibleTokenMarketServiceServerMockRecorder
}

// MockFungibleTokenMarketServiceServerMockRecorder is the mock recorder for MockFungibleTokenMarketServiceServer.
type MockFungibleTokenMarketServiceServerMockRecorder struct {
	mock *MockFungibleTokenMarketServiceServer
}

// NewMockFungibleTokenMarketServiceServer creates a new mock instance.
func NewMockFungibleTokenMarketServiceServer(ctrl *gomock.Controller) *MockFungibleTokenMarketServiceServer {
	mock := &MockFungibleTokenMarketServiceServer{ctrl: ctrl}
	mock.recorder = &MockFungibleTokenMarketServiceServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFungibleTokenMarketServiceServer) EXPECT() *MockFungibleTokenMarketServiceServerMockRecorder {
	return m.recorder
}

// GetFungibleTokenMarket mocks base method.
func (m *MockFungibleTokenMarketServiceServer) GetFungibleTokenMarket(ctx context.Context, in *GetFungibleTokenMarketRequest) (*FungibleTokenMarket, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFungibleTokenMarket", ctx, in)
	ret0, _ := ret[0].(*FungibleTokenMarket)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFungibleTokenMarket indicates an expected call of GetFungibleTokenMarket.
func (mr *MockFungibleTokenMarketServiceServerMockRecorder) GetFungibleTokenMarket(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFungibleTokenMarket", reflect.TypeOf((*MockFungibleTokenMarketServiceServer)(nil).GetFungibleTokenMarket), ctx, in)
}

// GetOrCreateFungibleTokenMarket mocks base method.
func (m *MockFungibleTokenMarketServiceServer) GetOrCreateFungibleTokenMarket(ctx context.Context, in *GetFungibleTokenMarketRequest) (*FungibleTokenMarket, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateFungibleTokenMarket", ctx, in)
	ret0, _ := ret[0].(*FungibleTokenMarket)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrCreateFungibleTokenMarket indicates an expected call of GetOrCreateFungibleTokenMarket.
func (mr *MockFungibleTokenMarketServiceServerMockRecorder) GetOrCreateFungibleTokenMarket(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateFungibleTokenMarket", reflect.TypeOf((*MockFungibleTokenMarketServiceServer)(nil).GetOrCreateFungibleTokenMarket), ctx, in)
}

// ListFungibleTokenMarkets mocks base method.
func (m *MockFungibleTokenMarketServiceServer) ListFungibleTokenMarkets(ctx context.Context, in *ListFungibleTokensMarketsRequest) (*ListFungibleTokensMarketsResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListFungibleTokenMarkets", ctx, in)
	ret0, _ := ret[0].(*ListFungibleTokensMarketsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFungibleTokenMarkets indicates an expected call of ListFungibleTokenMarkets.
func (mr *MockFungibleTokenMarketServiceServerMockRecorder) ListFungibleTokenMarkets(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFungibleTokenMarkets", reflect.TypeOf((*MockFungibleTokenMarketServiceServer)(nil).ListFungibleTokenMarkets), ctx, in)
}
