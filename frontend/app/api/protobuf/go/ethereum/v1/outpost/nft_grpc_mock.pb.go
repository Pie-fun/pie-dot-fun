// Code generated by protoc-gen-go-grpc-mock. DO NOT EDIT.
// source: ethereum/v1/outpost/nft.proto

package outpost

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockNFTServiceClient is a mock of NFTServiceClient interface.
type MockNFTServiceClient struct {
	ctrl     *gomock.Controller
	recorder *MockNFTServiceClientMockRecorder
}

// MockNFTServiceClientMockRecorder is the mock recorder for MockNFTServiceClient.
type MockNFTServiceClientMockRecorder struct {
	mock *MockNFTServiceClient
}

// NewMockNFTServiceClient creates a new mock instance.
func NewMockNFTServiceClient(ctrl *gomock.Controller) *MockNFTServiceClient {
	mock := &MockNFTServiceClient{ctrl: ctrl}
	mock.recorder = &MockNFTServiceClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNFTServiceClient) EXPECT() *MockNFTServiceClientMockRecorder {
	return m.recorder
}

// CheckHolderOfContract mocks base method.
func (m *MockNFTServiceClient) CheckHolderOfContract(ctx context.Context, in *CheckHolderOfContractRequest, opts ...grpc.CallOption) (*CheckHolderOfContractResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CheckHolderOfContract", varargs...)
	ret0, _ := ret[0].(*CheckHolderOfContractResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckHolderOfContract indicates an expected call of CheckHolderOfContract.
func (mr *MockNFTServiceClientMockRecorder) CheckHolderOfContract(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckHolderOfContract", reflect.TypeOf((*MockNFTServiceClient)(nil).CheckHolderOfContract), varargs...)
}

// GetContract mocks base method.
func (m *MockNFTServiceClient) GetContract(ctx context.Context, in *GetContractRequest, opts ...grpc.CallOption) (*NFTContract, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetContract", varargs...)
	ret0, _ := ret[0].(*NFTContract)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetContract indicates an expected call of GetContract.
func (mr *MockNFTServiceClientMockRecorder) GetContract(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContract", reflect.TypeOf((*MockNFTServiceClient)(nil).GetContract), varargs...)
}

// GetNFT mocks base method.
func (m *MockNFTServiceClient) GetNFT(ctx context.Context, in *GetNFTRequest, opts ...grpc.CallOption) (*NFT, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetNFT", varargs...)
	ret0, _ := ret[0].(*NFT)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNFT indicates an expected call of GetNFT.
func (mr *MockNFTServiceClientMockRecorder) GetNFT(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNFT", reflect.TypeOf((*MockNFTServiceClient)(nil).GetNFT), varargs...)
}

// ListNFTs mocks base method.
func (m *MockNFTServiceClient) ListNFTs(ctx context.Context, in *ListNFTsRequest, opts ...grpc.CallOption) (*ListNFTsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListNFTs", varargs...)
	ret0, _ := ret[0].(*ListNFTsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListNFTs indicates an expected call of ListNFTs.
func (mr *MockNFTServiceClientMockRecorder) ListNFTs(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNFTs", reflect.TypeOf((*MockNFTServiceClient)(nil).ListNFTs), varargs...)
}

// ListNFTsDelegate mocks base method.
func (m *MockNFTServiceClient) ListNFTsDelegate(ctx context.Context, in *ListNFTsDelegateRequest, opts ...grpc.CallOption) (*ListNFTsResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListNFTsDelegate", varargs...)
	ret0, _ := ret[0].(*ListNFTsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListNFTsDelegate indicates an expected call of ListNFTsDelegate.
func (mr *MockNFTServiceClientMockRecorder) ListNFTsDelegate(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNFTsDelegate", reflect.TypeOf((*MockNFTServiceClient)(nil).ListNFTsDelegate), varargs...)
}

// ListOwners mocks base method.
func (m *MockNFTServiceClient) ListOwners(ctx context.Context, in *ListOwnersRequest, opts ...grpc.CallOption) (*ListOwnersResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListOwners", varargs...)
	ret0, _ := ret[0].(*ListOwnersResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListOwners indicates an expected call of ListOwners.
func (mr *MockNFTServiceClientMockRecorder) ListOwners(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListOwners", reflect.TypeOf((*MockNFTServiceClient)(nil).ListOwners), varargs...)
}

// ValidateNFT mocks base method.
func (m *MockNFTServiceClient) ValidateNFT(ctx context.Context, in *ValidateNFTRequest, opts ...grpc.CallOption) (*ValidateNFTResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ValidateNFT", varargs...)
	ret0, _ := ret[0].(*ValidateNFTResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateNFT indicates an expected call of ValidateNFT.
func (mr *MockNFTServiceClientMockRecorder) ValidateNFT(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateNFT", reflect.TypeOf((*MockNFTServiceClient)(nil).ValidateNFT), varargs...)
}

// ValidateNFTAccess mocks base method.
func (m *MockNFTServiceClient) ValidateNFTAccess(ctx context.Context, in *ValidateNFTAccessRequest, opts ...grpc.CallOption) (*ValidateNFTAccessResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ValidateNFTAccess", varargs...)
	ret0, _ := ret[0].(*ValidateNFTAccessResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateNFTAccess indicates an expected call of ValidateNFTAccess.
func (mr *MockNFTServiceClientMockRecorder) ValidateNFTAccess(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateNFTAccess", reflect.TypeOf((*MockNFTServiceClient)(nil).ValidateNFTAccess), varargs...)
}

// MockNFTServiceServer is a mock of NFTServiceServer interface.
type MockNFTServiceServer struct {
	ctrl     *gomock.Controller
	recorder *MockNFTServiceServerMockRecorder
}

// MockNFTServiceServerMockRecorder is the mock recorder for MockNFTServiceServer.
type MockNFTServiceServerMockRecorder struct {
	mock *MockNFTServiceServer
}

// NewMockNFTServiceServer creates a new mock instance.
func NewMockNFTServiceServer(ctrl *gomock.Controller) *MockNFTServiceServer {
	mock := &MockNFTServiceServer{ctrl: ctrl}
	mock.recorder = &MockNFTServiceServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNFTServiceServer) EXPECT() *MockNFTServiceServerMockRecorder {
	return m.recorder
}

// CheckHolderOfContract mocks base method.
func (m *MockNFTServiceServer) CheckHolderOfContract(ctx context.Context, in *CheckHolderOfContractRequest) (*CheckHolderOfContractResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckHolderOfContract", ctx, in)
	ret0, _ := ret[0].(*CheckHolderOfContractResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckHolderOfContract indicates an expected call of CheckHolderOfContract.
func (mr *MockNFTServiceServerMockRecorder) CheckHolderOfContract(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckHolderOfContract", reflect.TypeOf((*MockNFTServiceServer)(nil).CheckHolderOfContract), ctx, in)
}

// GetContract mocks base method.
func (m *MockNFTServiceServer) GetContract(ctx context.Context, in *GetContractRequest) (*NFTContract, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetContract", ctx, in)
	ret0, _ := ret[0].(*NFTContract)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetContract indicates an expected call of GetContract.
func (mr *MockNFTServiceServerMockRecorder) GetContract(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContract", reflect.TypeOf((*MockNFTServiceServer)(nil).GetContract), ctx, in)
}

// GetNFT mocks base method.
func (m *MockNFTServiceServer) GetNFT(ctx context.Context, in *GetNFTRequest) (*NFT, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNFT", ctx, in)
	ret0, _ := ret[0].(*NFT)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNFT indicates an expected call of GetNFT.
func (mr *MockNFTServiceServerMockRecorder) GetNFT(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNFT", reflect.TypeOf((*MockNFTServiceServer)(nil).GetNFT), ctx, in)
}

// ListNFTs mocks base method.
func (m *MockNFTServiceServer) ListNFTs(ctx context.Context, in *ListNFTsRequest) (*ListNFTsResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListNFTs", ctx, in)
	ret0, _ := ret[0].(*ListNFTsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListNFTs indicates an expected call of ListNFTs.
func (mr *MockNFTServiceServerMockRecorder) ListNFTs(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNFTs", reflect.TypeOf((*MockNFTServiceServer)(nil).ListNFTs), ctx, in)
}

// ListNFTsDelegate mocks base method.
func (m *MockNFTServiceServer) ListNFTsDelegate(ctx context.Context, in *ListNFTsDelegateRequest) (*ListNFTsResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListNFTsDelegate", ctx, in)
	ret0, _ := ret[0].(*ListNFTsResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListNFTsDelegate indicates an expected call of ListNFTsDelegate.
func (mr *MockNFTServiceServerMockRecorder) ListNFTsDelegate(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNFTsDelegate", reflect.TypeOf((*MockNFTServiceServer)(nil).ListNFTsDelegate), ctx, in)
}

// ListOwners mocks base method.
func (m *MockNFTServiceServer) ListOwners(ctx context.Context, in *ListOwnersRequest) (*ListOwnersResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListOwners", ctx, in)
	ret0, _ := ret[0].(*ListOwnersResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListOwners indicates an expected call of ListOwners.
func (mr *MockNFTServiceServerMockRecorder) ListOwners(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListOwners", reflect.TypeOf((*MockNFTServiceServer)(nil).ListOwners), ctx, in)
}

// ValidateNFT mocks base method.
func (m *MockNFTServiceServer) ValidateNFT(ctx context.Context, in *ValidateNFTRequest) (*ValidateNFTResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateNFT", ctx, in)
	ret0, _ := ret[0].(*ValidateNFTResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateNFT indicates an expected call of ValidateNFT.
func (mr *MockNFTServiceServerMockRecorder) ValidateNFT(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateNFT", reflect.TypeOf((*MockNFTServiceServer)(nil).ValidateNFT), ctx, in)
}

// ValidateNFTAccess mocks base method.
func (m *MockNFTServiceServer) ValidateNFTAccess(ctx context.Context, in *ValidateNFTAccessRequest) (*ValidateNFTAccessResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateNFTAccess", ctx, in)
	ret0, _ := ret[0].(*ValidateNFTAccessResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateNFTAccess indicates an expected call of ValidateNFTAccess.
func (mr *MockNFTServiceServerMockRecorder) ValidateNFTAccess(ctx, in interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateNFTAccess", reflect.TypeOf((*MockNFTServiceServer)(nil).ValidateNFTAccess), ctx, in)
}
