// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: blast/v1/chain/query.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { ChainType, chainTypeFromJSON, chainTypeToJSON } from "../nft/nft";

export const protobufPackage = "blast.v1.chain";

export enum DelegationType {
  DELEGATION_TYPE_UNSPECIFIED = 0,
  DELEGATION_TYPE_ALL = 1,
  DELEGATION_TYPE_CONTRACT = 2,
  DELEGATION_TYPE_ERC721 = 3,
}

export function delegationTypeFromJSON(object: any): DelegationType {
  switch (object) {
    case 0:
    case "DELEGATION_TYPE_UNSPECIFIED":
      return DelegationType.DELEGATION_TYPE_UNSPECIFIED;
    case 1:
    case "DELEGATION_TYPE_ALL":
      return DelegationType.DELEGATION_TYPE_ALL;
    case 2:
    case "DELEGATION_TYPE_CONTRACT":
      return DelegationType.DELEGATION_TYPE_CONTRACT;
    case 3:
    case "DELEGATION_TYPE_ERC721":
      return DelegationType.DELEGATION_TYPE_ERC721;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DelegationType");
  }
}

export function delegationTypeToJSON(object: DelegationType): string {
  switch (object) {
    case DelegationType.DELEGATION_TYPE_UNSPECIFIED:
      return "DELEGATION_TYPE_UNSPECIFIED";
    case DelegationType.DELEGATION_TYPE_ALL:
      return "DELEGATION_TYPE_ALL";
    case DelegationType.DELEGATION_TYPE_CONTRACT:
      return "DELEGATION_TYPE_CONTRACT";
    case DelegationType.DELEGATION_TYPE_ERC721:
      return "DELEGATION_TYPE_ERC721";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DelegationType");
  }
}

/** The state of the transaction receipt. */
export enum ReceiptStatus {
  /** RECEIPT_STATUS_FAILED - RECEIPT_STATUS_FAILED is the status code of a transaction if execution failed. */
  RECEIPT_STATUS_FAILED = 0,
  /** RECEIPT_STATUS_SUCCESSFUL - RECEIPT_STATUS_SUCCESSFUL is the status code of a transaction if execution succeeded. */
  RECEIPT_STATUS_SUCCESSFUL = 1,
}

export function receiptStatusFromJSON(object: any): ReceiptStatus {
  switch (object) {
    case 0:
    case "RECEIPT_STATUS_FAILED":
      return ReceiptStatus.RECEIPT_STATUS_FAILED;
    case 1:
    case "RECEIPT_STATUS_SUCCESSFUL":
      return ReceiptStatus.RECEIPT_STATUS_SUCCESSFUL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ReceiptStatus");
  }
}

export function receiptStatusToJSON(object: ReceiptStatus): string {
  switch (object) {
    case ReceiptStatus.RECEIPT_STATUS_FAILED:
      return "RECEIPT_STATUS_FAILED";
    case ReceiptStatus.RECEIPT_STATUS_SUCCESSFUL:
      return "RECEIPT_STATUS_SUCCESSFUL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ReceiptStatus");
  }
}

export interface QueryReceiptRequest {
  txHash: string;
  /**
   * e.g. "60s", "5m", "1h30m"
   *
   * The amount of time to wait for the transaction to be mined.
   *
   * If the transaction is not mined within this time, server will return 504 Gateway Timeout(DEADLINE_EXCEEDED).
   *
   * The default is 5 minutes.
   *
   * The maximum allowed timeout is 30 minutes. If the value is greater than 30 minutes, server will automatically set it to 30 minutes.
   *
   * If longer timeout is needed, please retry after the previous request times out.
   */
  timeout: string;
}

export interface QueryQueryTransactionCountRequest {
  address: string;
  blockNumber: number;
}

export interface QueryQueryTransactionCountResponse {
  count: number;
}

export interface QueryDelegateCashRequest {
  address: string;
  chains: ChainType[];
}

export interface QueryDelegateCashResponse {
  delegates: Delegate[];
}

export interface QueryStakingContractAddressRequest {
  address: string;
}

export interface QueryStakingContractAddressResponse {
  contractAddress: string;
}

export interface QueryStakingAmountRequest {
  address: string;
}

export interface QueryStakingAmountResponse {
  stakingAmount: string;
}

export interface QueryOwnerOfRequest {
  contractAddress: string;
  tokenId: string;
}

export interface QueryOwnerOfResponse {
  ownerAddress: string;
}

export interface QueryBalanceOfRequest {
  contractAddress: string;
  ownerAddress: string;
}

export interface QueryBalanceOfResponse {
  balance: number;
}

export interface Delegate {
  type: DelegationType;
  from: string;
  to: string;
  contract: string;
  tokenId: string;
}

export interface Receipt {
  status: ReceiptStatus;
  transactionHash: string;
  blockHash: string;
  blockNumber: string;
  cumulativeGasUsed: number;
  gasUsed: number;
  contractAddress: string;
}

export interface MintScoreEvent {
  category?: MintScoreEvent_ScoreCategory | undefined;
  score?: number | undefined;
  address?: string | undefined;
  tokenId?: string | undefined;
}

export enum MintScoreEvent_ScoreCategory {
  SCORE_CATEGORY_UNSPECIFIED = 0,
  SINGLE_PLAYER = 1,
  MULTI_PLAYER = 2,
}

export function mintScoreEvent_ScoreCategoryFromJSON(object: any): MintScoreEvent_ScoreCategory {
  switch (object) {
    case 0:
    case "SCORE_CATEGORY_UNSPECIFIED":
      return MintScoreEvent_ScoreCategory.SCORE_CATEGORY_UNSPECIFIED;
    case 1:
    case "SINGLE_PLAYER":
      return MintScoreEvent_ScoreCategory.SINGLE_PLAYER;
    case 2:
    case "MULTI_PLAYER":
      return MintScoreEvent_ScoreCategory.MULTI_PLAYER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MintScoreEvent_ScoreCategory");
  }
}

export function mintScoreEvent_ScoreCategoryToJSON(object: MintScoreEvent_ScoreCategory): string {
  switch (object) {
    case MintScoreEvent_ScoreCategory.SCORE_CATEGORY_UNSPECIFIED:
      return "SCORE_CATEGORY_UNSPECIFIED";
    case MintScoreEvent_ScoreCategory.SINGLE_PLAYER:
      return "SINGLE_PLAYER";
    case MintScoreEvent_ScoreCategory.MULTI_PLAYER:
      return "MULTI_PLAYER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MintScoreEvent_ScoreCategory");
  }
}

export interface DeployTBAAndMintProtoShipEvent {
  profileTba: string;
  tokenId: string;
}

function createBaseQueryReceiptRequest(): QueryReceiptRequest {
  return { txHash: "", timeout: "" };
}

export const QueryReceiptRequest = {
  encode(message: QueryReceiptRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.timeout !== "") {
      writer.uint32(18).string(message.timeout);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryReceiptRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReceiptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeout = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReceiptRequest {
    return {
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      timeout: isSet(object.timeout) ? globalThis.String(object.timeout) : "",
    };
  },

  toJSON(message: QueryReceiptRequest): unknown {
    const obj: any = {};
    if (message.txHash !== undefined) {
      obj.txHash = message.txHash;
    }
    if (message.timeout !== undefined) {
      obj.timeout = message.timeout;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReceiptRequest>, I>>(base?: I): QueryReceiptRequest {
    return QueryReceiptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReceiptRequest>, I>>(object: I): QueryReceiptRequest {
    const message = createBaseQueryReceiptRequest();
    message.txHash = object.txHash ?? "";
    message.timeout = object.timeout ?? "";
    return message;
  },
};

function createBaseQueryQueryTransactionCountRequest(): QueryQueryTransactionCountRequest {
  return { address: "", blockNumber: 0 };
}

export const QueryQueryTransactionCountRequest = {
  encode(message: QueryQueryTransactionCountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.blockNumber !== 0) {
      writer.uint32(16).uint64(message.blockNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryQueryTransactionCountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQueryTransactionCountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.blockNumber = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQueryTransactionCountRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      blockNumber: isSet(object.blockNumber) ? globalThis.Number(object.blockNumber) : 0,
    };
  },

  toJSON(message: QueryQueryTransactionCountRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.blockNumber !== undefined) {
      obj.blockNumber = Math.round(message.blockNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQueryTransactionCountRequest>, I>>(
    base?: I,
  ): QueryQueryTransactionCountRequest {
    return QueryQueryTransactionCountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQueryTransactionCountRequest>, I>>(
    object: I,
  ): QueryQueryTransactionCountRequest {
    const message = createBaseQueryQueryTransactionCountRequest();
    message.address = object.address ?? "";
    message.blockNumber = object.blockNumber ?? 0;
    return message;
  },
};

function createBaseQueryQueryTransactionCountResponse(): QueryQueryTransactionCountResponse {
  return { count: 0 };
}

export const QueryQueryTransactionCountResponse = {
  encode(message: QueryQueryTransactionCountResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== 0) {
      writer.uint32(8).uint64(message.count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryQueryTransactionCountResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryQueryTransactionCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryQueryTransactionCountResponse {
    return { count: isSet(object.count) ? globalThis.Number(object.count) : 0 };
  },

  toJSON(message: QueryQueryTransactionCountResponse): unknown {
    const obj: any = {};
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryQueryTransactionCountResponse>, I>>(
    base?: I,
  ): QueryQueryTransactionCountResponse {
    return QueryQueryTransactionCountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryQueryTransactionCountResponse>, I>>(
    object: I,
  ): QueryQueryTransactionCountResponse {
    const message = createBaseQueryQueryTransactionCountResponse();
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseQueryDelegateCashRequest(): QueryDelegateCashRequest {
  return { address: "", chains: [] };
}

export const QueryDelegateCashRequest = {
  encode(message: QueryDelegateCashRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    writer.uint32(18).fork();
    for (const v of message.chains) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegateCashRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDelegateCashRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.chains.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.chains.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDelegateCashRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      chains: globalThis.Array.isArray(object?.chains) ? object.chains.map((e: any) => chainTypeFromJSON(e)) : [],
    };
  },

  toJSON(message: QueryDelegateCashRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.chains?.length) {
      obj.chains = message.chains.map((e) => chainTypeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryDelegateCashRequest>, I>>(base?: I): QueryDelegateCashRequest {
    return QueryDelegateCashRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryDelegateCashRequest>, I>>(object: I): QueryDelegateCashRequest {
    const message = createBaseQueryDelegateCashRequest();
    message.address = object.address ?? "";
    message.chains = object.chains?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryDelegateCashResponse(): QueryDelegateCashResponse {
  return { delegates: [] };
}

export const QueryDelegateCashResponse = {
  encode(message: QueryDelegateCashResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.delegates) {
      Delegate.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelegateCashResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDelegateCashResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.delegates.push(Delegate.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDelegateCashResponse {
    return {
      delegates: globalThis.Array.isArray(object?.delegates)
        ? object.delegates.map((e: any) => Delegate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryDelegateCashResponse): unknown {
    const obj: any = {};
    if (message.delegates?.length) {
      obj.delegates = message.delegates.map((e) => Delegate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryDelegateCashResponse>, I>>(base?: I): QueryDelegateCashResponse {
    return QueryDelegateCashResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryDelegateCashResponse>, I>>(object: I): QueryDelegateCashResponse {
    const message = createBaseQueryDelegateCashResponse();
    message.delegates = object.delegates?.map((e) => Delegate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryStakingContractAddressRequest(): QueryStakingContractAddressRequest {
  return { address: "" };
}

export const QueryStakingContractAddressRequest = {
  encode(message: QueryStakingContractAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryStakingContractAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStakingContractAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStakingContractAddressRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryStakingContractAddressRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStakingContractAddressRequest>, I>>(
    base?: I,
  ): QueryStakingContractAddressRequest {
    return QueryStakingContractAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStakingContractAddressRequest>, I>>(
    object: I,
  ): QueryStakingContractAddressRequest {
    const message = createBaseQueryStakingContractAddressRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryStakingContractAddressResponse(): QueryStakingContractAddressResponse {
  return { contractAddress: "" };
}

export const QueryStakingContractAddressResponse = {
  encode(message: QueryStakingContractAddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryStakingContractAddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStakingContractAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStakingContractAddressResponse {
    return { contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "" };
  },

  toJSON(message: QueryStakingContractAddressResponse): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = message.contractAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStakingContractAddressResponse>, I>>(
    base?: I,
  ): QueryStakingContractAddressResponse {
    return QueryStakingContractAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStakingContractAddressResponse>, I>>(
    object: I,
  ): QueryStakingContractAddressResponse {
    const message = createBaseQueryStakingContractAddressResponse();
    message.contractAddress = object.contractAddress ?? "";
    return message;
  },
};

function createBaseQueryStakingAmountRequest(): QueryStakingAmountRequest {
  return { address: "" };
}

export const QueryStakingAmountRequest = {
  encode(message: QueryStakingAmountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryStakingAmountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStakingAmountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStakingAmountRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryStakingAmountRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStakingAmountRequest>, I>>(base?: I): QueryStakingAmountRequest {
    return QueryStakingAmountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStakingAmountRequest>, I>>(object: I): QueryStakingAmountRequest {
    const message = createBaseQueryStakingAmountRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryStakingAmountResponse(): QueryStakingAmountResponse {
  return { stakingAmount: "" };
}

export const QueryStakingAmountResponse = {
  encode(message: QueryStakingAmountResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stakingAmount !== "") {
      writer.uint32(10).string(message.stakingAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryStakingAmountResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStakingAmountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stakingAmount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStakingAmountResponse {
    return { stakingAmount: isSet(object.stakingAmount) ? globalThis.String(object.stakingAmount) : "" };
  },

  toJSON(message: QueryStakingAmountResponse): unknown {
    const obj: any = {};
    if (message.stakingAmount !== undefined) {
      obj.stakingAmount = message.stakingAmount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStakingAmountResponse>, I>>(base?: I): QueryStakingAmountResponse {
    return QueryStakingAmountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStakingAmountResponse>, I>>(object: I): QueryStakingAmountResponse {
    const message = createBaseQueryStakingAmountResponse();
    message.stakingAmount = object.stakingAmount ?? "";
    return message;
  },
};

function createBaseQueryOwnerOfRequest(): QueryOwnerOfRequest {
  return { contractAddress: "", tokenId: "" };
}

export const QueryOwnerOfRequest = {
  encode(message: QueryOwnerOfRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOwnerOfRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOwnerOfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOwnerOfRequest {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: QueryOwnerOfRequest): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = message.contractAddress;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOwnerOfRequest>, I>>(base?: I): QueryOwnerOfRequest {
    return QueryOwnerOfRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOwnerOfRequest>, I>>(object: I): QueryOwnerOfRequest {
    const message = createBaseQueryOwnerOfRequest();
    message.contractAddress = object.contractAddress ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseQueryOwnerOfResponse(): QueryOwnerOfResponse {
  return { ownerAddress: "" };
}

export const QueryOwnerOfResponse = {
  encode(message: QueryOwnerOfResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryOwnerOfResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOwnerOfResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOwnerOfResponse {
    return { ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "" };
  },

  toJSON(message: QueryOwnerOfResponse): unknown {
    const obj: any = {};
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOwnerOfResponse>, I>>(base?: I): QueryOwnerOfResponse {
    return QueryOwnerOfResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOwnerOfResponse>, I>>(object: I): QueryOwnerOfResponse {
    const message = createBaseQueryOwnerOfResponse();
    message.ownerAddress = object.ownerAddress ?? "";
    return message;
  },
};

function createBaseQueryBalanceOfRequest(): QueryBalanceOfRequest {
  return { contractAddress: "", ownerAddress: "" };
}

export const QueryBalanceOfRequest = {
  encode(message: QueryBalanceOfRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(18).string(message.ownerAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceOfRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceOfRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceOfRequest {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
    };
  },

  toJSON(message: QueryBalanceOfRequest): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contractAddress = message.contractAddress;
    }
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBalanceOfRequest>, I>>(base?: I): QueryBalanceOfRequest {
    return QueryBalanceOfRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBalanceOfRequest>, I>>(object: I): QueryBalanceOfRequest {
    const message = createBaseQueryBalanceOfRequest();
    message.contractAddress = object.contractAddress ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    return message;
  },
};

function createBaseQueryBalanceOfResponse(): QueryBalanceOfResponse {
  return { balance: 0 };
}

export const QueryBalanceOfResponse = {
  encode(message: QueryBalanceOfResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.balance !== 0) {
      writer.uint32(8).uint32(message.balance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBalanceOfResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBalanceOfResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.balance = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBalanceOfResponse {
    return { balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0 };
  },

  toJSON(message: QueryBalanceOfResponse): unknown {
    const obj: any = {};
    if (message.balance !== undefined) {
      obj.balance = Math.round(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBalanceOfResponse>, I>>(base?: I): QueryBalanceOfResponse {
    return QueryBalanceOfResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBalanceOfResponse>, I>>(object: I): QueryBalanceOfResponse {
    const message = createBaseQueryBalanceOfResponse();
    message.balance = object.balance ?? 0;
    return message;
  },
};

function createBaseDelegate(): Delegate {
  return { type: 0, from: "", to: "", contract: "", tokenId: "" };
}

export const Delegate = {
  encode(message: Delegate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(26).string(message.to);
    }
    if (message.contract !== "") {
      writer.uint32(34).string(message.contract);
    }
    if (message.tokenId !== "") {
      writer.uint32(42).string(message.tokenId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Delegate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contract = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tokenId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Delegate {
    return {
      type: isSet(object.type) ? delegationTypeFromJSON(object.type) : 0,
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      contract: isSet(object.contract) ? globalThis.String(object.contract) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: Delegate): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = delegationTypeToJSON(message.type);
    }
    if (message.from !== undefined) {
      obj.from = message.from;
    }
    if (message.to !== undefined) {
      obj.to = message.to;
    }
    if (message.contract !== undefined) {
      obj.contract = message.contract;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Delegate>, I>>(base?: I): Delegate {
    return Delegate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Delegate>, I>>(object: I): Delegate {
    const message = createBaseDelegate();
    message.type = object.type ?? 0;
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.contract = object.contract ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

function createBaseReceipt(): Receipt {
  return {
    status: 0,
    transactionHash: "",
    blockHash: "",
    blockNumber: "",
    cumulativeGasUsed: 0,
    gasUsed: 0,
    contractAddress: "",
  };
}

export const Receipt = {
  encode(message: Receipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.transactionHash !== "") {
      writer.uint32(18).string(message.transactionHash);
    }
    if (message.blockHash !== "") {
      writer.uint32(26).string(message.blockHash);
    }
    if (message.blockNumber !== "") {
      writer.uint32(34).string(message.blockNumber);
    }
    if (message.cumulativeGasUsed !== 0) {
      writer.uint32(40).uint64(message.cumulativeGasUsed);
    }
    if (message.gasUsed !== 0) {
      writer.uint32(48).uint64(message.gasUsed);
    }
    if (message.contractAddress !== "") {
      writer.uint32(58).string(message.contractAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Receipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionHash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockNumber = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.cumulativeGasUsed = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.gasUsed = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt {
    return {
      status: isSet(object.status) ? receiptStatusFromJSON(object.status) : 0,
      transactionHash: isSet(object.transactionHash) ? globalThis.String(object.transactionHash) : "",
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      blockNumber: isSet(object.blockNumber) ? globalThis.String(object.blockNumber) : "",
      cumulativeGasUsed: isSet(object.cumulativeGasUsed) ? globalThis.Number(object.cumulativeGasUsed) : 0,
      gasUsed: isSet(object.gasUsed) ? globalThis.Number(object.gasUsed) : 0,
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
    };
  },

  toJSON(message: Receipt): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = receiptStatusToJSON(message.status);
    }
    if (message.transactionHash !== undefined) {
      obj.transactionHash = message.transactionHash;
    }
    if (message.blockHash !== undefined) {
      obj.blockHash = message.blockHash;
    }
    if (message.blockNumber !== undefined) {
      obj.blockNumber = message.blockNumber;
    }
    if (message.cumulativeGasUsed !== undefined) {
      obj.cumulativeGasUsed = Math.round(message.cumulativeGasUsed);
    }
    if (message.gasUsed !== undefined) {
      obj.gasUsed = Math.round(message.gasUsed);
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = message.contractAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt>, I>>(base?: I): Receipt {
    return Receipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt>, I>>(object: I): Receipt {
    const message = createBaseReceipt();
    message.status = object.status ?? 0;
    message.transactionHash = object.transactionHash ?? "";
    message.blockHash = object.blockHash ?? "";
    message.blockNumber = object.blockNumber ?? "";
    message.cumulativeGasUsed = object.cumulativeGasUsed ?? 0;
    message.gasUsed = object.gasUsed ?? 0;
    message.contractAddress = object.contractAddress ?? "";
    return message;
  },
};

function createBaseMintScoreEvent(): MintScoreEvent {
  return { category: undefined, score: undefined, address: undefined, tokenId: undefined };
}

export const MintScoreEvent = {
  encode(message: MintScoreEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.category !== undefined) {
      writer.uint32(8).int32(message.category);
    }
    if (message.score !== undefined) {
      writer.uint32(16).uint64(message.score);
    }
    if (message.address !== undefined) {
      writer.uint32(26).string(message.address);
    }
    if (message.tokenId !== undefined) {
      writer.uint32(34).string(message.tokenId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MintScoreEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintScoreEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.score = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tokenId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintScoreEvent {
    return {
      category: isSet(object.category) ? mintScoreEvent_ScoreCategoryFromJSON(object.category) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : undefined,
    };
  },

  toJSON(message: MintScoreEvent): unknown {
    const obj: any = {};
    if (message.category !== undefined) {
      obj.category = mintScoreEvent_ScoreCategoryToJSON(message.category);
    }
    if (message.score !== undefined) {
      obj.score = Math.round(message.score);
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MintScoreEvent>, I>>(base?: I): MintScoreEvent {
    return MintScoreEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MintScoreEvent>, I>>(object: I): MintScoreEvent {
    const message = createBaseMintScoreEvent();
    message.category = object.category ?? undefined;
    message.score = object.score ?? undefined;
    message.address = object.address ?? undefined;
    message.tokenId = object.tokenId ?? undefined;
    return message;
  },
};

function createBaseDeployTBAAndMintProtoShipEvent(): DeployTBAAndMintProtoShipEvent {
  return { profileTba: "", tokenId: "" };
}

export const DeployTBAAndMintProtoShipEvent = {
  encode(message: DeployTBAAndMintProtoShipEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.profileTba !== "") {
      writer.uint32(10).string(message.profileTba);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeployTBAAndMintProtoShipEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployTBAAndMintProtoShipEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.profileTba = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployTBAAndMintProtoShipEvent {
    return {
      profileTba: isSet(object.profileTba) ? globalThis.String(object.profileTba) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
    };
  },

  toJSON(message: DeployTBAAndMintProtoShipEvent): unknown {
    const obj: any = {};
    if (message.profileTba !== undefined) {
      obj.profileTba = message.profileTba;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeployTBAAndMintProtoShipEvent>, I>>(base?: I): DeployTBAAndMintProtoShipEvent {
    return DeployTBAAndMintProtoShipEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeployTBAAndMintProtoShipEvent>, I>>(
    object: I,
  ): DeployTBAAndMintProtoShipEvent {
    const message = createBaseDeployTBAAndMintProtoShipEvent();
    message.profileTba = object.profileTba ?? "";
    message.tokenId = object.tokenId ?? "";
    return message;
  },
};

/** ChainQueryService is the service that handles all chain requests. */
export interface ChainQueryService {
  QueryReceipt(request: QueryReceiptRequest): Promise<Receipt>;
  QueryTransactionCount(request: QueryQueryTransactionCountRequest): Promise<QueryQueryTransactionCountResponse>;
  QueryDelegateCash(request: QueryDelegateCashRequest): Promise<QueryDelegateCashResponse>;
  QueryStakingContractAddress(
    request: QueryStakingContractAddressRequest,
  ): Promise<QueryStakingContractAddressResponse>;
  QueryStakingAmount(request: QueryStakingAmountRequest): Promise<QueryStakingAmountResponse>;
  QueryOwnerOf(request: QueryOwnerOfRequest): Promise<QueryOwnerOfResponse>;
  QueryBalanceOf(request: QueryBalanceOfRequest): Promise<QueryBalanceOfResponse>;
}

export const ChainQueryServiceServiceName = "blast.v1.chain.ChainQueryService";
export class ChainQueryServiceClientImpl implements ChainQueryService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ChainQueryServiceServiceName;
    this.rpc = rpc;
    this.QueryReceipt = this.QueryReceipt.bind(this);
    this.QueryTransactionCount = this.QueryTransactionCount.bind(this);
    this.QueryDelegateCash = this.QueryDelegateCash.bind(this);
    this.QueryStakingContractAddress = this.QueryStakingContractAddress.bind(this);
    this.QueryStakingAmount = this.QueryStakingAmount.bind(this);
    this.QueryOwnerOf = this.QueryOwnerOf.bind(this);
    this.QueryBalanceOf = this.QueryBalanceOf.bind(this);
  }
  QueryReceipt(request: QueryReceiptRequest): Promise<Receipt> {
    const data = QueryReceiptRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryReceipt", data);
    return promise.then((data) => Receipt.decode(_m0.Reader.create(data)));
  }

  QueryTransactionCount(request: QueryQueryTransactionCountRequest): Promise<QueryQueryTransactionCountResponse> {
    const data = QueryQueryTransactionCountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryTransactionCount", data);
    return promise.then((data) => QueryQueryTransactionCountResponse.decode(_m0.Reader.create(data)));
  }

  QueryDelegateCash(request: QueryDelegateCashRequest): Promise<QueryDelegateCashResponse> {
    const data = QueryDelegateCashRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryDelegateCash", data);
    return promise.then((data) => QueryDelegateCashResponse.decode(_m0.Reader.create(data)));
  }

  QueryStakingContractAddress(
    request: QueryStakingContractAddressRequest,
  ): Promise<QueryStakingContractAddressResponse> {
    const data = QueryStakingContractAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryStakingContractAddress", data);
    return promise.then((data) => QueryStakingContractAddressResponse.decode(_m0.Reader.create(data)));
  }

  QueryStakingAmount(request: QueryStakingAmountRequest): Promise<QueryStakingAmountResponse> {
    const data = QueryStakingAmountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryStakingAmount", data);
    return promise.then((data) => QueryStakingAmountResponse.decode(_m0.Reader.create(data)));
  }

  QueryOwnerOf(request: QueryOwnerOfRequest): Promise<QueryOwnerOfResponse> {
    const data = QueryOwnerOfRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryOwnerOf", data);
    return promise.then((data) => QueryOwnerOfResponse.decode(_m0.Reader.create(data)));
  }

  QueryBalanceOf(request: QueryBalanceOfRequest): Promise<QueryBalanceOfResponse> {
    const data = QueryBalanceOfRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryBalanceOf", data);
    return promise.then((data) => QueryBalanceOfResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
