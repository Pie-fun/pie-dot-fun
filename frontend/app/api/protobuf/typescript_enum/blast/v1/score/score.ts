// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: blast/v1/score/score.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Empty } from "../../../google/protobuf/empty";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Decimal } from "../../../google/type/decimal";
import { UploadScoreParams } from "../chain/sign";

export const protobufPackage = "blast.v1.score";

export enum GameType {
  /** GAME_TYPE_UNSPECIFIED - default value. this value is unused. */
  GAME_TYPE_UNSPECIFIED = 0,
  STAR_SWEEPERS = 1,
}

export function gameTypeFromJSON(object: any): GameType {
  switch (object) {
    case 0:
    case "GAME_TYPE_UNSPECIFIED":
      return GameType.GAME_TYPE_UNSPECIFIED;
    case 1:
    case "STAR_SWEEPERS":
      return GameType.STAR_SWEEPERS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GameType");
  }
}

export function gameTypeToJSON(object: GameType): string {
  switch (object) {
    case GameType.GAME_TYPE_UNSPECIFIED:
      return "GAME_TYPE_UNSPECIFIED";
    case GameType.STAR_SWEEPERS:
      return "STAR_SWEEPERS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum GameType");
  }
}

export enum PlayMode {
  /** PLAY_MODE_UNSPECIFIED - default value. this value is unused. */
  PLAY_MODE_UNSPECIFIED = 0,
  /** SINGLE_PLAYER -  */
  SINGLE_PLAYER = 1,
}

export function playModeFromJSON(object: any): PlayMode {
  switch (object) {
    case 0:
    case "PLAY_MODE_UNSPECIFIED":
      return PlayMode.PLAY_MODE_UNSPECIFIED;
    case 1:
    case "SINGLE_PLAYER":
      return PlayMode.SINGLE_PLAYER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PlayMode");
  }
}

export function playModeToJSON(object: PlayMode): string {
  switch (object) {
    case PlayMode.PLAY_MODE_UNSPECIFIED:
      return "PLAY_MODE_UNSPECIFIED";
    case PlayMode.SINGLE_PLAYER:
      return "SINGLE_PLAYER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PlayMode");
  }
}

/** The state of score */
export enum ScoreState {
  /** SCORE_STATE_UNSPECIFIED - default value. this value is unused. */
  SCORE_STATE_UNSPECIFIED = 0,
  CREATED = 1,
  /** UPLOADED - The score is uploaded to onchain. */
  UPLOADED = 2,
}

export function scoreStateFromJSON(object: any): ScoreState {
  switch (object) {
    case 0:
    case "SCORE_STATE_UNSPECIFIED":
      return ScoreState.SCORE_STATE_UNSPECIFIED;
    case 1:
    case "CREATED":
      return ScoreState.CREATED;
    case 2:
    case "UPLOADED":
      return ScoreState.UPLOADED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ScoreState");
  }
}

export function scoreStateToJSON(object: ScoreState): string {
  switch (object) {
    case ScoreState.SCORE_STATE_UNSPECIFIED:
      return "SCORE_STATE_UNSPECIFIED";
    case ScoreState.CREATED:
      return "CREATED";
    case ScoreState.UPLOADED:
      return "UPLOADED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ScoreState");
  }
}

export enum ScoreRankUserType {
  /** SCORE_RANK_USER_TYPE_UNSPECIFIED - default value. this value is unused. */
  SCORE_RANK_USER_TYPE_UNSPECIFIED = 0,
  /**
   * ALL_USERS - All users in the spacebar.
   * Ranking persists regardless of the square.
   */
  ALL_USERS = 1,
  /**
   * ALL_MEMBERS - All members in the square.
   * Ranking persists only when the user is a member of the snapshot square.
   */
  ALL_MEMBERS = 2,
  /**
   * SQUARE_MEMBERS - Members in the specific square.
   * Ranking persists only when the user is a member of the snapshot square.
   */
  SQUARE_MEMBERS = 3,
  /**
   * SQUARE_USERS - All users in the specific square.
   * Ranking persists regardless of the square.
   */
  SQUARE_USERS = 4,
}

export function scoreRankUserTypeFromJSON(object: any): ScoreRankUserType {
  switch (object) {
    case 0:
    case "SCORE_RANK_USER_TYPE_UNSPECIFIED":
      return ScoreRankUserType.SCORE_RANK_USER_TYPE_UNSPECIFIED;
    case 1:
    case "ALL_USERS":
      return ScoreRankUserType.ALL_USERS;
    case 2:
    case "ALL_MEMBERS":
      return ScoreRankUserType.ALL_MEMBERS;
    case 3:
    case "SQUARE_MEMBERS":
      return ScoreRankUserType.SQUARE_MEMBERS;
    case 4:
    case "SQUARE_USERS":
      return ScoreRankUserType.SQUARE_USERS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ScoreRankUserType");
  }
}

export function scoreRankUserTypeToJSON(object: ScoreRankUserType): string {
  switch (object) {
    case ScoreRankUserType.SCORE_RANK_USER_TYPE_UNSPECIFIED:
      return "SCORE_RANK_USER_TYPE_UNSPECIFIED";
    case ScoreRankUserType.ALL_USERS:
      return "ALL_USERS";
    case ScoreRankUserType.ALL_MEMBERS:
      return "ALL_MEMBERS";
    case ScoreRankUserType.SQUARE_MEMBERS:
      return "SQUARE_MEMBERS";
    case ScoreRankUserType.SQUARE_USERS:
      return "SQUARE_USERS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ScoreRankUserType");
  }
}

export enum ScoreRankTimePeriod {
  /** SCORE_RANK_TIME_PERIOD_UNSPECIFIED - default value. this value is unused. */
  SCORE_RANK_TIME_PERIOD_UNSPECIFIED = 0,
  ALL_TIME = 1,
  WEEKLY = 2,
  WEEKLY_FULL_WEEK_BASED = 21,
  MONTHLY_FULL_WEEK_BASED = 31,
}

export function scoreRankTimePeriodFromJSON(object: any): ScoreRankTimePeriod {
  switch (object) {
    case 0:
    case "SCORE_RANK_TIME_PERIOD_UNSPECIFIED":
      return ScoreRankTimePeriod.SCORE_RANK_TIME_PERIOD_UNSPECIFIED;
    case 1:
    case "ALL_TIME":
      return ScoreRankTimePeriod.ALL_TIME;
    case 2:
    case "WEEKLY":
      return ScoreRankTimePeriod.WEEKLY;
    case 21:
    case "WEEKLY_FULL_WEEK_BASED":
      return ScoreRankTimePeriod.WEEKLY_FULL_WEEK_BASED;
    case 31:
    case "MONTHLY_FULL_WEEK_BASED":
      return ScoreRankTimePeriod.MONTHLY_FULL_WEEK_BASED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ScoreRankTimePeriod");
  }
}

export function scoreRankTimePeriodToJSON(object: ScoreRankTimePeriod): string {
  switch (object) {
    case ScoreRankTimePeriod.SCORE_RANK_TIME_PERIOD_UNSPECIFIED:
      return "SCORE_RANK_TIME_PERIOD_UNSPECIFIED";
    case ScoreRankTimePeriod.ALL_TIME:
      return "ALL_TIME";
    case ScoreRankTimePeriod.WEEKLY:
      return "WEEKLY";
    case ScoreRankTimePeriod.WEEKLY_FULL_WEEK_BASED:
      return "WEEKLY_FULL_WEEK_BASED";
    case ScoreRankTimePeriod.MONTHLY_FULL_WEEK_BASED:
      return "MONTHLY_FULL_WEEK_BASED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ScoreRankTimePeriod");
  }
}

export enum ScoreRankScoreType {
  /** SCORE_RANK_SCORE_TYPE_UNSPECIFIED - default value. this value is unused. */
  SCORE_RANK_SCORE_TYPE_UNSPECIFIED = 0,
  BEST_SCORE = 1,
  CUMULATIVE_SCORE = 2,
}

export function scoreRankScoreTypeFromJSON(object: any): ScoreRankScoreType {
  switch (object) {
    case 0:
    case "SCORE_RANK_SCORE_TYPE_UNSPECIFIED":
      return ScoreRankScoreType.SCORE_RANK_SCORE_TYPE_UNSPECIFIED;
    case 1:
    case "BEST_SCORE":
      return ScoreRankScoreType.BEST_SCORE;
    case 2:
    case "CUMULATIVE_SCORE":
      return ScoreRankScoreType.CUMULATIVE_SCORE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ScoreRankScoreType");
  }
}

export function scoreRankScoreTypeToJSON(object: ScoreRankScoreType): string {
  switch (object) {
    case ScoreRankScoreType.SCORE_RANK_SCORE_TYPE_UNSPECIFIED:
      return "SCORE_RANK_SCORE_TYPE_UNSPECIFIED";
    case ScoreRankScoreType.BEST_SCORE:
      return "BEST_SCORE";
    case ScoreRankScoreType.CUMULATIVE_SCORE:
      return "CUMULATIVE_SCORE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ScoreRankScoreType");
  }
}

export enum ScoreRankEntitiyType {
  /** SCORE_RANK_ENTITY_TYPE_UNSPECIFIED - default value. this value is unused. */
  SCORE_RANK_ENTITY_TYPE_UNSPECIFIED = 0,
  USER = 1,
  SQUARE = 2,
}

export function scoreRankEntitiyTypeFromJSON(object: any): ScoreRankEntitiyType {
  switch (object) {
    case 0:
    case "SCORE_RANK_ENTITY_TYPE_UNSPECIFIED":
      return ScoreRankEntitiyType.SCORE_RANK_ENTITY_TYPE_UNSPECIFIED;
    case 1:
    case "USER":
      return ScoreRankEntitiyType.USER;
    case 2:
    case "SQUARE":
      return ScoreRankEntitiyType.SQUARE;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ScoreRankEntitiyType");
  }
}

export function scoreRankEntitiyTypeToJSON(object: ScoreRankEntitiyType): string {
  switch (object) {
    case ScoreRankEntitiyType.SCORE_RANK_ENTITY_TYPE_UNSPECIFIED:
      return "SCORE_RANK_ENTITY_TYPE_UNSPECIFIED";
    case ScoreRankEntitiyType.USER:
      return "USER";
    case ScoreRankEntitiyType.SQUARE:
      return "SQUARE";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum ScoreRankEntitiyType");
  }
}

/** RewardRequest */
export interface RewardRequest {
  /** type */
  type: RewardRequest_RewardType;
}

/** RewardType */
export enum RewardRequest_RewardType {
  /** REWARD_TYPE_UNSPECIFIED - default value. */
  REWARD_TYPE_UNSPECIFIED = 0,
  WEEKLY_ALL_USERS_LEADERBOARD = 1,
  WEEKLY_SQUARE_MEMBERS_LEADERBOARD = 2,
  WEEKLY_SS_CHALLENGE = 3,
  MONTHLY_SS_CHALLENGE = 4,
  MONTHLY_SQUARE_COMPETITION = 5,
}

export function rewardRequest_RewardTypeFromJSON(object: any): RewardRequest_RewardType {
  switch (object) {
    case 0:
    case "REWARD_TYPE_UNSPECIFIED":
      return RewardRequest_RewardType.REWARD_TYPE_UNSPECIFIED;
    case 1:
    case "WEEKLY_ALL_USERS_LEADERBOARD":
      return RewardRequest_RewardType.WEEKLY_ALL_USERS_LEADERBOARD;
    case 2:
    case "WEEKLY_SQUARE_MEMBERS_LEADERBOARD":
      return RewardRequest_RewardType.WEEKLY_SQUARE_MEMBERS_LEADERBOARD;
    case 3:
    case "WEEKLY_SS_CHALLENGE":
      return RewardRequest_RewardType.WEEKLY_SS_CHALLENGE;
    case 4:
    case "MONTHLY_SS_CHALLENGE":
      return RewardRequest_RewardType.MONTHLY_SS_CHALLENGE;
    case 5:
    case "MONTHLY_SQUARE_COMPETITION":
      return RewardRequest_RewardType.MONTHLY_SQUARE_COMPETITION;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RewardRequest_RewardType");
  }
}

export function rewardRequest_RewardTypeToJSON(object: RewardRequest_RewardType): string {
  switch (object) {
    case RewardRequest_RewardType.REWARD_TYPE_UNSPECIFIED:
      return "REWARD_TYPE_UNSPECIFIED";
    case RewardRequest_RewardType.WEEKLY_ALL_USERS_LEADERBOARD:
      return "WEEKLY_ALL_USERS_LEADERBOARD";
    case RewardRequest_RewardType.WEEKLY_SQUARE_MEMBERS_LEADERBOARD:
      return "WEEKLY_SQUARE_MEMBERS_LEADERBOARD";
    case RewardRequest_RewardType.WEEKLY_SS_CHALLENGE:
      return "WEEKLY_SS_CHALLENGE";
    case RewardRequest_RewardType.MONTHLY_SS_CHALLENGE:
      return "MONTHLY_SS_CHALLENGE";
    case RewardRequest_RewardType.MONTHLY_SQUARE_COMPETITION:
      return "MONTHLY_SQUARE_COMPETITION";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RewardRequest_RewardType");
  }
}

/** RewardResponse */
export interface RewardResponse {
  /** user rewards */
  userRewards: RewardResponse_UserReward[];
}

/** user reward */
export interface RewardResponse_UserReward {
  /** user address */
  userAddress: string;
  /** spacebar points */
  points:
    | Decimal
    | undefined;
  /** blast points */
  blastPoints:
    | Decimal
    | undefined;
  /** blast gold */
  blastGold: Decimal | undefined;
}

export interface ValidateUploadScoreAndSignRequest {
  /**
   * The name of the score to create.
   * Format: users/{user_address}/scores/{game_id}
   */
  score: string;
  nonce: string;
}

export interface ValidateUploadScoreAndSignResponse {
  signature: string;
  params: UploadScoreParams | undefined;
}

/** CreateScoreRequest */
export interface CreateScoreRequest {
  /**
   * The name of the score to create.
   * Format: users/{user_address}/scores/{game_id}
   */
  name: string;
  /** score to create */
  score: Score | undefined;
}

export interface GetScoreRequest {
  /**
   * The name of the score to retrieve.
   * Format: users/{user_address}/scores/{game_id}
   */
  score: string;
}

export interface GetUserBestScoreRankingRequest {
  /**
   * The name of the score ranking to retrieve.
   * Format: rankings/bestScores/users/{user_address}
   */
  userBestScoreRanking: string;
  /** The user type of the ranking to retrieve. */
  userType: ScoreRankUserType;
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If rank type is one of ALL_MEMBERS, SQUARE_MEMBERS, the context should contain the square.
   * * snapshot_square="squares/{square_token_id}"
   * * snapshot_square_token_id="{square_token_id}"
   *
   * If rank type is ALL_USERS, the context should be empty.
   *
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   */
  context: string;
}

export interface ListUserBestScoreRankingsRequest {
  /** The user type of the ranking to retrieve. */
  userType: ScoreRankUserType;
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If rank type is one of ALL_MEMBERS, SQUARE_MEMBERS, the context should contain the square.
   * * snapshot_square="squares/{square_token_id}"
   * * snapshot_square_token_id="{square_token_id}"
   *
   * If rank type is ALL_USERS, the context should be empty.
   *
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   */
  context: string;
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPoints` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListUserBestScoreRankingsResponse {
  /** The list of rows that matched the query. */
  rankings: UserBestScoreRanking[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface GetUserCumulativeScoreRankingRequest {
  /**
   * The name of the score ranking to retrieve.
   * Format: rankings/cumulativeScores/users/{user_address}
   */
  userCumulativeScoreRanking: string;
  /** The type of ranking to retrieve. */
  userType: ScoreRankUserType;
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If rank type is one of ALL_MEMBERS, SQUARE_MEMBERS, the context should contain the square.
   * * snapshot_square="squares/{square_token_id}"
   * * snapshot_square_token_id="{square_token_id}"
   *
   * If rank type is ALL_USERS, the context should be empty.
   *
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   * If time period is WEEKLY_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_week="2024-08-W1"
   * If time period is MONTH_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_month="2024-08"
   */
  context: string;
}

export interface ListUserCumulativeScoreRankingsRequest {
  /** The type of ranking to retrieve. */
  userType: ScoreRankUserType;
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If rank type is one of ALL_MEMBERS, SQUARE_MEMBERS, the context should contain the square.
   * * snapshot_square="squares/{square_token_id}"
   * * snapshot_square_token_id="{square_token_id}"
   *
   * If rank type is ALL_USERS, the context should be empty.
   *
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   * If time period is WEEKLY_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_week="2024-08-W1"
   * If time period is MONTH_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_month="2024-08"
   */
  context: string;
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPoints` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListUserCumulativeScoreRankingsResponse {
  /** The list of rows that matched the query. */
  rankings: UserCumulativeScoreRanking[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface GetSquareCumulativeScoreRankingRequest {
  /**
   * The name of the score ranking to retrieve.
   * Format: rankings/cumulativeScores/squares/{square_address}
   */
  squareCumulativeScoreRanking: string;
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   * If time period is WEEKLY_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_week="2024-08-W1"
   * If time period is MONTH_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_month="2024-08"
   */
  context?: string | undefined;
}

export interface ListSquareCumulativeScoreRankingsRequest {
  /** The type of ranking to retrieve. */
  timePeriod: ScoreRankTimePeriod;
  /**
   * The context needed to get the ranking according to the rank type.
   * If time period is WEEKLY, the week can be set. If not set, the current week will be used.
   * * week=10
   * If time period is WEEKLY_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_week="2024-08-W1"
   * If time period is MONTH_FULL_WEEK_BASED, the week can be set.
   * * full_week_based_month="2024-08"
   */
  context?:
    | string
    | undefined;
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPoints` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListSquareCumulativeScoreRankingsResponse {
  /** The list of rows that matched the query. */
  rankings: SquareCumulativeScoreRanking[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface InvalidateScoreRankingsByUserRequest {
  /**
   * The name of the score ranking to invalidate.
   * Format: users/{user_address}
   */
  users: string[];
  /**
   * The context needed to decumulate the ranking according to the rank type.
   * Context for square is always required.
   * * snapshot_square="squares/{square_token_id}"
   * * snapshot_square_token_id="{square_token_id}"
   * Context for week is optional. If not set, the current week will be used.
   * * week=10
   * Context for full week based week is optional. If not set, the current date will be used.
   * * full_week_based_week="2024-08-W1"
   * Context for full week based month is optional. If not set, the current date will be used.
   * * full_week_based_month="2024-08"
   */
  context: string;
}

export interface Score {
  /**
   * The resource name of the Score.
   * Format: "users/{user_address}/scores/{game_id}"
   */
  name: string;
  /** The user address of the member. */
  userAddress: string;
  /** The game ID of the Score. */
  gameId: string;
  /** created time of score */
  createTime: string | undefined;
  state: ScoreState;
  /** points got from game */
  points: number;
  /** Game mode of score. */
  gameType: GameType;
  /** Play mode of score. */
  playMode: PlayMode;
  /** week of score */
  week: number;
  /**
   * The snapshot square token ID of the Score.
   * This field can be null if the score is not related to any square.
   */
  snapshotSquareTokenId?:
    | string
    | undefined;
  /** Thie field is internal use only. */
  blastGold?: number | undefined;
}

export interface UserBestScoreRanking {
  rank: number;
  userType: ScoreRankUserType;
  timePeriod: ScoreRankTimePeriod;
  score: Score | undefined;
}

export interface UserCumulativeScoreRanking {
  rank: number;
  userType: ScoreRankUserType;
  timePeriod: ScoreRankTimePeriod;
  userAddress: string;
  totalPoints: number;
}

export interface SquareCumulativeScoreRanking {
  rank: number;
  timePeriod: ScoreRankTimePeriod;
  squareTokenId: string;
  totalPoints: number;
  pointsCount: number;
  participantsCount: number;
}

function createBaseRewardRequest(): RewardRequest {
  return { type: 0 };
}

export const RewardRequest = {
  encode(message: RewardRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RewardRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RewardRequest {
    return { type: isSet(object.type) ? rewardRequest_RewardTypeFromJSON(object.type) : 0 };
  },

  toJSON(message: RewardRequest): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = rewardRequest_RewardTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RewardRequest>, I>>(base?: I): RewardRequest {
    return RewardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RewardRequest>, I>>(object: I): RewardRequest {
    const message = createBaseRewardRequest();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseRewardResponse(): RewardResponse {
  return { userRewards: [] };
}

export const RewardResponse = {
  encode(message: RewardResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.userRewards) {
      RewardResponse_UserReward.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RewardResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userRewards.push(RewardResponse_UserReward.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RewardResponse {
    return {
      userRewards: globalThis.Array.isArray(object?.userRewards)
        ? object.userRewards.map((e: any) => RewardResponse_UserReward.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RewardResponse): unknown {
    const obj: any = {};
    if (message.userRewards?.length) {
      obj.userRewards = message.userRewards.map((e) => RewardResponse_UserReward.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RewardResponse>, I>>(base?: I): RewardResponse {
    return RewardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RewardResponse>, I>>(object: I): RewardResponse {
    const message = createBaseRewardResponse();
    message.userRewards = object.userRewards?.map((e) => RewardResponse_UserReward.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRewardResponse_UserReward(): RewardResponse_UserReward {
  return { userAddress: "", points: undefined, blastPoints: undefined, blastGold: undefined };
}

export const RewardResponse_UserReward = {
  encode(message: RewardResponse_UserReward, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userAddress !== "") {
      writer.uint32(10).string(message.userAddress);
    }
    if (message.points !== undefined) {
      Decimal.encode(message.points, writer.uint32(18).fork()).ldelim();
    }
    if (message.blastPoints !== undefined) {
      Decimal.encode(message.blastPoints, writer.uint32(26).fork()).ldelim();
    }
    if (message.blastGold !== undefined) {
      Decimal.encode(message.blastGold, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RewardResponse_UserReward {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardResponse_UserReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.points = Decimal.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blastPoints = Decimal.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blastGold = Decimal.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RewardResponse_UserReward {
    return {
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      points: isSet(object.points) ? Decimal.fromJSON(object.points) : undefined,
      blastPoints: isSet(object.blastPoints) ? Decimal.fromJSON(object.blastPoints) : undefined,
      blastGold: isSet(object.blastGold) ? Decimal.fromJSON(object.blastGold) : undefined,
    };
  },

  toJSON(message: RewardResponse_UserReward): unknown {
    const obj: any = {};
    if (message.userAddress !== undefined) {
      obj.userAddress = message.userAddress;
    }
    if (message.points !== undefined) {
      obj.points = Decimal.toJSON(message.points);
    }
    if (message.blastPoints !== undefined) {
      obj.blastPoints = Decimal.toJSON(message.blastPoints);
    }
    if (message.blastGold !== undefined) {
      obj.blastGold = Decimal.toJSON(message.blastGold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RewardResponse_UserReward>, I>>(base?: I): RewardResponse_UserReward {
    return RewardResponse_UserReward.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RewardResponse_UserReward>, I>>(object: I): RewardResponse_UserReward {
    const message = createBaseRewardResponse_UserReward();
    message.userAddress = object.userAddress ?? "";
    message.points = (object.points !== undefined && object.points !== null)
      ? Decimal.fromPartial(object.points)
      : undefined;
    message.blastPoints = (object.blastPoints !== undefined && object.blastPoints !== null)
      ? Decimal.fromPartial(object.blastPoints)
      : undefined;
    message.blastGold = (object.blastGold !== undefined && object.blastGold !== null)
      ? Decimal.fromPartial(object.blastGold)
      : undefined;
    return message;
  },
};

function createBaseValidateUploadScoreAndSignRequest(): ValidateUploadScoreAndSignRequest {
  return { score: "", nonce: "" };
}

export const ValidateUploadScoreAndSignRequest = {
  encode(message: ValidateUploadScoreAndSignRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.score !== "") {
      writer.uint32(10).string(message.score);
    }
    if (message.nonce !== "") {
      writer.uint32(18).string(message.nonce);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateUploadScoreAndSignRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateUploadScoreAndSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.score = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nonce = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateUploadScoreAndSignRequest {
    return {
      score: isSet(object.score) ? globalThis.String(object.score) : "",
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
    };
  },

  toJSON(message: ValidateUploadScoreAndSignRequest): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.nonce !== undefined) {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateUploadScoreAndSignRequest>, I>>(
    base?: I,
  ): ValidateUploadScoreAndSignRequest {
    return ValidateUploadScoreAndSignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateUploadScoreAndSignRequest>, I>>(
    object: I,
  ): ValidateUploadScoreAndSignRequest {
    const message = createBaseValidateUploadScoreAndSignRequest();
    message.score = object.score ?? "";
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseValidateUploadScoreAndSignResponse(): ValidateUploadScoreAndSignResponse {
  return { signature: "", params: undefined };
}

export const ValidateUploadScoreAndSignResponse = {
  encode(message: ValidateUploadScoreAndSignResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    if (message.params !== undefined) {
      UploadScoreParams.encode(message.params, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateUploadScoreAndSignResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateUploadScoreAndSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.params = UploadScoreParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateUploadScoreAndSignResponse {
    return {
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      params: isSet(object.params) ? UploadScoreParams.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: ValidateUploadScoreAndSignResponse): unknown {
    const obj: any = {};
    if (message.signature !== undefined) {
      obj.signature = message.signature;
    }
    if (message.params !== undefined) {
      obj.params = UploadScoreParams.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateUploadScoreAndSignResponse>, I>>(
    base?: I,
  ): ValidateUploadScoreAndSignResponse {
    return ValidateUploadScoreAndSignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateUploadScoreAndSignResponse>, I>>(
    object: I,
  ): ValidateUploadScoreAndSignResponse {
    const message = createBaseValidateUploadScoreAndSignResponse();
    message.signature = object.signature ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? UploadScoreParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseCreateScoreRequest(): CreateScoreRequest {
  return { name: "", score: undefined };
}

export const CreateScoreRequest = {
  encode(message: CreateScoreRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.score !== undefined) {
      Score.encode(message.score, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateScoreRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.score = Score.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateScoreRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      score: isSet(object.score) ? Score.fromJSON(object.score) : undefined,
    };
  },

  toJSON(message: CreateScoreRequest): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.score !== undefined) {
      obj.score = Score.toJSON(message.score);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateScoreRequest>, I>>(base?: I): CreateScoreRequest {
    return CreateScoreRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateScoreRequest>, I>>(object: I): CreateScoreRequest {
    const message = createBaseCreateScoreRequest();
    message.name = object.name ?? "";
    message.score = (object.score !== undefined && object.score !== null) ? Score.fromPartial(object.score) : undefined;
    return message;
  },
};

function createBaseGetScoreRequest(): GetScoreRequest {
  return { score: "" };
}

export const GetScoreRequest = {
  encode(message: GetScoreRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.score !== "") {
      writer.uint32(10).string(message.score);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetScoreRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.score = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetScoreRequest {
    return { score: isSet(object.score) ? globalThis.String(object.score) : "" };
  },

  toJSON(message: GetScoreRequest): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetScoreRequest>, I>>(base?: I): GetScoreRequest {
    return GetScoreRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetScoreRequest>, I>>(object: I): GetScoreRequest {
    const message = createBaseGetScoreRequest();
    message.score = object.score ?? "";
    return message;
  },
};

function createBaseGetUserBestScoreRankingRequest(): GetUserBestScoreRankingRequest {
  return { userBestScoreRanking: "", userType: 0, timePeriod: 0, context: "" };
}

export const GetUserBestScoreRankingRequest = {
  encode(message: GetUserBestScoreRankingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userBestScoreRanking !== "") {
      writer.uint32(10).string(message.userBestScoreRanking);
    }
    if (message.userType !== 0) {
      writer.uint32(16).int32(message.userType);
    }
    if (message.timePeriod !== 0) {
      writer.uint32(24).int32(message.timePeriod);
    }
    if (message.context !== "") {
      writer.uint32(34).string(message.context);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserBestScoreRankingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserBestScoreRankingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userBestScoreRanking = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timePeriod = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.context = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserBestScoreRankingRequest {
    return {
      userBestScoreRanking: isSet(object.userBestScoreRanking) ? globalThis.String(object.userBestScoreRanking) : "",
      userType: isSet(object.userType) ? scoreRankUserTypeFromJSON(object.userType) : 0,
      timePeriod: isSet(object.timePeriod) ? scoreRankTimePeriodFromJSON(object.timePeriod) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: GetUserBestScoreRankingRequest): unknown {
    const obj: any = {};
    if (message.userBestScoreRanking !== undefined) {
      obj.userBestScoreRanking = message.userBestScoreRanking;
    }
    if (message.userType !== undefined) {
      obj.userType = scoreRankUserTypeToJSON(message.userType);
    }
    if (message.timePeriod !== undefined) {
      obj.timePeriod = scoreRankTimePeriodToJSON(message.timePeriod);
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserBestScoreRankingRequest>, I>>(base?: I): GetUserBestScoreRankingRequest {
    return GetUserBestScoreRankingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserBestScoreRankingRequest>, I>>(
    object: I,
  ): GetUserBestScoreRankingRequest {
    const message = createBaseGetUserBestScoreRankingRequest();
    message.userBestScoreRanking = object.userBestScoreRanking ?? "";
    message.userType = object.userType ?? 0;
    message.timePeriod = object.timePeriod ?? 0;
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseListUserBestScoreRankingsRequest(): ListUserBestScoreRankingsRequest {
  return { userType: 0, timePeriod: 0, context: "", pageSize: 0, pageToken: "" };
}

export const ListUserBestScoreRankingsRequest = {
  encode(message: ListUserBestScoreRankingsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userType !== 0) {
      writer.uint32(8).int32(message.userType);
    }
    if (message.timePeriod !== 0) {
      writer.uint32(16).int32(message.timePeriod);
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUserBestScoreRankingsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserBestScoreRankingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timePeriod = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserBestScoreRankingsRequest {
    return {
      userType: isSet(object.userType) ? scoreRankUserTypeFromJSON(object.userType) : 0,
      timePeriod: isSet(object.timePeriod) ? scoreRankTimePeriodFromJSON(object.timePeriod) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListUserBestScoreRankingsRequest): unknown {
    const obj: any = {};
    if (message.userType !== undefined) {
      obj.userType = scoreRankUserTypeToJSON(message.userType);
    }
    if (message.timePeriod !== undefined) {
      obj.timePeriod = scoreRankTimePeriodToJSON(message.timePeriod);
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserBestScoreRankingsRequest>, I>>(
    base?: I,
  ): ListUserBestScoreRankingsRequest {
    return ListUserBestScoreRankingsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserBestScoreRankingsRequest>, I>>(
    object: I,
  ): ListUserBestScoreRankingsRequest {
    const message = createBaseListUserBestScoreRankingsRequest();
    message.userType = object.userType ?? 0;
    message.timePeriod = object.timePeriod ?? 0;
    message.context = object.context ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListUserBestScoreRankingsResponse(): ListUserBestScoreRankingsResponse {
  return { rankings: [], nextPageToken: "" };
}

export const ListUserBestScoreRankingsResponse = {
  encode(message: ListUserBestScoreRankingsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rankings) {
      UserBestScoreRanking.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUserBestScoreRankingsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserBestScoreRankingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rankings.push(UserBestScoreRanking.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserBestScoreRankingsResponse {
    return {
      rankings: globalThis.Array.isArray(object?.rankings)
        ? object.rankings.map((e: any) => UserBestScoreRanking.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListUserBestScoreRankingsResponse): unknown {
    const obj: any = {};
    if (message.rankings?.length) {
      obj.rankings = message.rankings.map((e) => UserBestScoreRanking.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserBestScoreRankingsResponse>, I>>(
    base?: I,
  ): ListUserBestScoreRankingsResponse {
    return ListUserBestScoreRankingsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserBestScoreRankingsResponse>, I>>(
    object: I,
  ): ListUserBestScoreRankingsResponse {
    const message = createBaseListUserBestScoreRankingsResponse();
    message.rankings = object.rankings?.map((e) => UserBestScoreRanking.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetUserCumulativeScoreRankingRequest(): GetUserCumulativeScoreRankingRequest {
  return { userCumulativeScoreRanking: "", userType: 0, timePeriod: 0, context: "" };
}

export const GetUserCumulativeScoreRankingRequest = {
  encode(message: GetUserCumulativeScoreRankingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userCumulativeScoreRanking !== "") {
      writer.uint32(10).string(message.userCumulativeScoreRanking);
    }
    if (message.userType !== 0) {
      writer.uint32(16).int32(message.userType);
    }
    if (message.timePeriod !== 0) {
      writer.uint32(24).int32(message.timePeriod);
    }
    if (message.context !== "") {
      writer.uint32(34).string(message.context);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserCumulativeScoreRankingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserCumulativeScoreRankingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userCumulativeScoreRanking = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timePeriod = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.context = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserCumulativeScoreRankingRequest {
    return {
      userCumulativeScoreRanking: isSet(object.userCumulativeScoreRanking)
        ? globalThis.String(object.userCumulativeScoreRanking)
        : "",
      userType: isSet(object.userType) ? scoreRankUserTypeFromJSON(object.userType) : 0,
      timePeriod: isSet(object.timePeriod) ? scoreRankTimePeriodFromJSON(object.timePeriod) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: GetUserCumulativeScoreRankingRequest): unknown {
    const obj: any = {};
    if (message.userCumulativeScoreRanking !== undefined) {
      obj.userCumulativeScoreRanking = message.userCumulativeScoreRanking;
    }
    if (message.userType !== undefined) {
      obj.userType = scoreRankUserTypeToJSON(message.userType);
    }
    if (message.timePeriod !== undefined) {
      obj.timePeriod = scoreRankTimePeriodToJSON(message.timePeriod);
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserCumulativeScoreRankingRequest>, I>>(
    base?: I,
  ): GetUserCumulativeScoreRankingRequest {
    return GetUserCumulativeScoreRankingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserCumulativeScoreRankingRequest>, I>>(
    object: I,
  ): GetUserCumulativeScoreRankingRequest {
    const message = createBaseGetUserCumulativeScoreRankingRequest();
    message.userCumulativeScoreRanking = object.userCumulativeScoreRanking ?? "";
    message.userType = object.userType ?? 0;
    message.timePeriod = object.timePeriod ?? 0;
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseListUserCumulativeScoreRankingsRequest(): ListUserCumulativeScoreRankingsRequest {
  return { userType: 0, timePeriod: 0, context: "", pageSize: 0, pageToken: "" };
}

export const ListUserCumulativeScoreRankingsRequest = {
  encode(message: ListUserCumulativeScoreRankingsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userType !== 0) {
      writer.uint32(8).int32(message.userType);
    }
    if (message.timePeriod !== 0) {
      writer.uint32(16).int32(message.timePeriod);
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(42).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUserCumulativeScoreRankingsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserCumulativeScoreRankingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.userType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timePeriod = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserCumulativeScoreRankingsRequest {
    return {
      userType: isSet(object.userType) ? scoreRankUserTypeFromJSON(object.userType) : 0,
      timePeriod: isSet(object.timePeriod) ? scoreRankTimePeriodFromJSON(object.timePeriod) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListUserCumulativeScoreRankingsRequest): unknown {
    const obj: any = {};
    if (message.userType !== undefined) {
      obj.userType = scoreRankUserTypeToJSON(message.userType);
    }
    if (message.timePeriod !== undefined) {
      obj.timePeriod = scoreRankTimePeriodToJSON(message.timePeriod);
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserCumulativeScoreRankingsRequest>, I>>(
    base?: I,
  ): ListUserCumulativeScoreRankingsRequest {
    return ListUserCumulativeScoreRankingsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserCumulativeScoreRankingsRequest>, I>>(
    object: I,
  ): ListUserCumulativeScoreRankingsRequest {
    const message = createBaseListUserCumulativeScoreRankingsRequest();
    message.userType = object.userType ?? 0;
    message.timePeriod = object.timePeriod ?? 0;
    message.context = object.context ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListUserCumulativeScoreRankingsResponse(): ListUserCumulativeScoreRankingsResponse {
  return { rankings: [], nextPageToken: "" };
}

export const ListUserCumulativeScoreRankingsResponse = {
  encode(message: ListUserCumulativeScoreRankingsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rankings) {
      UserCumulativeScoreRanking.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUserCumulativeScoreRankingsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserCumulativeScoreRankingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rankings.push(UserCumulativeScoreRanking.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserCumulativeScoreRankingsResponse {
    return {
      rankings: globalThis.Array.isArray(object?.rankings)
        ? object.rankings.map((e: any) => UserCumulativeScoreRanking.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListUserCumulativeScoreRankingsResponse): unknown {
    const obj: any = {};
    if (message.rankings?.length) {
      obj.rankings = message.rankings.map((e) => UserCumulativeScoreRanking.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserCumulativeScoreRankingsResponse>, I>>(
    base?: I,
  ): ListUserCumulativeScoreRankingsResponse {
    return ListUserCumulativeScoreRankingsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserCumulativeScoreRankingsResponse>, I>>(
    object: I,
  ): ListUserCumulativeScoreRankingsResponse {
    const message = createBaseListUserCumulativeScoreRankingsResponse();
    message.rankings = object.rankings?.map((e) => UserCumulativeScoreRanking.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetSquareCumulativeScoreRankingRequest(): GetSquareCumulativeScoreRankingRequest {
  return { squareCumulativeScoreRanking: "", timePeriod: 0, context: undefined };
}

export const GetSquareCumulativeScoreRankingRequest = {
  encode(message: GetSquareCumulativeScoreRankingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.squareCumulativeScoreRanking !== "") {
      writer.uint32(10).string(message.squareCumulativeScoreRanking);
    }
    if (message.timePeriod !== 0) {
      writer.uint32(16).int32(message.timePeriod);
    }
    if (message.context !== undefined) {
      writer.uint32(26).string(message.context);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSquareCumulativeScoreRankingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSquareCumulativeScoreRankingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.squareCumulativeScoreRanking = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timePeriod = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSquareCumulativeScoreRankingRequest {
    return {
      squareCumulativeScoreRanking: isSet(object.squareCumulativeScoreRanking)
        ? globalThis.String(object.squareCumulativeScoreRanking)
        : "",
      timePeriod: isSet(object.timePeriod) ? scoreRankTimePeriodFromJSON(object.timePeriod) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
    };
  },

  toJSON(message: GetSquareCumulativeScoreRankingRequest): unknown {
    const obj: any = {};
    if (message.squareCumulativeScoreRanking !== undefined) {
      obj.squareCumulativeScoreRanking = message.squareCumulativeScoreRanking;
    }
    if (message.timePeriod !== undefined) {
      obj.timePeriod = scoreRankTimePeriodToJSON(message.timePeriod);
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSquareCumulativeScoreRankingRequest>, I>>(
    base?: I,
  ): GetSquareCumulativeScoreRankingRequest {
    return GetSquareCumulativeScoreRankingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSquareCumulativeScoreRankingRequest>, I>>(
    object: I,
  ): GetSquareCumulativeScoreRankingRequest {
    const message = createBaseGetSquareCumulativeScoreRankingRequest();
    message.squareCumulativeScoreRanking = object.squareCumulativeScoreRanking ?? "";
    message.timePeriod = object.timePeriod ?? 0;
    message.context = object.context ?? undefined;
    return message;
  },
};

function createBaseListSquareCumulativeScoreRankingsRequest(): ListSquareCumulativeScoreRankingsRequest {
  return { timePeriod: 0, context: undefined, pageSize: 0, pageToken: "" };
}

export const ListSquareCumulativeScoreRankingsRequest = {
  encode(message: ListSquareCumulativeScoreRankingsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.timePeriod !== 0) {
      writer.uint32(8).int32(message.timePeriod);
    }
    if (message.context !== undefined) {
      writer.uint32(18).string(message.context);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSquareCumulativeScoreRankingsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquareCumulativeScoreRankingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.timePeriod = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.context = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquareCumulativeScoreRankingsRequest {
    return {
      timePeriod: isSet(object.timePeriod) ? scoreRankTimePeriodFromJSON(object.timePeriod) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSquareCumulativeScoreRankingsRequest): unknown {
    const obj: any = {};
    if (message.timePeriod !== undefined) {
      obj.timePeriod = scoreRankTimePeriodToJSON(message.timePeriod);
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquareCumulativeScoreRankingsRequest>, I>>(
    base?: I,
  ): ListSquareCumulativeScoreRankingsRequest {
    return ListSquareCumulativeScoreRankingsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquareCumulativeScoreRankingsRequest>, I>>(
    object: I,
  ): ListSquareCumulativeScoreRankingsRequest {
    const message = createBaseListSquareCumulativeScoreRankingsRequest();
    message.timePeriod = object.timePeriod ?? 0;
    message.context = object.context ?? undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSquareCumulativeScoreRankingsResponse(): ListSquareCumulativeScoreRankingsResponse {
  return { rankings: [], nextPageToken: "" };
}

export const ListSquareCumulativeScoreRankingsResponse = {
  encode(message: ListSquareCumulativeScoreRankingsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rankings) {
      SquareCumulativeScoreRanking.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSquareCumulativeScoreRankingsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquareCumulativeScoreRankingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rankings.push(SquareCumulativeScoreRanking.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquareCumulativeScoreRankingsResponse {
    return {
      rankings: globalThis.Array.isArray(object?.rankings)
        ? object.rankings.map((e: any) => SquareCumulativeScoreRanking.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSquareCumulativeScoreRankingsResponse): unknown {
    const obj: any = {};
    if (message.rankings?.length) {
      obj.rankings = message.rankings.map((e) => SquareCumulativeScoreRanking.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquareCumulativeScoreRankingsResponse>, I>>(
    base?: I,
  ): ListSquareCumulativeScoreRankingsResponse {
    return ListSquareCumulativeScoreRankingsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquareCumulativeScoreRankingsResponse>, I>>(
    object: I,
  ): ListSquareCumulativeScoreRankingsResponse {
    const message = createBaseListSquareCumulativeScoreRankingsResponse();
    message.rankings = object.rankings?.map((e) => SquareCumulativeScoreRanking.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseInvalidateScoreRankingsByUserRequest(): InvalidateScoreRankingsByUserRequest {
  return { users: [], context: "" };
}

export const InvalidateScoreRankingsByUserRequest = {
  encode(message: InvalidateScoreRankingsByUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.users) {
      writer.uint32(10).string(v!);
    }
    if (message.context !== "") {
      writer.uint32(18).string(message.context);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvalidateScoreRankingsByUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidateScoreRankingsByUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.users.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.context = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvalidateScoreRankingsByUserRequest {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => globalThis.String(e)) : [],
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: InvalidateScoreRankingsByUserRequest): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvalidateScoreRankingsByUserRequest>, I>>(
    base?: I,
  ): InvalidateScoreRankingsByUserRequest {
    return InvalidateScoreRankingsByUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvalidateScoreRankingsByUserRequest>, I>>(
    object: I,
  ): InvalidateScoreRankingsByUserRequest {
    const message = createBaseInvalidateScoreRankingsByUserRequest();
    message.users = object.users?.map((e) => e) || [];
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseScore(): Score {
  return {
    name: "",
    userAddress: "",
    gameId: "",
    createTime: undefined,
    state: 0,
    points: 0,
    gameType: 0,
    playMode: 0,
    week: 0,
    snapshotSquareTokenId: undefined,
    blastGold: undefined,
  };
}

export const Score = {
  encode(message: Score, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.userAddress !== "") {
      writer.uint32(18).string(message.userAddress);
    }
    if (message.gameId !== "") {
      writer.uint32(26).string(message.gameId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.points !== 0) {
      writer.uint32(48).uint32(message.points);
    }
    if (message.gameType !== 0) {
      writer.uint32(64).int32(message.gameType);
    }
    if (message.playMode !== 0) {
      writer.uint32(72).int32(message.playMode);
    }
    if (message.week !== 0) {
      writer.uint32(80).uint32(message.week);
    }
    if (message.snapshotSquareTokenId !== undefined) {
      writer.uint32(90).string(message.snapshotSquareTokenId);
    }
    if (message.blastGold !== undefined) {
      writer.uint32(101).float(message.blastGold);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Score {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gameId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.points = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.gameType = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.playMode = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.week = reader.uint32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.snapshotSquareTokenId = reader.string();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.blastGold = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Score {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : "",
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      state: isSet(object.state) ? scoreStateFromJSON(object.state) : 0,
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
      gameType: isSet(object.gameType) ? gameTypeFromJSON(object.gameType) : 0,
      playMode: isSet(object.playMode) ? playModeFromJSON(object.playMode) : 0,
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
      snapshotSquareTokenId: isSet(object.snapshotSquareTokenId)
        ? globalThis.String(object.snapshotSquareTokenId)
        : undefined,
      blastGold: isSet(object.blastGold) ? globalThis.Number(object.blastGold) : undefined,
    };
  },

  toJSON(message: Score): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.userAddress !== undefined) {
      obj.userAddress = message.userAddress;
    }
    if (message.gameId !== undefined) {
      obj.gameId = message.gameId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.state !== undefined) {
      obj.state = scoreStateToJSON(message.state);
    }
    if (message.points !== undefined) {
      obj.points = Math.round(message.points);
    }
    if (message.gameType !== undefined) {
      obj.gameType = gameTypeToJSON(message.gameType);
    }
    if (message.playMode !== undefined) {
      obj.playMode = playModeToJSON(message.playMode);
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    if (message.snapshotSquareTokenId !== undefined) {
      obj.snapshotSquareTokenId = message.snapshotSquareTokenId;
    }
    if (message.blastGold !== undefined) {
      obj.blastGold = message.blastGold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Score>, I>>(base?: I): Score {
    return Score.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Score>, I>>(object: I): Score {
    const message = createBaseScore();
    message.name = object.name ?? "";
    message.userAddress = object.userAddress ?? "";
    message.gameId = object.gameId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.state = object.state ?? 0;
    message.points = object.points ?? 0;
    message.gameType = object.gameType ?? 0;
    message.playMode = object.playMode ?? 0;
    message.week = object.week ?? 0;
    message.snapshotSquareTokenId = object.snapshotSquareTokenId ?? undefined;
    message.blastGold = object.blastGold ?? undefined;
    return message;
  },
};

function createBaseUserBestScoreRanking(): UserBestScoreRanking {
  return { rank: 0, userType: 0, timePeriod: 0, score: undefined };
}

export const UserBestScoreRanking = {
  encode(message: UserBestScoreRanking, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.userType !== 0) {
      writer.uint32(16).int32(message.userType);
    }
    if (message.timePeriod !== 0) {
      writer.uint32(24).int32(message.timePeriod);
    }
    if (message.score !== undefined) {
      Score.encode(message.score, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserBestScoreRanking {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserBestScoreRanking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timePeriod = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.score = Score.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserBestScoreRanking {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      userType: isSet(object.userType) ? scoreRankUserTypeFromJSON(object.userType) : 0,
      timePeriod: isSet(object.timePeriod) ? scoreRankTimePeriodFromJSON(object.timePeriod) : 0,
      score: isSet(object.score) ? Score.fromJSON(object.score) : undefined,
    };
  },

  toJSON(message: UserBestScoreRanking): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.userType !== undefined) {
      obj.userType = scoreRankUserTypeToJSON(message.userType);
    }
    if (message.timePeriod !== undefined) {
      obj.timePeriod = scoreRankTimePeriodToJSON(message.timePeriod);
    }
    if (message.score !== undefined) {
      obj.score = Score.toJSON(message.score);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserBestScoreRanking>, I>>(base?: I): UserBestScoreRanking {
    return UserBestScoreRanking.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserBestScoreRanking>, I>>(object: I): UserBestScoreRanking {
    const message = createBaseUserBestScoreRanking();
    message.rank = object.rank ?? 0;
    message.userType = object.userType ?? 0;
    message.timePeriod = object.timePeriod ?? 0;
    message.score = (object.score !== undefined && object.score !== null) ? Score.fromPartial(object.score) : undefined;
    return message;
  },
};

function createBaseUserCumulativeScoreRanking(): UserCumulativeScoreRanking {
  return { rank: 0, userType: 0, timePeriod: 0, userAddress: "", totalPoints: 0 };
}

export const UserCumulativeScoreRanking = {
  encode(message: UserCumulativeScoreRanking, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.userType !== 0) {
      writer.uint32(16).int32(message.userType);
    }
    if (message.timePeriod !== 0) {
      writer.uint32(24).int32(message.timePeriod);
    }
    if (message.userAddress !== "") {
      writer.uint32(42).string(message.userAddress);
    }
    if (message.totalPoints !== 0) {
      writer.uint32(48).uint64(message.totalPoints);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserCumulativeScoreRanking {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCumulativeScoreRanking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timePeriod = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalPoints = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserCumulativeScoreRanking {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      userType: isSet(object.userType) ? scoreRankUserTypeFromJSON(object.userType) : 0,
      timePeriod: isSet(object.timePeriod) ? scoreRankTimePeriodFromJSON(object.timePeriod) : 0,
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
    };
  },

  toJSON(message: UserCumulativeScoreRanking): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.userType !== undefined) {
      obj.userType = scoreRankUserTypeToJSON(message.userType);
    }
    if (message.timePeriod !== undefined) {
      obj.timePeriod = scoreRankTimePeriodToJSON(message.timePeriod);
    }
    if (message.userAddress !== undefined) {
      obj.userAddress = message.userAddress;
    }
    if (message.totalPoints !== undefined) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserCumulativeScoreRanking>, I>>(base?: I): UserCumulativeScoreRanking {
    return UserCumulativeScoreRanking.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserCumulativeScoreRanking>, I>>(object: I): UserCumulativeScoreRanking {
    const message = createBaseUserCumulativeScoreRanking();
    message.rank = object.rank ?? 0;
    message.userType = object.userType ?? 0;
    message.timePeriod = object.timePeriod ?? 0;
    message.userAddress = object.userAddress ?? "";
    message.totalPoints = object.totalPoints ?? 0;
    return message;
  },
};

function createBaseSquareCumulativeScoreRanking(): SquareCumulativeScoreRanking {
  return { rank: 0, timePeriod: 0, squareTokenId: "", totalPoints: 0, pointsCount: 0, participantsCount: 0 };
}

export const SquareCumulativeScoreRanking = {
  encode(message: SquareCumulativeScoreRanking, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.timePeriod !== 0) {
      writer.uint32(16).int32(message.timePeriod);
    }
    if (message.squareTokenId !== "") {
      writer.uint32(42).string(message.squareTokenId);
    }
    if (message.totalPoints !== 0) {
      writer.uint32(48).uint64(message.totalPoints);
    }
    if (message.pointsCount !== 0) {
      writer.uint32(56).uint32(message.pointsCount);
    }
    if (message.participantsCount !== 0) {
      writer.uint32(64).uint32(message.participantsCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SquareCumulativeScoreRanking {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSquareCumulativeScoreRanking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timePeriod = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.squareTokenId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalPoints = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.pointsCount = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.participantsCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SquareCumulativeScoreRanking {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      timePeriod: isSet(object.timePeriod) ? scoreRankTimePeriodFromJSON(object.timePeriod) : 0,
      squareTokenId: isSet(object.squareTokenId) ? globalThis.String(object.squareTokenId) : "",
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
      pointsCount: isSet(object.pointsCount) ? globalThis.Number(object.pointsCount) : 0,
      participantsCount: isSet(object.participantsCount) ? globalThis.Number(object.participantsCount) : 0,
    };
  },

  toJSON(message: SquareCumulativeScoreRanking): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.timePeriod !== undefined) {
      obj.timePeriod = scoreRankTimePeriodToJSON(message.timePeriod);
    }
    if (message.squareTokenId !== undefined) {
      obj.squareTokenId = message.squareTokenId;
    }
    if (message.totalPoints !== undefined) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    if (message.pointsCount !== undefined) {
      obj.pointsCount = Math.round(message.pointsCount);
    }
    if (message.participantsCount !== undefined) {
      obj.participantsCount = Math.round(message.participantsCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SquareCumulativeScoreRanking>, I>>(base?: I): SquareCumulativeScoreRanking {
    return SquareCumulativeScoreRanking.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SquareCumulativeScoreRanking>, I>>(object: I): SquareCumulativeScoreRanking {
    const message = createBaseSquareCumulativeScoreRanking();
    message.rank = object.rank ?? 0;
    message.timePeriod = object.timePeriod ?? 0;
    message.squareTokenId = object.squareTokenId ?? "";
    message.totalPoints = object.totalPoints ?? 0;
    message.pointsCount = object.pointsCount ?? 0;
    message.participantsCount = object.participantsCount ?? 0;
    return message;
  },
};

/** ScoreService contains the function to interact with the Score of the spacebar */
export interface ScoreService {
  /** ValidateUploadScoreAndSign validate the upload score and then return signatrue if valid */
  ValidateUploadScoreAndSign(request: ValidateUploadScoreAndSignRequest): Promise<ValidateUploadScoreAndSignResponse>;
  /** CreateScore create Score with Score */
  CreateScore(request: CreateScoreRequest): Promise<Score>;
  /** GetScore */
  GetScore(request: GetScoreRequest): Promise<Score>;
  /** GetUserBestScoreRanking */
  GetUserBestScoreRanking(request: GetUserBestScoreRankingRequest): Promise<UserBestScoreRanking>;
  /** ListUserBestScoreRankings */
  ListUserBestScoreRankings(request: ListUserBestScoreRankingsRequest): Promise<ListUserBestScoreRankingsResponse>;
  /** GetUserCumulativeScoreRanking */
  GetUserCumulativeScoreRanking(request: GetUserCumulativeScoreRankingRequest): Promise<UserCumulativeScoreRanking>;
  /** ListUserCumulativeScoreRankings */
  ListUserCumulativeScoreRankings(
    request: ListUserCumulativeScoreRankingsRequest,
  ): Promise<ListUserCumulativeScoreRankingsResponse>;
  /** GetSquareCumulativeScoreRanking */
  GetSquareCumulativeScoreRanking(
    request: GetSquareCumulativeScoreRankingRequest,
  ): Promise<SquareCumulativeScoreRanking>;
  /** ListSquareCumulativeScoreRankings */
  ListSquareCumulativeScoreRankings(
    request: ListSquareCumulativeScoreRankingsRequest,
  ): Promise<ListSquareCumulativeScoreRankingsResponse>;
  /** InvalidateScoreRankingsByUser */
  InvalidateScoreRankingsByUser(request: InvalidateScoreRankingsByUserRequest): Promise<Empty>;
  /**
   * DryRunReward
   * for admin.
   */
  DryRunReward(request: RewardRequest): Promise<RewardResponse>;
}

export const ScoreServiceServiceName = "blast.v1.score.ScoreService";
export class ScoreServiceClientImpl implements ScoreService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ScoreServiceServiceName;
    this.rpc = rpc;
    this.ValidateUploadScoreAndSign = this.ValidateUploadScoreAndSign.bind(this);
    this.CreateScore = this.CreateScore.bind(this);
    this.GetScore = this.GetScore.bind(this);
    this.GetUserBestScoreRanking = this.GetUserBestScoreRanking.bind(this);
    this.ListUserBestScoreRankings = this.ListUserBestScoreRankings.bind(this);
    this.GetUserCumulativeScoreRanking = this.GetUserCumulativeScoreRanking.bind(this);
    this.ListUserCumulativeScoreRankings = this.ListUserCumulativeScoreRankings.bind(this);
    this.GetSquareCumulativeScoreRanking = this.GetSquareCumulativeScoreRanking.bind(this);
    this.ListSquareCumulativeScoreRankings = this.ListSquareCumulativeScoreRankings.bind(this);
    this.InvalidateScoreRankingsByUser = this.InvalidateScoreRankingsByUser.bind(this);
    this.DryRunReward = this.DryRunReward.bind(this);
  }
  ValidateUploadScoreAndSign(request: ValidateUploadScoreAndSignRequest): Promise<ValidateUploadScoreAndSignResponse> {
    const data = ValidateUploadScoreAndSignRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ValidateUploadScoreAndSign", data);
    return promise.then((data) => ValidateUploadScoreAndSignResponse.decode(_m0.Reader.create(data)));
  }

  CreateScore(request: CreateScoreRequest): Promise<Score> {
    const data = CreateScoreRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateScore", data);
    return promise.then((data) => Score.decode(_m0.Reader.create(data)));
  }

  GetScore(request: GetScoreRequest): Promise<Score> {
    const data = GetScoreRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetScore", data);
    return promise.then((data) => Score.decode(_m0.Reader.create(data)));
  }

  GetUserBestScoreRanking(request: GetUserBestScoreRankingRequest): Promise<UserBestScoreRanking> {
    const data = GetUserBestScoreRankingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserBestScoreRanking", data);
    return promise.then((data) => UserBestScoreRanking.decode(_m0.Reader.create(data)));
  }

  ListUserBestScoreRankings(request: ListUserBestScoreRankingsRequest): Promise<ListUserBestScoreRankingsResponse> {
    const data = ListUserBestScoreRankingsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListUserBestScoreRankings", data);
    return promise.then((data) => ListUserBestScoreRankingsResponse.decode(_m0.Reader.create(data)));
  }

  GetUserCumulativeScoreRanking(request: GetUserCumulativeScoreRankingRequest): Promise<UserCumulativeScoreRanking> {
    const data = GetUserCumulativeScoreRankingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserCumulativeScoreRanking", data);
    return promise.then((data) => UserCumulativeScoreRanking.decode(_m0.Reader.create(data)));
  }

  ListUserCumulativeScoreRankings(
    request: ListUserCumulativeScoreRankingsRequest,
  ): Promise<ListUserCumulativeScoreRankingsResponse> {
    const data = ListUserCumulativeScoreRankingsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListUserCumulativeScoreRankings", data);
    return promise.then((data) => ListUserCumulativeScoreRankingsResponse.decode(_m0.Reader.create(data)));
  }

  GetSquareCumulativeScoreRanking(
    request: GetSquareCumulativeScoreRankingRequest,
  ): Promise<SquareCumulativeScoreRanking> {
    const data = GetSquareCumulativeScoreRankingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSquareCumulativeScoreRanking", data);
    return promise.then((data) => SquareCumulativeScoreRanking.decode(_m0.Reader.create(data)));
  }

  ListSquareCumulativeScoreRankings(
    request: ListSquareCumulativeScoreRankingsRequest,
  ): Promise<ListSquareCumulativeScoreRankingsResponse> {
    const data = ListSquareCumulativeScoreRankingsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSquareCumulativeScoreRankings", data);
    return promise.then((data) => ListSquareCumulativeScoreRankingsResponse.decode(_m0.Reader.create(data)));
  }

  InvalidateScoreRankingsByUser(request: InvalidateScoreRankingsByUserRequest): Promise<Empty> {
    const data = InvalidateScoreRankingsByUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InvalidateScoreRankingsByUser", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  DryRunReward(request: RewardRequest): Promise<RewardResponse> {
    const data = RewardRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DryRunReward", data);
    return promise.then((data) => RewardResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
