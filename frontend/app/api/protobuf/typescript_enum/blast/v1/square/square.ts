// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: blast/v1/square/square.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { FieldMask } from "../../../google/protobuf/field_mask";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { JoinSquareParams, MintAndCreateSquareParams, TransferSquareParams } from "../chain/sign";

export const protobufPackage = "blast.v1.square";

/**
 * SquareView enumeration represents the view of a square.
 * The view controls the amount of information returned.
 *
 * Reference
 * https://cloud.google.com/apis/design/design_patterns#list_flattening and
 * https://google.aip.dev/157
 */
export enum SquareView {
  /**
   * SQUARE_VIEW_UNSPECIFIED - The default / unset value.
   * The API will default to the SQUARE_VIEW_NOT_MEMBER view.
   */
  SQUARE_VIEW_UNSPECIFIED = 0,
  /** SQUARE_VIEW_OWNER - Include everything. */
  SQUARE_VIEW_OWNER = 1,
  /**
   * SQUARE_VIEW_MEMBER - Include only fields that are safe to be exposed to members
   * Do not include `private``
   */
  SQUARE_VIEW_MEMBER = 2,
  /**
   * SQUARE_VIEW_NOT_MEMBER - Include only fields that are safe to be exposed to non-members
   * Do not include `private`
   * This is the default value for GetSquare.
   */
  SQUARE_VIEW_NOT_MEMBER = 3,
}

export function squareViewFromJSON(object: any): SquareView {
  switch (object) {
    case 0:
    case "SQUARE_VIEW_UNSPECIFIED":
      return SquareView.SQUARE_VIEW_UNSPECIFIED;
    case 1:
    case "SQUARE_VIEW_OWNER":
      return SquareView.SQUARE_VIEW_OWNER;
    case 2:
    case "SQUARE_VIEW_MEMBER":
      return SquareView.SQUARE_VIEW_MEMBER;
    case 3:
    case "SQUARE_VIEW_NOT_MEMBER":
      return SquareView.SQUARE_VIEW_NOT_MEMBER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SquareView");
  }
}

export function squareViewToJSON(object: SquareView): string {
  switch (object) {
    case SquareView.SQUARE_VIEW_UNSPECIFIED:
      return "SQUARE_VIEW_UNSPECIFIED";
    case SquareView.SQUARE_VIEW_OWNER:
      return "SQUARE_VIEW_OWNER";
    case SquareView.SQUARE_VIEW_MEMBER:
      return "SQUARE_VIEW_MEMBER";
    case SquareView.SQUARE_VIEW_NOT_MEMBER:
      return "SQUARE_VIEW_NOT_MEMBER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SquareView");
  }
}

/** The state of square */
export enum SquareState {
  /** STATE_UNSPECIFIED - default value. this value is unused. */
  STATE_UNSPECIFIED = 0,
  /** CREATED_PENDING - The square is created at server side and pending for onchain tx is finalized */
  CREATED_PENDING = 1,
  /** OWNED - The square is owned by Spacebar user. */
  OWNED = 2,
  /** UNOWNED - The owner of the square is not a Spacebar user. */
  UNOWNED = 3,
}

export function squareStateFromJSON(object: any): SquareState {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return SquareState.STATE_UNSPECIFIED;
    case 1:
    case "CREATED_PENDING":
      return SquareState.CREATED_PENDING;
    case 2:
    case "OWNED":
      return SquareState.OWNED;
    case 3:
    case "UNOWNED":
      return SquareState.UNOWNED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SquareState");
  }
}

export function squareStateToJSON(object: SquareState): string {
  switch (object) {
    case SquareState.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case SquareState.CREATED_PENDING:
      return "CREATED_PENDING";
    case SquareState.OWNED:
      return "OWNED";
    case SquareState.UNOWNED:
      return "UNOWNED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SquareState");
  }
}

/** The join type of square */
export enum SquareJoinType {
  /** TYPE_UNSPECIFIED - default value. this value is unused. */
  TYPE_UNSPECIFIED = 0,
  /** PUBLIC - Anyone can join the square. */
  PUBLIC = 1,
  /** PRIVATE - Only user with the code can join the square. */
  PRIVATE = 2,
  /** TOKEN_GATED - Only user with the specific token can join the square. */
  TOKEN_GATED = 3,
}

export function squareJoinTypeFromJSON(object: any): SquareJoinType {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return SquareJoinType.TYPE_UNSPECIFIED;
    case 1:
    case "PUBLIC":
      return SquareJoinType.PUBLIC;
    case 2:
    case "PRIVATE":
      return SquareJoinType.PRIVATE;
    case 3:
    case "TOKEN_GATED":
      return SquareJoinType.TOKEN_GATED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SquareJoinType");
  }
}

export function squareJoinTypeToJSON(object: SquareJoinType): string {
  switch (object) {
    case SquareJoinType.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case SquareJoinType.PUBLIC:
      return "PUBLIC";
    case SquareJoinType.PRIVATE:
      return "PRIVATE";
    case SquareJoinType.TOKEN_GATED:
      return "TOKEN_GATED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SquareJoinType");
  }
}

/** The member type of square */
export enum SquareMemberType {
  /** SQUARE_MEMBER_TYPE_UNSPECIFIED - default value. this value is unused. */
  SQUARE_MEMBER_TYPE_UNSPECIFIED = 0,
  OWNER = 1,
  MEMBER = 2,
}

export function squareMemberTypeFromJSON(object: any): SquareMemberType {
  switch (object) {
    case 0:
    case "SQUARE_MEMBER_TYPE_UNSPECIFIED":
      return SquareMemberType.SQUARE_MEMBER_TYPE_UNSPECIFIED;
    case 1:
    case "OWNER":
      return SquareMemberType.OWNER;
    case 2:
    case "MEMBER":
      return SquareMemberType.MEMBER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SquareMemberType");
  }
}

export function squareMemberTypeToJSON(object: SquareMemberType): string {
  switch (object) {
    case SquareMemberType.SQUARE_MEMBER_TYPE_UNSPECIFIED:
      return "SQUARE_MEMBER_TYPE_UNSPECIFIED";
    case SquareMemberType.OWNER:
      return "OWNER";
    case SquareMemberType.MEMBER:
      return "MEMBER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SquareMemberType");
  }
}

export enum SquareMemberRankType {
  SQUARE_MEMBER_RANK_TYPE_UNSPECIFIED = 0,
  ALL_TIME = 1,
  WEEKLY = 2,
}

export function squareMemberRankTypeFromJSON(object: any): SquareMemberRankType {
  switch (object) {
    case 0:
    case "SQUARE_MEMBER_RANK_TYPE_UNSPECIFIED":
      return SquareMemberRankType.SQUARE_MEMBER_RANK_TYPE_UNSPECIFIED;
    case 1:
    case "ALL_TIME":
      return SquareMemberRankType.ALL_TIME;
    case 2:
    case "WEEKLY":
      return SquareMemberRankType.WEEKLY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SquareMemberRankType");
  }
}

export function squareMemberRankTypeToJSON(object: SquareMemberRankType): string {
  switch (object) {
    case SquareMemberRankType.SQUARE_MEMBER_RANK_TYPE_UNSPECIFIED:
      return "SQUARE_MEMBER_RANK_TYPE_UNSPECIFIED";
    case SquareMemberRankType.ALL_TIME:
      return "ALL_TIME";
    case SquareMemberRankType.WEEKLY:
      return "WEEKLY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SquareMemberRankType");
  }
}

export enum RejectMintCode {
  REJECT_MINT_CODE_UNSPECIFIED = 0,
  /** NO_ELIGIBILITY - The user is not whitelisted to mint the Square NFT. */
  NO_ELIGIBILITY = 1,
  /** ROUND_TIME_NOT_MATCH - The Square NFT is already minted. */
  ROUND_TIME_NOT_MATCH = 2,
  /** ALREADY_MINTED - The Square NFT is already minted. */
  ALREADY_MINTED = 3,
}

export function rejectMintCodeFromJSON(object: any): RejectMintCode {
  switch (object) {
    case 0:
    case "REJECT_MINT_CODE_UNSPECIFIED":
      return RejectMintCode.REJECT_MINT_CODE_UNSPECIFIED;
    case 1:
    case "NO_ELIGIBILITY":
      return RejectMintCode.NO_ELIGIBILITY;
    case 2:
    case "ROUND_TIME_NOT_MATCH":
      return RejectMintCode.ROUND_TIME_NOT_MATCH;
    case 3:
    case "ALREADY_MINTED":
      return RejectMintCode.ALREADY_MINTED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RejectMintCode");
  }
}

export function rejectMintCodeToJSON(object: RejectMintCode): string {
  switch (object) {
    case RejectMintCode.REJECT_MINT_CODE_UNSPECIFIED:
      return "REJECT_MINT_CODE_UNSPECIFIED";
    case RejectMintCode.NO_ELIGIBILITY:
      return "NO_ELIGIBILITY";
    case RejectMintCode.ROUND_TIME_NOT_MATCH:
      return "ROUND_TIME_NOT_MATCH";
    case RejectMintCode.ALREADY_MINTED:
      return "ALREADY_MINTED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RejectMintCode");
  }
}

export enum RejectJoinSquareCode {
  REJECT_JOIN_CODE_UNSPECIFIED = 0,
  /** REJECT_JOIN_FULLY_OCCUPIED - The square is fully occupied. */
  REJECT_JOIN_FULLY_OCCUPIED = 1,
  /** REJECT_JOIN_NOT_ENOUGH_STAKING_AMOUNT - The user's staking amount is below the minimum required amount to join the square. */
  REJECT_JOIN_NOT_ENOUGH_STAKING_AMOUNT = 2,
  /** REJECT_JOIN_INCORRECT_PRIVATE_CODE - The private code is incorrect. */
  REJECT_JOIN_INCORRECT_PRIVATE_CODE = 3,
  /** REJECT_JOIN_NOT_TOKEN_HOLDER - The user is not a token holder of the token gated square. */
  REJECT_JOIN_NOT_TOKEN_HOLDER = 4,
  /** REJECT_JOIN_ALREADY_JOINED - The user is already memeber of the square. */
  REJECT_JOIN_ALREADY_JOINED = 5,
}

export function rejectJoinSquareCodeFromJSON(object: any): RejectJoinSquareCode {
  switch (object) {
    case 0:
    case "REJECT_JOIN_CODE_UNSPECIFIED":
      return RejectJoinSquareCode.REJECT_JOIN_CODE_UNSPECIFIED;
    case 1:
    case "REJECT_JOIN_FULLY_OCCUPIED":
      return RejectJoinSquareCode.REJECT_JOIN_FULLY_OCCUPIED;
    case 2:
    case "REJECT_JOIN_NOT_ENOUGH_STAKING_AMOUNT":
      return RejectJoinSquareCode.REJECT_JOIN_NOT_ENOUGH_STAKING_AMOUNT;
    case 3:
    case "REJECT_JOIN_INCORRECT_PRIVATE_CODE":
      return RejectJoinSquareCode.REJECT_JOIN_INCORRECT_PRIVATE_CODE;
    case 4:
    case "REJECT_JOIN_NOT_TOKEN_HOLDER":
      return RejectJoinSquareCode.REJECT_JOIN_NOT_TOKEN_HOLDER;
    case 5:
    case "REJECT_JOIN_ALREADY_JOINED":
      return RejectJoinSquareCode.REJECT_JOIN_ALREADY_JOINED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RejectJoinSquareCode");
  }
}

export function rejectJoinSquareCodeToJSON(object: RejectJoinSquareCode): string {
  switch (object) {
    case RejectJoinSquareCode.REJECT_JOIN_CODE_UNSPECIFIED:
      return "REJECT_JOIN_CODE_UNSPECIFIED";
    case RejectJoinSquareCode.REJECT_JOIN_FULLY_OCCUPIED:
      return "REJECT_JOIN_FULLY_OCCUPIED";
    case RejectJoinSquareCode.REJECT_JOIN_NOT_ENOUGH_STAKING_AMOUNT:
      return "REJECT_JOIN_NOT_ENOUGH_STAKING_AMOUNT";
    case RejectJoinSquareCode.REJECT_JOIN_INCORRECT_PRIVATE_CODE:
      return "REJECT_JOIN_INCORRECT_PRIVATE_CODE";
    case RejectJoinSquareCode.REJECT_JOIN_NOT_TOKEN_HOLDER:
      return "REJECT_JOIN_NOT_TOKEN_HOLDER";
    case RejectJoinSquareCode.REJECT_JOIN_ALREADY_JOINED:
      return "REJECT_JOIN_ALREADY_JOINED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RejectJoinSquareCode");
  }
}

export enum RejectTransferSquareCode {
  REJECT_TRANSFER_CODE_UNSPECIFIED = 0,
  /** REJECT_TRANSFER_FULLY_OCCUPIED - The square is fully occupied. */
  REJECT_TRANSFER_FULLY_OCCUPIED = 1,
  /** REJECT_TRANSFER_NOT_ENOUGH_STAKING_AMOUNT - The user's staking amount is below the minimum required amount to join the square. */
  REJECT_TRANSFER_NOT_ENOUGH_STAKING_AMOUNT = 2,
  /** REJECT_TRANSFER_INCORRECT_PRIVATE_CODE - The private code is incorrect. */
  REJECT_TRANSFER_INCORRECT_PRIVATE_CODE = 3,
  /** REJECT_TRANSFER_NOT_TOKEN_HOLDER - The user is not a token holder of the token gated square. */
  REJECT_TRANSFER_NOT_TOKEN_HOLDER = 4,
  /** REJECT_TRANSFER_NOT_SQUARE_MEMBER - The user is not member of any square. */
  REJECT_TRANSFER_NOT_SQUARE_MEMBER = 5,
  /** REJECT_TRANSFER_NOT_AFTER_COOLDOWN_TIME - The user transfer or join the square within the cooldown time. */
  REJECT_TRANSFER_NOT_AFTER_COOLDOWN_TIME = 6,
}

export function rejectTransferSquareCodeFromJSON(object: any): RejectTransferSquareCode {
  switch (object) {
    case 0:
    case "REJECT_TRANSFER_CODE_UNSPECIFIED":
      return RejectTransferSquareCode.REJECT_TRANSFER_CODE_UNSPECIFIED;
    case 1:
    case "REJECT_TRANSFER_FULLY_OCCUPIED":
      return RejectTransferSquareCode.REJECT_TRANSFER_FULLY_OCCUPIED;
    case 2:
    case "REJECT_TRANSFER_NOT_ENOUGH_STAKING_AMOUNT":
      return RejectTransferSquareCode.REJECT_TRANSFER_NOT_ENOUGH_STAKING_AMOUNT;
    case 3:
    case "REJECT_TRANSFER_INCORRECT_PRIVATE_CODE":
      return RejectTransferSquareCode.REJECT_TRANSFER_INCORRECT_PRIVATE_CODE;
    case 4:
    case "REJECT_TRANSFER_NOT_TOKEN_HOLDER":
      return RejectTransferSquareCode.REJECT_TRANSFER_NOT_TOKEN_HOLDER;
    case 5:
    case "REJECT_TRANSFER_NOT_SQUARE_MEMBER":
      return RejectTransferSquareCode.REJECT_TRANSFER_NOT_SQUARE_MEMBER;
    case 6:
    case "REJECT_TRANSFER_NOT_AFTER_COOLDOWN_TIME":
      return RejectTransferSquareCode.REJECT_TRANSFER_NOT_AFTER_COOLDOWN_TIME;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RejectTransferSquareCode");
  }
}

export function rejectTransferSquareCodeToJSON(object: RejectTransferSquareCode): string {
  switch (object) {
    case RejectTransferSquareCode.REJECT_TRANSFER_CODE_UNSPECIFIED:
      return "REJECT_TRANSFER_CODE_UNSPECIFIED";
    case RejectTransferSquareCode.REJECT_TRANSFER_FULLY_OCCUPIED:
      return "REJECT_TRANSFER_FULLY_OCCUPIED";
    case RejectTransferSquareCode.REJECT_TRANSFER_NOT_ENOUGH_STAKING_AMOUNT:
      return "REJECT_TRANSFER_NOT_ENOUGH_STAKING_AMOUNT";
    case RejectTransferSquareCode.REJECT_TRANSFER_INCORRECT_PRIVATE_CODE:
      return "REJECT_TRANSFER_INCORRECT_PRIVATE_CODE";
    case RejectTransferSquareCode.REJECT_TRANSFER_NOT_TOKEN_HOLDER:
      return "REJECT_TRANSFER_NOT_TOKEN_HOLDER";
    case RejectTransferSquareCode.REJECT_TRANSFER_NOT_SQUARE_MEMBER:
      return "REJECT_TRANSFER_NOT_SQUARE_MEMBER";
    case RejectTransferSquareCode.REJECT_TRANSFER_NOT_AFTER_COOLDOWN_TIME:
      return "REJECT_TRANSFER_NOT_AFTER_COOLDOWN_TIME";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum RejectTransferSquareCode");
  }
}

export enum MintEligibility {
  MINT_ELIGIBILITY_UNSPECIFIED = 0,
  /** NOT_ELIGIBLE - The user is not eligible to mint the Square NFT. */
  NOT_ELIGIBLE = 1,
  /** ELIGIBLE_ROUND1 - The user is eligible to mint the Square NFT in round 1. */
  ELIGIBLE_ROUND1 = 2,
  /** ELIGIBLE_ROUND2 - The user is eligible to mint the Square NFT in round 2. */
  ELIGIBLE_ROUND2 = 3,
  /** ELIGIBLE_ROUND1_AND_ROUND2 - The user is eligible to mint the Square NFT in round 1 and round 2. */
  ELIGIBLE_ROUND1_AND_ROUND2 = 4,
}

export function mintEligibilityFromJSON(object: any): MintEligibility {
  switch (object) {
    case 0:
    case "MINT_ELIGIBILITY_UNSPECIFIED":
      return MintEligibility.MINT_ELIGIBILITY_UNSPECIFIED;
    case 1:
    case "NOT_ELIGIBLE":
      return MintEligibility.NOT_ELIGIBLE;
    case 2:
    case "ELIGIBLE_ROUND1":
      return MintEligibility.ELIGIBLE_ROUND1;
    case 3:
    case "ELIGIBLE_ROUND2":
      return MintEligibility.ELIGIBLE_ROUND2;
    case 4:
    case "ELIGIBLE_ROUND1_AND_ROUND2":
      return MintEligibility.ELIGIBLE_ROUND1_AND_ROUND2;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MintEligibility");
  }
}

export function mintEligibilityToJSON(object: MintEligibility): string {
  switch (object) {
    case MintEligibility.MINT_ELIGIBILITY_UNSPECIFIED:
      return "MINT_ELIGIBILITY_UNSPECIFIED";
    case MintEligibility.NOT_ELIGIBLE:
      return "NOT_ELIGIBLE";
    case MintEligibility.ELIGIBLE_ROUND1:
      return "ELIGIBLE_ROUND1";
    case MintEligibility.ELIGIBLE_ROUND2:
      return "ELIGIBLE_ROUND2";
    case MintEligibility.ELIGIBLE_ROUND1_AND_ROUND2:
      return "ELIGIBLE_ROUND1_AND_ROUND2";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MintEligibility");
  }
}

export enum TransferMemberType {
  TRANSFER_MEMBER_TYPE_UNSPECIFIED = 0,
  DEFAULT = 1,
  KICKED_OUT = 2,
  TO_OWNER = 3,
}

export function transferMemberTypeFromJSON(object: any): TransferMemberType {
  switch (object) {
    case 0:
    case "TRANSFER_MEMBER_TYPE_UNSPECIFIED":
      return TransferMemberType.TRANSFER_MEMBER_TYPE_UNSPECIFIED;
    case 1:
    case "DEFAULT":
      return TransferMemberType.DEFAULT;
    case 2:
    case "KICKED_OUT":
      return TransferMemberType.KICKED_OUT;
    case 3:
    case "TO_OWNER":
      return TransferMemberType.TO_OWNER;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TransferMemberType");
  }
}

export function transferMemberTypeToJSON(object: TransferMemberType): string {
  switch (object) {
    case TransferMemberType.TRANSFER_MEMBER_TYPE_UNSPECIFIED:
      return "TRANSFER_MEMBER_TYPE_UNSPECIFIED";
    case TransferMemberType.DEFAULT:
      return "DEFAULT";
    case TransferMemberType.KICKED_OUT:
      return "KICKED_OUT";
    case TransferMemberType.TO_OWNER:
      return "TO_OWNER";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TransferMemberType");
  }
}

export enum SpiritType {
  SQUARE_SPIRIT_TYPE_UNSPECIFIED = 0,
  VOTING = 1,
  SUMMON_BEBOB_SUCCESS = 2,
  ATTACK_BEBOB_SUCCESS = 3,
  COLLECT_STARS = 4,
  COMMUNITY_EVENT = 5,
}

export function spiritTypeFromJSON(object: any): SpiritType {
  switch (object) {
    case 0:
    case "SQUARE_SPIRIT_TYPE_UNSPECIFIED":
      return SpiritType.SQUARE_SPIRIT_TYPE_UNSPECIFIED;
    case 1:
    case "VOTING":
      return SpiritType.VOTING;
    case 2:
    case "SUMMON_BEBOB_SUCCESS":
      return SpiritType.SUMMON_BEBOB_SUCCESS;
    case 3:
    case "ATTACK_BEBOB_SUCCESS":
      return SpiritType.ATTACK_BEBOB_SUCCESS;
    case 4:
    case "COLLECT_STARS":
      return SpiritType.COLLECT_STARS;
    case 5:
    case "COMMUNITY_EVENT":
      return SpiritType.COMMUNITY_EVENT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SpiritType");
  }
}

export function spiritTypeToJSON(object: SpiritType): string {
  switch (object) {
    case SpiritType.SQUARE_SPIRIT_TYPE_UNSPECIFIED:
      return "SQUARE_SPIRIT_TYPE_UNSPECIFIED";
    case SpiritType.VOTING:
      return "VOTING";
    case SpiritType.SUMMON_BEBOB_SUCCESS:
      return "SUMMON_BEBOB_SUCCESS";
    case SpiritType.ATTACK_BEBOB_SUCCESS:
      return "ATTACK_BEBOB_SUCCESS";
    case SpiritType.COLLECT_STARS:
      return "COLLECT_STARS";
    case SpiritType.COMMUNITY_EVENT:
      return "COMMUNITY_EVENT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SpiritType");
  }
}

export interface GetSquareRequest {
  /**
   * The name of the square to retrieve.
   * Format: squares/{token_id}
   */
  square: string;
  /**
   * Optional. The view to return.
   * Defaults to SQUARE_VIEW_NOT_MEMBER if not set.
   * If set to SQUARE_VIEW_OWNER or SQUARE_VIEW_MEMBER, but the user does not have permission to do so, the API will return a PERMISSION_DENIED error.
   *
   * SquareView enumeration represents the view of a square.
   * The view controls the amount of information returned.
   *
   * Reference
   * https://cloud.google.com/apis/design/design_patterns#list_flattening and
   * https://google.aip.dev/157
   */
  view: SquareView;
}

export interface ListSquaresRequest {
  /**
   * The maximum number of squares to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListSquares` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Available Sequence and Operator
   * * name
   *   * `=`
   * * token_id
   *   * `=`
   * * signature_id
   *   * `=`
   * * state
   *   * `=`
   * * join_type
   *   * `=`
   * * display_name
   *   * `=`
   * * occupied
   *   * `negation`
   *
   * Examples
   * * name="squares/10"
   * * token_id="10"
   * * signature_id="3ed92b99-00be-4417-b69f-dca2d8d14c7f"
   * * join_type=TOKEN_GATED
   * * display_name="SQUARE"
   * * join_type=TOKEN_GATED AND not occupied
   */
  filter: string;
  /**
   * Optional. One or more fields to compare and use to sort the output.
   * Default order for a field is descending by id
   * To specify ascending or descending order, append " asc" or " desc" to the field name. If not specified, the order is ascending.
   *
   * Reference
   * * https://google.aip.dev/132#ordering.
   *
   * Supported Fields
   * * "token_id", "total_points", "spirits"
   *
   * Examples
   * * order_by=token_id asc
   * * order_by=total_points desc
   * * order_by=spirits desc
   */
  orderBy: string;
}

/**
 * ListSquaresResponse
 * (-- api-linter: core::0158::response-next-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 */
export interface ListSquaresResponse {
  /** The list of rows that matched the query. */
  squares: Square[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface ValidateDisplayNameAvailabilityRequest {
  /** The display_name of Square. */
  displayName: string;
}

export interface ValidateDisplayNameAvailabilityResponse {
  /** The display_name of Square. */
  displayName: string;
  /** The availability of the nickname. */
  available: boolean;
  /**
   * The reason of the display_name is not available.
   * Example:
   * - display name already exists
   * - display name should more or equal than 4
   * - display name should less or equal than 10
   * - display name contains non uppercase character
   */
  reason?: string | undefined;
}

export interface CreateSquareAndSignRequest {
  nonce: string;
  /** square to create */
  square: Square | undefined;
}

export interface CreateSquareAndSignResponse {
  /** square to create */
  square:
    | Square
    | undefined;
  /** signature to sign the onchain tx */
  signature: string;
  params: MintAndCreateSquareParams | undefined;
}

export interface ListUsersSquaresRequest {
  user: string;
}

export interface ListUsersSquaresResponse {
  /** The list of rows that matched the query. */
  squares: Square[];
}

export interface UpdateSquareRequest {
  /**
   * Square to update
   * Format: squares/{token_id}
   */
  square:
    | Square
    | undefined;
  /**
   * Field mask that specifies the fields to update.
   * If no field mask is set, all fields will be updated.
   *
   * Supported Fields
   * * "display_name", "description", "join"
   *
   * Wildcards are supported.
   * Examples
   * ["*"]
   * ["display_name"]
   * ["display_name", "description"]
   * ["join"]
   */
  updateMask: string[] | undefined;
}

export interface GetSquareWeeklySpiritsRequest {
  /**
   * The name of the square to retrieve.
   * Format: squares/{token_id}
   */
  square: string;
  /**
   * The week number to retrieve.
   * If unspecified, the current week will be returned.
   */
  week?: number | undefined;
}

export interface GetSquareWeeklySpiritsResponse {
  weeklySpirits: number;
}

export interface CheckMintEligibilityRequest {
  user: string;
}

export interface CheckMintEligibilityResponse {
  user: string;
  /** Whether the user is eligible to mint the Square NFT */
  eligibility: MintEligibility;
  /**
   * Whether the user is currently available to mint the Square NFT
   * If the user is not available, the reason code will be set.
   * If the user is available, the reason code will be empty.
   * Can be unavailable though the eligibility is ELIGIBLE_ROUND1 or ELIGIBLE_ROUND2 if it is not appropriate round time.
   */
  available: boolean;
  /** The reason code of the user is not eligible to mint the Square NFT. */
  rejectCode?: RejectMintCode | undefined;
}

export interface ApproveJoinSquareAndSignRequest {
  /**
   * The resource name of the square to retrieve.
   * Format: squares/{token_id}
   */
  square: string;
  /**
   * The resource name of the user to join.
   * Format: users/{address}
   */
  user: string;
  /**
   * The private code of the square.
   * This field is required if the square is private.
   * Otherwise, this field should be empty.
   */
  privateCode?: string | undefined;
  nonce: string;
}

export interface ApproveJoinSquareAndSignResponse {
  approved: boolean;
  signature: string;
  rejectCode?: RejectJoinSquareCode | undefined;
  params: JoinSquareParams | undefined;
}

export interface ApproveTransferSquareAndSignRequest {
  /**
   * The resource name of the square to transfer.
   * Format: squares/{token_id}
   */
  square: string;
  /**
   * The resource name of the user to transfer.
   * Format: users/{address}
   */
  user: string;
  /**
   * The private code of the square.
   * This field is required if the square is private.
   * Otherwise, this field should be empty.
   */
  privateCode?: string | undefined;
  nonce: string;
}

export interface ApproveTransferSquareAndSignResponse {
  approved: boolean;
  signature: string;
  rejectCode?: RejectTransferSquareCode | undefined;
  params: TransferSquareParams | undefined;
}

export interface GetSquareWeeklyPointsRequest {
  /**
   * The name of the square to retrieve.
   * Format: squares/{token_id}
   */
  square: string;
  /**
   * The week number to retrieve.
   * If unspecified, the current week will be returned.
   */
  week: number;
}

export interface GetSquareWeeklyPointsResponse {
  /** The weekly points of the square. */
  weeklyPoints: number;
  /** The week number of the points. */
  week: number;
}

export interface ListSquareSpiritHistoriesRequest {
  /**
   * The name of the square to retrieve.
   * Format: squares/{token_id}
   */
  square: string;
  /**
   * The maximum number of spirits to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListSquareSpiritHistories` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListSquareSpiritHistoriesResposne {
  /** The list of rows that matched the query. */
  histories: SquareSpiritHistory[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content
   * of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface ListSquareMembersRequest {
  /**
   * The name of the square to retrieve.
   * Format: squares/{token_id}
   */
  square: string;
  /**
   * The maximum number of squares to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListSquareMembers` must match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Available Sequence and Operator
   * * user
   *   * `=`
   * * member
   *   * `=`
   * * member_address
   *   * `=`
   * * join_time
   *   * `>`, `<`, `>=`, `<=`
   * * show_left
   *   * `NOT`
   *
   * Examples
   * * member_address="0x6F11EF2c07f2E381CbE514198DdE87A0c0a19442"
   * * join_time>"2024-04-10T11:30:00Z"
   * * show_left
   */
  filter: string;
  /**
   * Optional. One or more fields to compare and use to sort the output.
   * Default order for a field is descending by id
   * To specify ascending or descending order, append " asc" or " desc" to the field name. If not specified, the order is ascending.
   *
   * Reference
   * * https://google.aip.dev/132#ordering.
   *
   * Supported Fields
   * * "total_points", "join_time"
   *
   * Examples
   * * order_by=join_time asc
   * * order_by=total_points desc, join_time asc
   */
  orderBy: string;
}

/**
 * ListSquareMembersResponse
 * (-- api-linter: core::0158::response-next-page-token-field=disabled
 *     aip.dev/not-precedent: We need to do this because reasons. --)
 */
export interface ListSquareMembersResponse {
  /** The list of rows that matched the query. */
  members: SquareMember[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface ListSquareMemberRankingsRequest {
  /**
   * The name of the square to retrieve.
   * Format: squares/{token_id}
   */
  square: string;
  rankType: SquareMemberRankType;
  /**
   * The maximum number of points to return. The service may return fewer than
   * this value.
   * If unspecified, at most 50 rows will be returned.
   * The maximum value is 1024; values above 1024 will be coerced to 1024.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   *
   * When paginating, all other parameters provided to `ListPoints` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

export interface ListSquareMemberRankingsResponse {
  /** The list of rows that matched the query. */
  rankings: SquareMemberRanking[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface Square {
  /**
   * The resource name of the Square.
   * Format: squares/{token_id}
   */
  name: string;
  /** ERC721 token ID of the Square. */
  tokenId: string;
  /**  */
  ownerAddress: string;
  /**
   * The created time of Square.
   * RFC3339 format e.g. "2006-01-02T15:04:05Z07:00"
   */
  createTime: string | undefined;
  state: SquareState;
  /**
   * The signature id of the Square.
   * This field is used for multi signature when minting the Square NFT.
   */
  signatureId: string;
  /** The join type of the square. */
  joinType: SquareJoinType;
  join?:
    | { $case: "public"; public: Public }
    | { $case: "private"; private: Private }
    | { $case: "tokenGated"; tokenGated: TokenGated }
    | undefined;
  /** The display name of the square. */
  displayName: string;
  /** The introduction of the square. */
  introduction: string;
  /** The minimum required staking amount to join the square in ETH. */
  minimumStakingAmountToJoinInEth: number;
  /** The total staking amount of all members in the square in ETH. */
  totalMembersStakingAmountInEth: number;
  /** The multiplier of the square. */
  multiplier: number;
  /** The all-time total points of the square. */
  totalPoints: number;
  /** The total capacity of the square. */
  capacity: number;
  /** The current number of members in the square. */
  occupancy: number;
  /** The occupancy of the square including join pending members. */
  occupancyIncludingPending: number;
  /** The PFP boost of the square. */
  pfpBoost:
    | PFPBoost
    | undefined;
  /** The NFT of the square. */
  nft: SquareNFT | undefined;
  spirits: number;
  /**  */
  stars: number;
  /** DEPRECATED: Use spirits instead. */
  totalSpirits: number;
  /** DEPRECATED: Use GetSquareWeeklySpirits API instead. */
  weeklySpirits: number;
}

export interface PFPBoost {
  percentage: number;
  memberCount: number;
  /**
   * The resource name of the NFT contract.
   * Format: nfts/{chain_type}/{contract_address}
   */
  nftContract: string;
}

export interface Public {
}

export interface Private {
  code: string;
}

export interface TokenGated {
  /**
   * The resource name of the NFT contract.
   * Format: nfts/{chain_type}/{contract_address}
   */
  nftContract: string;
}

export interface SquareNFT {
  /** Token ID of the NFT asset. */
  tokenId: number;
  /**
   * The URI of the NFT asset's image.
   * This URI is cached version of image original URI
   * e.g. "https://cdn.spacebar.xyz/nfts/ethereum/0x79fcdef22feed20eddacbb2587640e45491b757f/609"
   */
  imageUri: string;
  /** The URI of the NFT asset's metadata. */
  metadataUri: string;
}

export interface SquareMember {
  /**
   * The resource name of the Square.
   * Format: squares/{square_token_id}/members/{user_address}
   */
  name: string;
  /** The token ID of the Square. */
  squareTokenId: string;
  /** The user address of the member. */
  userAddress: string;
  /** The member type of the square. */
  type: SquareMemberType;
  totalPoints: number;
  /** RFC3339 format e.g. "2006-01-02T15:04:05Z07:00" */
  joinTime: string | undefined;
}

export interface SquareMemberRanking {
  rank: number;
  points: number;
  member: SquareMember | undefined;
}

export interface SquareSpiritHistory {
  /**
   * The name of the Square
   * Format: squares/{token_id}
   */
  square: string;
  /** The spirit type of the square. */
  type: SpiritType;
  /** The user address of the member. */
  amount: number;
  /** RFC3339 format e.g. "2006-01-02T15:04:05Z07:00" */
  createTime: string | undefined;
}

function createBaseGetSquareRequest(): GetSquareRequest {
  return { square: "", view: 0 };
}

export const GetSquareRequest = {
  encode(message: GetSquareRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== "") {
      writer.uint32(10).string(message.square);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSquareRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSquareRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.square = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSquareRequest {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      view: isSet(object.view) ? squareViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetSquareRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.view !== undefined) {
      obj.view = squareViewToJSON(message.view);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSquareRequest>, I>>(base?: I): GetSquareRequest {
    return GetSquareRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSquareRequest>, I>>(object: I): GetSquareRequest {
    const message = createBaseGetSquareRequest();
    message.square = object.square ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListSquaresRequest(): ListSquaresRequest {
  return { pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListSquaresRequest = {
  encode(message: ListSquaresRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSquaresRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquaresRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquaresRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListSquaresRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    if (message.orderBy !== undefined) {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquaresRequest>, I>>(base?: I): ListSquaresRequest {
    return ListSquaresRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquaresRequest>, I>>(object: I): ListSquaresRequest {
    const message = createBaseListSquaresRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListSquaresResponse(): ListSquaresResponse {
  return { squares: [], nextPageToken: "" };
}

export const ListSquaresResponse = {
  encode(message: ListSquaresResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.squares) {
      Square.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSquaresResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquaresResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.squares.push(Square.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquaresResponse {
    return {
      squares: globalThis.Array.isArray(object?.squares) ? object.squares.map((e: any) => Square.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSquaresResponse): unknown {
    const obj: any = {};
    if (message.squares?.length) {
      obj.squares = message.squares.map((e) => Square.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquaresResponse>, I>>(base?: I): ListSquaresResponse {
    return ListSquaresResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquaresResponse>, I>>(object: I): ListSquaresResponse {
    const message = createBaseListSquaresResponse();
    message.squares = object.squares?.map((e) => Square.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseValidateDisplayNameAvailabilityRequest(): ValidateDisplayNameAvailabilityRequest {
  return { displayName: "" };
}

export const ValidateDisplayNameAvailabilityRequest = {
  encode(message: ValidateDisplayNameAvailabilityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateDisplayNameAvailabilityRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateDisplayNameAvailabilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateDisplayNameAvailabilityRequest {
    return { displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "" };
  },

  toJSON(message: ValidateDisplayNameAvailabilityRequest): unknown {
    const obj: any = {};
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateDisplayNameAvailabilityRequest>, I>>(
    base?: I,
  ): ValidateDisplayNameAvailabilityRequest {
    return ValidateDisplayNameAvailabilityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateDisplayNameAvailabilityRequest>, I>>(
    object: I,
  ): ValidateDisplayNameAvailabilityRequest {
    const message = createBaseValidateDisplayNameAvailabilityRequest();
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseValidateDisplayNameAvailabilityResponse(): ValidateDisplayNameAvailabilityResponse {
  return { displayName: "", available: false, reason: undefined };
}

export const ValidateDisplayNameAvailabilityResponse = {
  encode(message: ValidateDisplayNameAvailabilityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.available !== false) {
      writer.uint32(16).bool(message.available);
    }
    if (message.reason !== undefined) {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateDisplayNameAvailabilityResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateDisplayNameAvailabilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.available = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateDisplayNameAvailabilityResponse {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      available: isSet(object.available) ? globalThis.Boolean(object.available) : false,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: ValidateDisplayNameAvailabilityResponse): unknown {
    const obj: any = {};
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.available !== undefined) {
      obj.available = message.available;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateDisplayNameAvailabilityResponse>, I>>(
    base?: I,
  ): ValidateDisplayNameAvailabilityResponse {
    return ValidateDisplayNameAvailabilityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateDisplayNameAvailabilityResponse>, I>>(
    object: I,
  ): ValidateDisplayNameAvailabilityResponse {
    const message = createBaseValidateDisplayNameAvailabilityResponse();
    message.displayName = object.displayName ?? "";
    message.available = object.available ?? false;
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseCreateSquareAndSignRequest(): CreateSquareAndSignRequest {
  return { nonce: "", square: undefined };
}

export const CreateSquareAndSignRequest = {
  encode(message: CreateSquareAndSignRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nonce !== "") {
      writer.uint32(10).string(message.nonce);
    }
    if (message.square !== undefined) {
      Square.encode(message.square, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSquareAndSignRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSquareAndSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nonce = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.square = Square.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSquareAndSignRequest {
    return {
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
      square: isSet(object.square) ? Square.fromJSON(object.square) : undefined,
    };
  },

  toJSON(message: CreateSquareAndSignRequest): unknown {
    const obj: any = {};
    if (message.nonce !== undefined) {
      obj.nonce = message.nonce;
    }
    if (message.square !== undefined) {
      obj.square = Square.toJSON(message.square);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSquareAndSignRequest>, I>>(base?: I): CreateSquareAndSignRequest {
    return CreateSquareAndSignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSquareAndSignRequest>, I>>(object: I): CreateSquareAndSignRequest {
    const message = createBaseCreateSquareAndSignRequest();
    message.nonce = object.nonce ?? "";
    message.square = (object.square !== undefined && object.square !== null)
      ? Square.fromPartial(object.square)
      : undefined;
    return message;
  },
};

function createBaseCreateSquareAndSignResponse(): CreateSquareAndSignResponse {
  return { square: undefined, signature: "", params: undefined };
}

export const CreateSquareAndSignResponse = {
  encode(message: CreateSquareAndSignResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== undefined) {
      Square.encode(message.square, writer.uint32(10).fork()).ldelim();
    }
    if (message.signature !== "") {
      writer.uint32(18).string(message.signature);
    }
    if (message.params !== undefined) {
      MintAndCreateSquareParams.encode(message.params, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSquareAndSignResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSquareAndSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.square = Square.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.params = MintAndCreateSquareParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSquareAndSignResponse {
    return {
      square: isSet(object.square) ? Square.fromJSON(object.square) : undefined,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      params: isSet(object.params) ? MintAndCreateSquareParams.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: CreateSquareAndSignResponse): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = Square.toJSON(message.square);
    }
    if (message.signature !== undefined) {
      obj.signature = message.signature;
    }
    if (message.params !== undefined) {
      obj.params = MintAndCreateSquareParams.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSquareAndSignResponse>, I>>(base?: I): CreateSquareAndSignResponse {
    return CreateSquareAndSignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSquareAndSignResponse>, I>>(object: I): CreateSquareAndSignResponse {
    const message = createBaseCreateSquareAndSignResponse();
    message.square = (object.square !== undefined && object.square !== null)
      ? Square.fromPartial(object.square)
      : undefined;
    message.signature = object.signature ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? MintAndCreateSquareParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseListUsersSquaresRequest(): ListUsersSquaresRequest {
  return { user: "" };
}

export const ListUsersSquaresRequest = {
  encode(message: ListUsersSquaresRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUsersSquaresRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersSquaresRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersSquaresRequest {
    return { user: isSet(object.user) ? globalThis.String(object.user) : "" };
  },

  toJSON(message: ListUsersSquaresRequest): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersSquaresRequest>, I>>(base?: I): ListUsersSquaresRequest {
    return ListUsersSquaresRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersSquaresRequest>, I>>(object: I): ListUsersSquaresRequest {
    const message = createBaseListUsersSquaresRequest();
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseListUsersSquaresResponse(): ListUsersSquaresResponse {
  return { squares: [] };
}

export const ListUsersSquaresResponse = {
  encode(message: ListUsersSquaresResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.squares) {
      Square.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUsersSquaresResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersSquaresResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.squares.push(Square.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersSquaresResponse {
    return {
      squares: globalThis.Array.isArray(object?.squares) ? object.squares.map((e: any) => Square.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListUsersSquaresResponse): unknown {
    const obj: any = {};
    if (message.squares?.length) {
      obj.squares = message.squares.map((e) => Square.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersSquaresResponse>, I>>(base?: I): ListUsersSquaresResponse {
    return ListUsersSquaresResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersSquaresResponse>, I>>(object: I): ListUsersSquaresResponse {
    const message = createBaseListUsersSquaresResponse();
    message.squares = object.squares?.map((e) => Square.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateSquareRequest(): UpdateSquareRequest {
  return { square: undefined, updateMask: undefined };
}

export const UpdateSquareRequest = {
  encode(message: UpdateSquareRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== undefined) {
      Square.encode(message.square, writer.uint32(10).fork()).ldelim();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSquareRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSquareRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.square = Square.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSquareRequest {
    return {
      square: isSet(object.square) ? Square.fromJSON(object.square) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateSquareRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = Square.toJSON(message.square);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSquareRequest>, I>>(base?: I): UpdateSquareRequest {
    return UpdateSquareRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSquareRequest>, I>>(object: I): UpdateSquareRequest {
    const message = createBaseUpdateSquareRequest();
    message.square = (object.square !== undefined && object.square !== null)
      ? Square.fromPartial(object.square)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetSquareWeeklySpiritsRequest(): GetSquareWeeklySpiritsRequest {
  return { square: "", week: undefined };
}

export const GetSquareWeeklySpiritsRequest = {
  encode(message: GetSquareWeeklySpiritsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== "") {
      writer.uint32(10).string(message.square);
    }
    if (message.week !== undefined) {
      writer.uint32(16).uint32(message.week);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSquareWeeklySpiritsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSquareWeeklySpiritsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.square = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.week = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSquareWeeklySpiritsRequest {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : undefined,
    };
  },

  toJSON(message: GetSquareWeeklySpiritsRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSquareWeeklySpiritsRequest>, I>>(base?: I): GetSquareWeeklySpiritsRequest {
    return GetSquareWeeklySpiritsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSquareWeeklySpiritsRequest>, I>>(
    object: I,
  ): GetSquareWeeklySpiritsRequest {
    const message = createBaseGetSquareWeeklySpiritsRequest();
    message.square = object.square ?? "";
    message.week = object.week ?? undefined;
    return message;
  },
};

function createBaseGetSquareWeeklySpiritsResponse(): GetSquareWeeklySpiritsResponse {
  return { weeklySpirits: 0 };
}

export const GetSquareWeeklySpiritsResponse = {
  encode(message: GetSquareWeeklySpiritsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.weeklySpirits !== 0) {
      writer.uint32(8).uint32(message.weeklySpirits);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSquareWeeklySpiritsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSquareWeeklySpiritsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.weeklySpirits = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSquareWeeklySpiritsResponse {
    return { weeklySpirits: isSet(object.weeklySpirits) ? globalThis.Number(object.weeklySpirits) : 0 };
  },

  toJSON(message: GetSquareWeeklySpiritsResponse): unknown {
    const obj: any = {};
    if (message.weeklySpirits !== undefined) {
      obj.weeklySpirits = Math.round(message.weeklySpirits);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSquareWeeklySpiritsResponse>, I>>(base?: I): GetSquareWeeklySpiritsResponse {
    return GetSquareWeeklySpiritsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSquareWeeklySpiritsResponse>, I>>(
    object: I,
  ): GetSquareWeeklySpiritsResponse {
    const message = createBaseGetSquareWeeklySpiritsResponse();
    message.weeklySpirits = object.weeklySpirits ?? 0;
    return message;
  },
};

function createBaseCheckMintEligibilityRequest(): CheckMintEligibilityRequest {
  return { user: "" };
}

export const CheckMintEligibilityRequest = {
  encode(message: CheckMintEligibilityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckMintEligibilityRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckMintEligibilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckMintEligibilityRequest {
    return { user: isSet(object.user) ? globalThis.String(object.user) : "" };
  },

  toJSON(message: CheckMintEligibilityRequest): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckMintEligibilityRequest>, I>>(base?: I): CheckMintEligibilityRequest {
    return CheckMintEligibilityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckMintEligibilityRequest>, I>>(object: I): CheckMintEligibilityRequest {
    const message = createBaseCheckMintEligibilityRequest();
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseCheckMintEligibilityResponse(): CheckMintEligibilityResponse {
  return { user: "", eligibility: 0, available: false, rejectCode: undefined };
}

export const CheckMintEligibilityResponse = {
  encode(message: CheckMintEligibilityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.eligibility !== 0) {
      writer.uint32(16).int32(message.eligibility);
    }
    if (message.available !== false) {
      writer.uint32(24).bool(message.available);
    }
    if (message.rejectCode !== undefined) {
      writer.uint32(32).int32(message.rejectCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckMintEligibilityResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckMintEligibilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eligibility = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.available = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rejectCode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckMintEligibilityResponse {
    return {
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      eligibility: isSet(object.eligibility) ? mintEligibilityFromJSON(object.eligibility) : 0,
      available: isSet(object.available) ? globalThis.Boolean(object.available) : false,
      rejectCode: isSet(object.rejectCode) ? rejectMintCodeFromJSON(object.rejectCode) : undefined,
    };
  },

  toJSON(message: CheckMintEligibilityResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.eligibility !== undefined) {
      obj.eligibility = mintEligibilityToJSON(message.eligibility);
    }
    if (message.available !== undefined) {
      obj.available = message.available;
    }
    if (message.rejectCode !== undefined) {
      obj.rejectCode = rejectMintCodeToJSON(message.rejectCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckMintEligibilityResponse>, I>>(base?: I): CheckMintEligibilityResponse {
    return CheckMintEligibilityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckMintEligibilityResponse>, I>>(object: I): CheckMintEligibilityResponse {
    const message = createBaseCheckMintEligibilityResponse();
    message.user = object.user ?? "";
    message.eligibility = object.eligibility ?? 0;
    message.available = object.available ?? false;
    message.rejectCode = object.rejectCode ?? undefined;
    return message;
  },
};

function createBaseApproveJoinSquareAndSignRequest(): ApproveJoinSquareAndSignRequest {
  return { square: "", user: "", privateCode: undefined, nonce: "" };
}

export const ApproveJoinSquareAndSignRequest = {
  encode(message: ApproveJoinSquareAndSignRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== "") {
      writer.uint32(10).string(message.square);
    }
    if (message.user !== "") {
      writer.uint32(18).string(message.user);
    }
    if (message.privateCode !== undefined) {
      writer.uint32(26).string(message.privateCode);
    }
    if (message.nonce !== "") {
      writer.uint32(34).string(message.nonce);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveJoinSquareAndSignRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveJoinSquareAndSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.square = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.privateCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveJoinSquareAndSignRequest {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      privateCode: isSet(object.privateCode) ? globalThis.String(object.privateCode) : undefined,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
    };
  },

  toJSON(message: ApproveJoinSquareAndSignRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.privateCode !== undefined) {
      obj.privateCode = message.privateCode;
    }
    if (message.nonce !== undefined) {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApproveJoinSquareAndSignRequest>, I>>(base?: I): ApproveJoinSquareAndSignRequest {
    return ApproveJoinSquareAndSignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApproveJoinSquareAndSignRequest>, I>>(
    object: I,
  ): ApproveJoinSquareAndSignRequest {
    const message = createBaseApproveJoinSquareAndSignRequest();
    message.square = object.square ?? "";
    message.user = object.user ?? "";
    message.privateCode = object.privateCode ?? undefined;
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseApproveJoinSquareAndSignResponse(): ApproveJoinSquareAndSignResponse {
  return { approved: false, signature: "", rejectCode: undefined, params: undefined };
}

export const ApproveJoinSquareAndSignResponse = {
  encode(message: ApproveJoinSquareAndSignResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.approved !== false) {
      writer.uint32(8).bool(message.approved);
    }
    if (message.signature !== "") {
      writer.uint32(18).string(message.signature);
    }
    if (message.rejectCode !== undefined) {
      writer.uint32(24).int32(message.rejectCode);
    }
    if (message.params !== undefined) {
      JoinSquareParams.encode(message.params, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveJoinSquareAndSignResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveJoinSquareAndSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.approved = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rejectCode = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.params = JoinSquareParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveJoinSquareAndSignResponse {
    return {
      approved: isSet(object.approved) ? globalThis.Boolean(object.approved) : false,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      rejectCode: isSet(object.rejectCode) ? rejectJoinSquareCodeFromJSON(object.rejectCode) : undefined,
      params: isSet(object.params) ? JoinSquareParams.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: ApproveJoinSquareAndSignResponse): unknown {
    const obj: any = {};
    if (message.approved !== undefined) {
      obj.approved = message.approved;
    }
    if (message.signature !== undefined) {
      obj.signature = message.signature;
    }
    if (message.rejectCode !== undefined) {
      obj.rejectCode = rejectJoinSquareCodeToJSON(message.rejectCode);
    }
    if (message.params !== undefined) {
      obj.params = JoinSquareParams.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApproveJoinSquareAndSignResponse>, I>>(
    base?: I,
  ): ApproveJoinSquareAndSignResponse {
    return ApproveJoinSquareAndSignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApproveJoinSquareAndSignResponse>, I>>(
    object: I,
  ): ApproveJoinSquareAndSignResponse {
    const message = createBaseApproveJoinSquareAndSignResponse();
    message.approved = object.approved ?? false;
    message.signature = object.signature ?? "";
    message.rejectCode = object.rejectCode ?? undefined;
    message.params = (object.params !== undefined && object.params !== null)
      ? JoinSquareParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseApproveTransferSquareAndSignRequest(): ApproveTransferSquareAndSignRequest {
  return { square: "", user: "", privateCode: undefined, nonce: "" };
}

export const ApproveTransferSquareAndSignRequest = {
  encode(message: ApproveTransferSquareAndSignRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== "") {
      writer.uint32(10).string(message.square);
    }
    if (message.user !== "") {
      writer.uint32(18).string(message.user);
    }
    if (message.privateCode !== undefined) {
      writer.uint32(26).string(message.privateCode);
    }
    if (message.nonce !== "") {
      writer.uint32(34).string(message.nonce);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveTransferSquareAndSignRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveTransferSquareAndSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.square = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.privateCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveTransferSquareAndSignRequest {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      privateCode: isSet(object.privateCode) ? globalThis.String(object.privateCode) : undefined,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
    };
  },

  toJSON(message: ApproveTransferSquareAndSignRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.privateCode !== undefined) {
      obj.privateCode = message.privateCode;
    }
    if (message.nonce !== undefined) {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApproveTransferSquareAndSignRequest>, I>>(
    base?: I,
  ): ApproveTransferSquareAndSignRequest {
    return ApproveTransferSquareAndSignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApproveTransferSquareAndSignRequest>, I>>(
    object: I,
  ): ApproveTransferSquareAndSignRequest {
    const message = createBaseApproveTransferSquareAndSignRequest();
    message.square = object.square ?? "";
    message.user = object.user ?? "";
    message.privateCode = object.privateCode ?? undefined;
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseApproveTransferSquareAndSignResponse(): ApproveTransferSquareAndSignResponse {
  return { approved: false, signature: "", rejectCode: undefined, params: undefined };
}

export const ApproveTransferSquareAndSignResponse = {
  encode(message: ApproveTransferSquareAndSignResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.approved !== false) {
      writer.uint32(8).bool(message.approved);
    }
    if (message.signature !== "") {
      writer.uint32(18).string(message.signature);
    }
    if (message.rejectCode !== undefined) {
      writer.uint32(24).int32(message.rejectCode);
    }
    if (message.params !== undefined) {
      TransferSquareParams.encode(message.params, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveTransferSquareAndSignResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveTransferSquareAndSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.approved = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rejectCode = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.params = TransferSquareParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveTransferSquareAndSignResponse {
    return {
      approved: isSet(object.approved) ? globalThis.Boolean(object.approved) : false,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      rejectCode: isSet(object.rejectCode) ? rejectTransferSquareCodeFromJSON(object.rejectCode) : undefined,
      params: isSet(object.params) ? TransferSquareParams.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: ApproveTransferSquareAndSignResponse): unknown {
    const obj: any = {};
    if (message.approved !== undefined) {
      obj.approved = message.approved;
    }
    if (message.signature !== undefined) {
      obj.signature = message.signature;
    }
    if (message.rejectCode !== undefined) {
      obj.rejectCode = rejectTransferSquareCodeToJSON(message.rejectCode);
    }
    if (message.params !== undefined) {
      obj.params = TransferSquareParams.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApproveTransferSquareAndSignResponse>, I>>(
    base?: I,
  ): ApproveTransferSquareAndSignResponse {
    return ApproveTransferSquareAndSignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApproveTransferSquareAndSignResponse>, I>>(
    object: I,
  ): ApproveTransferSquareAndSignResponse {
    const message = createBaseApproveTransferSquareAndSignResponse();
    message.approved = object.approved ?? false;
    message.signature = object.signature ?? "";
    message.rejectCode = object.rejectCode ?? undefined;
    message.params = (object.params !== undefined && object.params !== null)
      ? TransferSquareParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseGetSquareWeeklyPointsRequest(): GetSquareWeeklyPointsRequest {
  return { square: "", week: 0 };
}

export const GetSquareWeeklyPointsRequest = {
  encode(message: GetSquareWeeklyPointsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== "") {
      writer.uint32(10).string(message.square);
    }
    if (message.week !== 0) {
      writer.uint32(16).uint32(message.week);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSquareWeeklyPointsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSquareWeeklyPointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.square = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.week = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSquareWeeklyPointsRequest {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
    };
  },

  toJSON(message: GetSquareWeeklyPointsRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSquareWeeklyPointsRequest>, I>>(base?: I): GetSquareWeeklyPointsRequest {
    return GetSquareWeeklyPointsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSquareWeeklyPointsRequest>, I>>(object: I): GetSquareWeeklyPointsRequest {
    const message = createBaseGetSquareWeeklyPointsRequest();
    message.square = object.square ?? "";
    message.week = object.week ?? 0;
    return message;
  },
};

function createBaseGetSquareWeeklyPointsResponse(): GetSquareWeeklyPointsResponse {
  return { weeklyPoints: 0, week: 0 };
}

export const GetSquareWeeklyPointsResponse = {
  encode(message: GetSquareWeeklyPointsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.weeklyPoints !== 0) {
      writer.uint32(8).uint32(message.weeklyPoints);
    }
    if (message.week !== 0) {
      writer.uint32(16).uint32(message.week);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSquareWeeklyPointsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSquareWeeklyPointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.weeklyPoints = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.week = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSquareWeeklyPointsResponse {
    return {
      weeklyPoints: isSet(object.weeklyPoints) ? globalThis.Number(object.weeklyPoints) : 0,
      week: isSet(object.week) ? globalThis.Number(object.week) : 0,
    };
  },

  toJSON(message: GetSquareWeeklyPointsResponse): unknown {
    const obj: any = {};
    if (message.weeklyPoints !== undefined) {
      obj.weeklyPoints = Math.round(message.weeklyPoints);
    }
    if (message.week !== undefined) {
      obj.week = Math.round(message.week);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSquareWeeklyPointsResponse>, I>>(base?: I): GetSquareWeeklyPointsResponse {
    return GetSquareWeeklyPointsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSquareWeeklyPointsResponse>, I>>(
    object: I,
  ): GetSquareWeeklyPointsResponse {
    const message = createBaseGetSquareWeeklyPointsResponse();
    message.weeklyPoints = object.weeklyPoints ?? 0;
    message.week = object.week ?? 0;
    return message;
  },
};

function createBaseListSquareSpiritHistoriesRequest(): ListSquareSpiritHistoriesRequest {
  return { square: "", pageSize: 0, pageToken: "" };
}

export const ListSquareSpiritHistoriesRequest = {
  encode(message: ListSquareSpiritHistoriesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== "") {
      writer.uint32(10).string(message.square);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSquareSpiritHistoriesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquareSpiritHistoriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.square = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquareSpiritHistoriesRequest {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSquareSpiritHistoriesRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquareSpiritHistoriesRequest>, I>>(
    base?: I,
  ): ListSquareSpiritHistoriesRequest {
    return ListSquareSpiritHistoriesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquareSpiritHistoriesRequest>, I>>(
    object: I,
  ): ListSquareSpiritHistoriesRequest {
    const message = createBaseListSquareSpiritHistoriesRequest();
    message.square = object.square ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSquareSpiritHistoriesResposne(): ListSquareSpiritHistoriesResposne {
  return { histories: [], nextPageToken: "" };
}

export const ListSquareSpiritHistoriesResposne = {
  encode(message: ListSquareSpiritHistoriesResposne, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.histories) {
      SquareSpiritHistory.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSquareSpiritHistoriesResposne {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquareSpiritHistoriesResposne();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.histories.push(SquareSpiritHistory.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquareSpiritHistoriesResposne {
    return {
      histories: globalThis.Array.isArray(object?.histories)
        ? object.histories.map((e: any) => SquareSpiritHistory.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSquareSpiritHistoriesResposne): unknown {
    const obj: any = {};
    if (message.histories?.length) {
      obj.histories = message.histories.map((e) => SquareSpiritHistory.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquareSpiritHistoriesResposne>, I>>(
    base?: I,
  ): ListSquareSpiritHistoriesResposne {
    return ListSquareSpiritHistoriesResposne.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquareSpiritHistoriesResposne>, I>>(
    object: I,
  ): ListSquareSpiritHistoriesResposne {
    const message = createBaseListSquareSpiritHistoriesResposne();
    message.histories = object.histories?.map((e) => SquareSpiritHistory.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListSquareMembersRequest(): ListSquareMembersRequest {
  return { square: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListSquareMembersRequest = {
  encode(message: ListSquareMembersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== "") {
      writer.uint32(10).string(message.square);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSquareMembersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquareMembersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.square = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquareMembersRequest {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListSquareMembersRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    if (message.orderBy !== undefined) {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquareMembersRequest>, I>>(base?: I): ListSquareMembersRequest {
    return ListSquareMembersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquareMembersRequest>, I>>(object: I): ListSquareMembersRequest {
    const message = createBaseListSquareMembersRequest();
    message.square = object.square ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListSquareMembersResponse(): ListSquareMembersResponse {
  return { members: [], nextPageToken: "" };
}

export const ListSquareMembersResponse = {
  encode(message: ListSquareMembersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.members) {
      SquareMember.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSquareMembersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquareMembersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.members.push(SquareMember.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquareMembersResponse {
    return {
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => SquareMember.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSquareMembersResponse): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => SquareMember.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquareMembersResponse>, I>>(base?: I): ListSquareMembersResponse {
    return ListSquareMembersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquareMembersResponse>, I>>(object: I): ListSquareMembersResponse {
    const message = createBaseListSquareMembersResponse();
    message.members = object.members?.map((e) => SquareMember.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListSquareMemberRankingsRequest(): ListSquareMemberRankingsRequest {
  return { square: "", rankType: 0, pageSize: 0, pageToken: "" };
}

export const ListSquareMemberRankingsRequest = {
  encode(message: ListSquareMemberRankingsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== "") {
      writer.uint32(10).string(message.square);
    }
    if (message.rankType !== 0) {
      writer.uint32(16).int32(message.rankType);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSquareMemberRankingsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquareMemberRankingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.square = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.rankType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquareMemberRankingsRequest {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      rankType: isSet(object.rankType) ? squareMemberRankTypeFromJSON(object.rankType) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSquareMemberRankingsRequest): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.rankType !== undefined) {
      obj.rankType = squareMemberRankTypeToJSON(message.rankType);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquareMemberRankingsRequest>, I>>(base?: I): ListSquareMemberRankingsRequest {
    return ListSquareMemberRankingsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquareMemberRankingsRequest>, I>>(
    object: I,
  ): ListSquareMemberRankingsRequest {
    const message = createBaseListSquareMemberRankingsRequest();
    message.square = object.square ?? "";
    message.rankType = object.rankType ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSquareMemberRankingsResponse(): ListSquareMemberRankingsResponse {
  return { rankings: [], nextPageToken: "" };
}

export const ListSquareMemberRankingsResponse = {
  encode(message: ListSquareMemberRankingsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rankings) {
      SquareMemberRanking.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSquareMemberRankingsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSquareMemberRankingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rankings.push(SquareMemberRanking.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSquareMemberRankingsResponse {
    return {
      rankings: globalThis.Array.isArray(object?.rankings)
        ? object.rankings.map((e: any) => SquareMemberRanking.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSquareMemberRankingsResponse): unknown {
    const obj: any = {};
    if (message.rankings?.length) {
      obj.rankings = message.rankings.map((e) => SquareMemberRanking.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSquareMemberRankingsResponse>, I>>(
    base?: I,
  ): ListSquareMemberRankingsResponse {
    return ListSquareMemberRankingsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSquareMemberRankingsResponse>, I>>(
    object: I,
  ): ListSquareMemberRankingsResponse {
    const message = createBaseListSquareMemberRankingsResponse();
    message.rankings = object.rankings?.map((e) => SquareMemberRanking.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSquare(): Square {
  return {
    name: "",
    tokenId: "",
    ownerAddress: "",
    createTime: undefined,
    state: 0,
    signatureId: "",
    joinType: 0,
    join: undefined,
    displayName: "",
    introduction: "",
    minimumStakingAmountToJoinInEth: 0,
    totalMembersStakingAmountInEth: 0,
    multiplier: 0,
    totalPoints: 0,
    capacity: 0,
    occupancy: 0,
    occupancyIncludingPending: 0,
    pfpBoost: undefined,
    nft: undefined,
    spirits: 0,
    stars: 0,
    totalSpirits: 0,
    weeklySpirits: 0,
  };
}

export const Square = {
  encode(message: Square, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tokenId !== "") {
      writer.uint32(18).string(message.tokenId);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(26).string(message.ownerAddress);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.signatureId !== "") {
      writer.uint32(50).string(message.signatureId);
    }
    if (message.joinType !== 0) {
      writer.uint32(56).int32(message.joinType);
    }
    switch (message.join?.$case) {
      case "public":
        Public.encode(message.join.public, writer.uint32(66).fork()).ldelim();
        break;
      case "private":
        Private.encode(message.join.private, writer.uint32(74).fork()).ldelim();
        break;
      case "tokenGated":
        TokenGated.encode(message.join.tokenGated, writer.uint32(82).fork()).ldelim();
        break;
    }
    if (message.displayName !== "") {
      writer.uint32(90).string(message.displayName);
    }
    if (message.introduction !== "") {
      writer.uint32(98).string(message.introduction);
    }
    if (message.minimumStakingAmountToJoinInEth !== 0) {
      writer.uint32(109).float(message.minimumStakingAmountToJoinInEth);
    }
    if (message.totalMembersStakingAmountInEth !== 0) {
      writer.uint32(117).float(message.totalMembersStakingAmountInEth);
    }
    if (message.multiplier !== 0) {
      writer.uint32(125).float(message.multiplier);
    }
    if (message.totalPoints !== 0) {
      writer.uint32(128).uint32(message.totalPoints);
    }
    if (message.capacity !== 0) {
      writer.uint32(136).uint32(message.capacity);
    }
    if (message.occupancy !== 0) {
      writer.uint32(144).uint32(message.occupancy);
    }
    if (message.occupancyIncludingPending !== 0) {
      writer.uint32(152).uint32(message.occupancyIncludingPending);
    }
    if (message.pfpBoost !== undefined) {
      PFPBoost.encode(message.pfpBoost, writer.uint32(162).fork()).ldelim();
    }
    if (message.nft !== undefined) {
      SquareNFT.encode(message.nft, writer.uint32(170).fork()).ldelim();
    }
    if (message.spirits !== 0) {
      writer.uint32(176).uint32(message.spirits);
    }
    if (message.stars !== 0) {
      writer.uint32(184).uint32(message.stars);
    }
    if (message.totalSpirits !== 0) {
      writer.uint32(192).uint32(message.totalSpirits);
    }
    if (message.weeklySpirits !== 0) {
      writer.uint32(200).uint32(message.weeklySpirits);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Square {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSquare();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.signatureId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.joinType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.join = { $case: "public", public: Public.decode(reader, reader.uint32()) };
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.join = { $case: "private", private: Private.decode(reader, reader.uint32()) };
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.join = { $case: "tokenGated", tokenGated: TokenGated.decode(reader, reader.uint32()) };
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.introduction = reader.string();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.minimumStakingAmountToJoinInEth = reader.float();
          continue;
        case 14:
          if (tag !== 117) {
            break;
          }

          message.totalMembersStakingAmountInEth = reader.float();
          continue;
        case 15:
          if (tag !== 125) {
            break;
          }

          message.multiplier = reader.float();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.totalPoints = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.capacity = reader.uint32();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.occupancy = reader.uint32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.occupancyIncludingPending = reader.uint32();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.pfpBoost = PFPBoost.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.nft = SquareNFT.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.spirits = reader.uint32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.stars = reader.uint32();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.totalSpirits = reader.uint32();
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.weeklySpirits = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Square {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
      state: isSet(object.state) ? squareStateFromJSON(object.state) : 0,
      signatureId: isSet(object.signatureId) ? globalThis.String(object.signatureId) : "",
      joinType: isSet(object.joinType) ? squareJoinTypeFromJSON(object.joinType) : 0,
      join: isSet(object.public)
        ? { $case: "public", public: Public.fromJSON(object.public) }
        : isSet(object.private)
        ? { $case: "private", private: Private.fromJSON(object.private) }
        : isSet(object.tokenGated)
        ? { $case: "tokenGated", tokenGated: TokenGated.fromJSON(object.tokenGated) }
        : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : "",
      minimumStakingAmountToJoinInEth: isSet(object.minimumStakingAmountToJoinInEth)
        ? globalThis.Number(object.minimumStakingAmountToJoinInEth)
        : 0,
      totalMembersStakingAmountInEth: isSet(object.totalMembersStakingAmountInEth)
        ? globalThis.Number(object.totalMembersStakingAmountInEth)
        : 0,
      multiplier: isSet(object.multiplier) ? globalThis.Number(object.multiplier) : 0,
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
      capacity: isSet(object.capacity) ? globalThis.Number(object.capacity) : 0,
      occupancy: isSet(object.occupancy) ? globalThis.Number(object.occupancy) : 0,
      occupancyIncludingPending: isSet(object.occupancyIncludingPending)
        ? globalThis.Number(object.occupancyIncludingPending)
        : 0,
      pfpBoost: isSet(object.pfpBoost) ? PFPBoost.fromJSON(object.pfpBoost) : undefined,
      nft: isSet(object.nft) ? SquareNFT.fromJSON(object.nft) : undefined,
      spirits: isSet(object.spirits) ? globalThis.Number(object.spirits) : 0,
      stars: isSet(object.stars) ? globalThis.Number(object.stars) : 0,
      totalSpirits: isSet(object.totalSpirits) ? globalThis.Number(object.totalSpirits) : 0,
      weeklySpirits: isSet(object.weeklySpirits) ? globalThis.Number(object.weeklySpirits) : 0,
    };
  },

  toJSON(message: Square): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.tokenId !== undefined) {
      obj.tokenId = message.tokenId;
    }
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    if (message.state !== undefined) {
      obj.state = squareStateToJSON(message.state);
    }
    if (message.signatureId !== undefined) {
      obj.signatureId = message.signatureId;
    }
    if (message.joinType !== undefined) {
      obj.joinType = squareJoinTypeToJSON(message.joinType);
    }
    if (message.join?.$case === "public") {
      obj.public = Public.toJSON(message.join.public);
    }
    if (message.join?.$case === "private") {
      obj.private = Private.toJSON(message.join.private);
    }
    if (message.join?.$case === "tokenGated") {
      obj.tokenGated = TokenGated.toJSON(message.join.tokenGated);
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.introduction !== undefined) {
      obj.introduction = message.introduction;
    }
    if (message.minimumStakingAmountToJoinInEth !== undefined) {
      obj.minimumStakingAmountToJoinInEth = message.minimumStakingAmountToJoinInEth;
    }
    if (message.totalMembersStakingAmountInEth !== undefined) {
      obj.totalMembersStakingAmountInEth = message.totalMembersStakingAmountInEth;
    }
    if (message.multiplier !== undefined) {
      obj.multiplier = message.multiplier;
    }
    if (message.totalPoints !== undefined) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    if (message.capacity !== undefined) {
      obj.capacity = Math.round(message.capacity);
    }
    if (message.occupancy !== undefined) {
      obj.occupancy = Math.round(message.occupancy);
    }
    if (message.occupancyIncludingPending !== undefined) {
      obj.occupancyIncludingPending = Math.round(message.occupancyIncludingPending);
    }
    if (message.pfpBoost !== undefined) {
      obj.pfpBoost = PFPBoost.toJSON(message.pfpBoost);
    }
    if (message.nft !== undefined) {
      obj.nft = SquareNFT.toJSON(message.nft);
    }
    if (message.spirits !== undefined) {
      obj.spirits = Math.round(message.spirits);
    }
    if (message.stars !== undefined) {
      obj.stars = Math.round(message.stars);
    }
    if (message.totalSpirits !== undefined) {
      obj.totalSpirits = Math.round(message.totalSpirits);
    }
    if (message.weeklySpirits !== undefined) {
      obj.weeklySpirits = Math.round(message.weeklySpirits);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Square>, I>>(base?: I): Square {
    return Square.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Square>, I>>(object: I): Square {
    const message = createBaseSquare();
    message.name = object.name ?? "";
    message.tokenId = object.tokenId ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.createTime = object.createTime ?? undefined;
    message.state = object.state ?? 0;
    message.signatureId = object.signatureId ?? "";
    message.joinType = object.joinType ?? 0;
    if (object.join?.$case === "public" && object.join?.public !== undefined && object.join?.public !== null) {
      message.join = { $case: "public", public: Public.fromPartial(object.join.public) };
    }
    if (object.join?.$case === "private" && object.join?.private !== undefined && object.join?.private !== null) {
      message.join = { $case: "private", private: Private.fromPartial(object.join.private) };
    }
    if (
      object.join?.$case === "tokenGated" && object.join?.tokenGated !== undefined && object.join?.tokenGated !== null
    ) {
      message.join = { $case: "tokenGated", tokenGated: TokenGated.fromPartial(object.join.tokenGated) };
    }
    message.displayName = object.displayName ?? "";
    message.introduction = object.introduction ?? "";
    message.minimumStakingAmountToJoinInEth = object.minimumStakingAmountToJoinInEth ?? 0;
    message.totalMembersStakingAmountInEth = object.totalMembersStakingAmountInEth ?? 0;
    message.multiplier = object.multiplier ?? 0;
    message.totalPoints = object.totalPoints ?? 0;
    message.capacity = object.capacity ?? 0;
    message.occupancy = object.occupancy ?? 0;
    message.occupancyIncludingPending = object.occupancyIncludingPending ?? 0;
    message.pfpBoost = (object.pfpBoost !== undefined && object.pfpBoost !== null)
      ? PFPBoost.fromPartial(object.pfpBoost)
      : undefined;
    message.nft = (object.nft !== undefined && object.nft !== null) ? SquareNFT.fromPartial(object.nft) : undefined;
    message.spirits = object.spirits ?? 0;
    message.stars = object.stars ?? 0;
    message.totalSpirits = object.totalSpirits ?? 0;
    message.weeklySpirits = object.weeklySpirits ?? 0;
    return message;
  },
};

function createBasePFPBoost(): PFPBoost {
  return { percentage: 0, memberCount: 0, nftContract: "" };
}

export const PFPBoost = {
  encode(message: PFPBoost, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.percentage !== 0) {
      writer.uint32(13).float(message.percentage);
    }
    if (message.memberCount !== 0) {
      writer.uint32(16).uint32(message.memberCount);
    }
    if (message.nftContract !== "") {
      writer.uint32(26).string(message.nftContract);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PFPBoost {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePFPBoost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.percentage = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.memberCount = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nftContract = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PFPBoost {
    return {
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : 0,
      memberCount: isSet(object.memberCount) ? globalThis.Number(object.memberCount) : 0,
      nftContract: isSet(object.nftContract) ? globalThis.String(object.nftContract) : "",
    };
  },

  toJSON(message: PFPBoost): unknown {
    const obj: any = {};
    if (message.percentage !== undefined) {
      obj.percentage = message.percentage;
    }
    if (message.memberCount !== undefined) {
      obj.memberCount = Math.round(message.memberCount);
    }
    if (message.nftContract !== undefined) {
      obj.nftContract = message.nftContract;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PFPBoost>, I>>(base?: I): PFPBoost {
    return PFPBoost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PFPBoost>, I>>(object: I): PFPBoost {
    const message = createBasePFPBoost();
    message.percentage = object.percentage ?? 0;
    message.memberCount = object.memberCount ?? 0;
    message.nftContract = object.nftContract ?? "";
    return message;
  },
};

function createBasePublic(): Public {
  return {};
}

export const Public = {
  encode(_: Public, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Public {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Public {
    return {};
  },

  toJSON(_: Public): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Public>, I>>(base?: I): Public {
    return Public.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Public>, I>>(_: I): Public {
    const message = createBasePublic();
    return message;
  },
};

function createBasePrivate(): Private {
  return { code: "" };
}

export const Private = {
  encode(message: Private, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Private {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Private {
    return { code: isSet(object.code) ? globalThis.String(object.code) : "" };
  },

  toJSON(message: Private): unknown {
    const obj: any = {};
    if (message.code !== undefined) {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Private>, I>>(base?: I): Private {
    return Private.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Private>, I>>(object: I): Private {
    const message = createBasePrivate();
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseTokenGated(): TokenGated {
  return { nftContract: "" };
}

export const TokenGated = {
  encode(message: TokenGated, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nftContract !== "") {
      writer.uint32(10).string(message.nftContract);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenGated {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenGated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nftContract = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenGated {
    return { nftContract: isSet(object.nftContract) ? globalThis.String(object.nftContract) : "" };
  },

  toJSON(message: TokenGated): unknown {
    const obj: any = {};
    if (message.nftContract !== undefined) {
      obj.nftContract = message.nftContract;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenGated>, I>>(base?: I): TokenGated {
    return TokenGated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenGated>, I>>(object: I): TokenGated {
    const message = createBaseTokenGated();
    message.nftContract = object.nftContract ?? "";
    return message;
  },
};

function createBaseSquareNFT(): SquareNFT {
  return { tokenId: 0, imageUri: "", metadataUri: "" };
}

export const SquareNFT = {
  encode(message: SquareNFT, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenId !== 0) {
      writer.uint32(8).uint32(message.tokenId);
    }
    if (message.imageUri !== "") {
      writer.uint32(18).string(message.imageUri);
    }
    if (message.metadataUri !== "") {
      writer.uint32(26).string(message.metadataUri);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SquareNFT {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSquareNFT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tokenId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadataUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SquareNFT {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      metadataUri: isSet(object.metadataUri) ? globalThis.String(object.metadataUri) : "",
    };
  },

  toJSON(message: SquareNFT): unknown {
    const obj: any = {};
    if (message.tokenId !== undefined) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.imageUri !== undefined) {
      obj.imageUri = message.imageUri;
    }
    if (message.metadataUri !== undefined) {
      obj.metadataUri = message.metadataUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SquareNFT>, I>>(base?: I): SquareNFT {
    return SquareNFT.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SquareNFT>, I>>(object: I): SquareNFT {
    const message = createBaseSquareNFT();
    message.tokenId = object.tokenId ?? 0;
    message.imageUri = object.imageUri ?? "";
    message.metadataUri = object.metadataUri ?? "";
    return message;
  },
};

function createBaseSquareMember(): SquareMember {
  return { name: "", squareTokenId: "", userAddress: "", type: 0, totalPoints: 0, joinTime: undefined };
}

export const SquareMember = {
  encode(message: SquareMember, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.squareTokenId !== "") {
      writer.uint32(18).string(message.squareTokenId);
    }
    if (message.userAddress !== "") {
      writer.uint32(26).string(message.userAddress);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.totalPoints !== 0) {
      writer.uint32(40).uint32(message.totalPoints);
    }
    if (message.joinTime !== undefined) {
      Timestamp.encode(toTimestamp(message.joinTime), writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SquareMember {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSquareMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.squareTokenId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalPoints = reader.uint32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.joinTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SquareMember {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      squareTokenId: isSet(object.squareTokenId) ? globalThis.String(object.squareTokenId) : "",
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      type: isSet(object.type) ? squareMemberTypeFromJSON(object.type) : 0,
      totalPoints: isSet(object.totalPoints) ? globalThis.Number(object.totalPoints) : 0,
      joinTime: isSet(object.joinTime) ? globalThis.String(object.joinTime) : undefined,
    };
  },

  toJSON(message: SquareMember): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.squareTokenId !== undefined) {
      obj.squareTokenId = message.squareTokenId;
    }
    if (message.userAddress !== undefined) {
      obj.userAddress = message.userAddress;
    }
    if (message.type !== undefined) {
      obj.type = squareMemberTypeToJSON(message.type);
    }
    if (message.totalPoints !== undefined) {
      obj.totalPoints = Math.round(message.totalPoints);
    }
    if (message.joinTime !== undefined) {
      obj.joinTime = message.joinTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SquareMember>, I>>(base?: I): SquareMember {
    return SquareMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SquareMember>, I>>(object: I): SquareMember {
    const message = createBaseSquareMember();
    message.name = object.name ?? "";
    message.squareTokenId = object.squareTokenId ?? "";
    message.userAddress = object.userAddress ?? "";
    message.type = object.type ?? 0;
    message.totalPoints = object.totalPoints ?? 0;
    message.joinTime = object.joinTime ?? undefined;
    return message;
  },
};

function createBaseSquareMemberRanking(): SquareMemberRanking {
  return { rank: 0, points: 0, member: undefined };
}

export const SquareMemberRanking = {
  encode(message: SquareMemberRanking, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.points !== 0) {
      writer.uint32(16).uint32(message.points);
    }
    if (message.member !== undefined) {
      SquareMember.encode(message.member, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SquareMemberRanking {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSquareMemberRanking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.points = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.member = SquareMember.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SquareMemberRanking {
    return {
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      points: isSet(object.points) ? globalThis.Number(object.points) : 0,
      member: isSet(object.member) ? SquareMember.fromJSON(object.member) : undefined,
    };
  },

  toJSON(message: SquareMemberRanking): unknown {
    const obj: any = {};
    if (message.rank !== undefined) {
      obj.rank = Math.round(message.rank);
    }
    if (message.points !== undefined) {
      obj.points = Math.round(message.points);
    }
    if (message.member !== undefined) {
      obj.member = SquareMember.toJSON(message.member);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SquareMemberRanking>, I>>(base?: I): SquareMemberRanking {
    return SquareMemberRanking.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SquareMemberRanking>, I>>(object: I): SquareMemberRanking {
    const message = createBaseSquareMemberRanking();
    message.rank = object.rank ?? 0;
    message.points = object.points ?? 0;
    message.member = (object.member !== undefined && object.member !== null)
      ? SquareMember.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseSquareSpiritHistory(): SquareSpiritHistory {
  return { square: "", type: 0, amount: 0, createTime: undefined };
}

export const SquareSpiritHistory = {
  encode(message: SquareSpiritHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.square !== "") {
      writer.uint32(18).string(message.square);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint32(message.amount);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SquareSpiritHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSquareSpiritHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.square = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SquareSpiritHistory {
    return {
      square: isSet(object.square) ? globalThis.String(object.square) : "",
      type: isSet(object.type) ? spiritTypeFromJSON(object.type) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : undefined,
    };
  },

  toJSON(message: SquareSpiritHistory): unknown {
    const obj: any = {};
    if (message.square !== undefined) {
      obj.square = message.square;
    }
    if (message.type !== undefined) {
      obj.type = spiritTypeToJSON(message.type);
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SquareSpiritHistory>, I>>(base?: I): SquareSpiritHistory {
    return SquareSpiritHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SquareSpiritHistory>, I>>(object: I): SquareSpiritHistory {
    const message = createBaseSquareSpiritHistory();
    message.square = object.square ?? "";
    message.type = object.type ?? 0;
    message.amount = object.amount ?? 0;
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

/** SquareService contains the function to interact with the Square of the spacebar */
export interface SquareService {
  /** GetSquare will return Square. */
  GetSquare(request: GetSquareRequest): Promise<Square>;
  /** ListSquares will return Squares. */
  ListSquares(request: ListSquaresRequest): Promise<ListSquaresResponse>;
  /** UpdateSquare update Square. */
  UpdateSquare(request: UpdateSquareRequest): Promise<Square>;
  /** GetSquareWeeklySpirits will return weekly spirits of the Square. */
  GetSquareWeeklySpirits(request: GetSquareWeeklySpiritsRequest): Promise<GetSquareWeeklySpiritsResponse>;
  /** CheckMintEligibility check if the user is eligible to mint the NFT of the Square. */
  CheckMintEligibility(request: CheckMintEligibilityRequest): Promise<CheckMintEligibilityResponse>;
  /** ValidateDisplayNameAvailability check if the display name is available. */
  ValidateDisplayNameAvailability(
    request: ValidateDisplayNameAvailabilityRequest,
  ): Promise<ValidateDisplayNameAvailabilityResponse>;
  /** CreateSquareAndSign create Square with CREATED_PENDING state and response with signature to sign the onchain tx. */
  CreateSquareAndSign(request: CreateSquareAndSignRequest): Promise<CreateSquareAndSignResponse>;
  /** ApproveJoinSquareAndSign verify the member join the square and return signature to sign the onchain tx. */
  ApproveJoinSquareAndSign(request: ApproveJoinSquareAndSignRequest): Promise<ApproveJoinSquareAndSignResponse>;
  /** ApproveTransferSquareAndSign verify the member transfer the square and return signature to sign the onchain tx. */
  ApproveTransferSquareAndSign(
    request: ApproveTransferSquareAndSignRequest,
  ): Promise<ApproveTransferSquareAndSignResponse>;
  /** GetSquareWeeklyPoints will return Square. */
  GetSquareWeeklyPoints(request: GetSquareWeeklyPointsRequest): Promise<GetSquareWeeklyPointsResponse>;
  /** ListSquareSpiritHistories will return the spirit history of the Square. */
  ListSquareSpiritHistories(request: ListSquareSpiritHistoriesRequest): Promise<ListSquareSpiritHistoriesResposne>;
  /** ListSquareMembers will return the members of the Square. */
  ListSquareMembers(request: ListSquareMembersRequest): Promise<ListSquareMembersResponse>;
  /** ListSquareMemberRankings will return the leaderboard of the Square. */
  ListSquareMemberRankings(request: ListSquareMemberRankingsRequest): Promise<ListSquareMemberRankingsResponse>;
}

export const SquareServiceServiceName = "blast.v1.square.SquareService";
export class SquareServiceClientImpl implements SquareService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SquareServiceServiceName;
    this.rpc = rpc;
    this.GetSquare = this.GetSquare.bind(this);
    this.ListSquares = this.ListSquares.bind(this);
    this.UpdateSquare = this.UpdateSquare.bind(this);
    this.GetSquareWeeklySpirits = this.GetSquareWeeklySpirits.bind(this);
    this.CheckMintEligibility = this.CheckMintEligibility.bind(this);
    this.ValidateDisplayNameAvailability = this.ValidateDisplayNameAvailability.bind(this);
    this.CreateSquareAndSign = this.CreateSquareAndSign.bind(this);
    this.ApproveJoinSquareAndSign = this.ApproveJoinSquareAndSign.bind(this);
    this.ApproveTransferSquareAndSign = this.ApproveTransferSquareAndSign.bind(this);
    this.GetSquareWeeklyPoints = this.GetSquareWeeklyPoints.bind(this);
    this.ListSquareSpiritHistories = this.ListSquareSpiritHistories.bind(this);
    this.ListSquareMembers = this.ListSquareMembers.bind(this);
    this.ListSquareMemberRankings = this.ListSquareMemberRankings.bind(this);
  }
  GetSquare(request: GetSquareRequest): Promise<Square> {
    const data = GetSquareRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSquare", data);
    return promise.then((data) => Square.decode(_m0.Reader.create(data)));
  }

  ListSquares(request: ListSquaresRequest): Promise<ListSquaresResponse> {
    const data = ListSquaresRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSquares", data);
    return promise.then((data) => ListSquaresResponse.decode(_m0.Reader.create(data)));
  }

  UpdateSquare(request: UpdateSquareRequest): Promise<Square> {
    const data = UpdateSquareRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSquare", data);
    return promise.then((data) => Square.decode(_m0.Reader.create(data)));
  }

  GetSquareWeeklySpirits(request: GetSquareWeeklySpiritsRequest): Promise<GetSquareWeeklySpiritsResponse> {
    const data = GetSquareWeeklySpiritsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSquareWeeklySpirits", data);
    return promise.then((data) => GetSquareWeeklySpiritsResponse.decode(_m0.Reader.create(data)));
  }

  CheckMintEligibility(request: CheckMintEligibilityRequest): Promise<CheckMintEligibilityResponse> {
    const data = CheckMintEligibilityRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CheckMintEligibility", data);
    return promise.then((data) => CheckMintEligibilityResponse.decode(_m0.Reader.create(data)));
  }

  ValidateDisplayNameAvailability(
    request: ValidateDisplayNameAvailabilityRequest,
  ): Promise<ValidateDisplayNameAvailabilityResponse> {
    const data = ValidateDisplayNameAvailabilityRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ValidateDisplayNameAvailability", data);
    return promise.then((data) => ValidateDisplayNameAvailabilityResponse.decode(_m0.Reader.create(data)));
  }

  CreateSquareAndSign(request: CreateSquareAndSignRequest): Promise<CreateSquareAndSignResponse> {
    const data = CreateSquareAndSignRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateSquareAndSign", data);
    return promise.then((data) => CreateSquareAndSignResponse.decode(_m0.Reader.create(data)));
  }

  ApproveJoinSquareAndSign(request: ApproveJoinSquareAndSignRequest): Promise<ApproveJoinSquareAndSignResponse> {
    const data = ApproveJoinSquareAndSignRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ApproveJoinSquareAndSign", data);
    return promise.then((data) => ApproveJoinSquareAndSignResponse.decode(_m0.Reader.create(data)));
  }

  ApproveTransferSquareAndSign(
    request: ApproveTransferSquareAndSignRequest,
  ): Promise<ApproveTransferSquareAndSignResponse> {
    const data = ApproveTransferSquareAndSignRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ApproveTransferSquareAndSign", data);
    return promise.then((data) => ApproveTransferSquareAndSignResponse.decode(_m0.Reader.create(data)));
  }

  GetSquareWeeklyPoints(request: GetSquareWeeklyPointsRequest): Promise<GetSquareWeeklyPointsResponse> {
    const data = GetSquareWeeklyPointsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSquareWeeklyPoints", data);
    return promise.then((data) => GetSquareWeeklyPointsResponse.decode(_m0.Reader.create(data)));
  }

  ListSquareSpiritHistories(request: ListSquareSpiritHistoriesRequest): Promise<ListSquareSpiritHistoriesResposne> {
    const data = ListSquareSpiritHistoriesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSquareSpiritHistories", data);
    return promise.then((data) => ListSquareSpiritHistoriesResposne.decode(_m0.Reader.create(data)));
  }

  ListSquareMembers(request: ListSquareMembersRequest): Promise<ListSquareMembersResponse> {
    const data = ListSquareMembersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSquareMembers", data);
    return promise.then((data) => ListSquareMembersResponse.decode(_m0.Reader.create(data)));
  }

  ListSquareMemberRankings(request: ListSquareMemberRankingsRequest): Promise<ListSquareMemberRankingsResponse> {
    const data = ListSquareMemberRankingsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSquareMemberRankings", data);
    return promise.then((data) => ListSquareMemberRankingsResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
