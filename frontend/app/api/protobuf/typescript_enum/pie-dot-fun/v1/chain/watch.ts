// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: pie-dot-fun/v1/chain/watch.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "piedotfun.v1.chain";

export enum BasketEventExtraInfoKey {
  BASKET_EXTRA_INFO_KEY_UNSPECIFIED = 0,
  BASKET_EXTRA_INFO_KEY_VALUE_USDC = 1,
  BASKET_EXTRA_INFO_KEY_VALUE_SOL = 2,
}

export function basketEventExtraInfoKeyFromJSON(object: any): BasketEventExtraInfoKey {
  switch (object) {
    case 0:
    case "BASKET_EXTRA_INFO_KEY_UNSPECIFIED":
      return BasketEventExtraInfoKey.BASKET_EXTRA_INFO_KEY_UNSPECIFIED;
    case 1:
    case "BASKET_EXTRA_INFO_KEY_VALUE_USDC":
      return BasketEventExtraInfoKey.BASKET_EXTRA_INFO_KEY_VALUE_USDC;
    case 2:
    case "BASKET_EXTRA_INFO_KEY_VALUE_SOL":
      return BasketEventExtraInfoKey.BASKET_EXTRA_INFO_KEY_VALUE_SOL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BasketEventExtraInfoKey");
  }
}

export function basketEventExtraInfoKeyToJSON(object: BasketEventExtraInfoKey): string {
  switch (object) {
    case BasketEventExtraInfoKey.BASKET_EXTRA_INFO_KEY_UNSPECIFIED:
      return "BASKET_EXTRA_INFO_KEY_UNSPECIFIED";
    case BasketEventExtraInfoKey.BASKET_EXTRA_INFO_KEY_VALUE_USDC:
      return "BASKET_EXTRA_INFO_KEY_VALUE_USDC";
    case BasketEventExtraInfoKey.BASKET_EXTRA_INFO_KEY_VALUE_SOL:
      return "BASKET_EXTRA_INFO_KEY_VALUE_SOL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BasketEventExtraInfoKey");
  }
}

/** BasketComponent represents a component of a basket with its mint and ratio */
export interface BasketComponent {
  /** solana.PublicKey */
  mint: string;
  ratio: string;
}

/** CreateBasketEvent represents the event of creating a new basket */
export interface CreateBasketEvent {
  basketId: number;
  name: string;
  symbol: string;
  uri: string;
  /** solana.PublicKey */
  creator: string;
  /** solana.PublicKey */
  mint: string;
  components: BasketComponent[];
}

/** StartRebalancingEvent represents the event of starting basket rebalancing */
export interface StartRebalancingEvent {
  basketId: number;
  /** solana.PublicKey */
  mint: string;
  timestamp: number;
}

/** StopRebalancingEvent represents the event of stopping basket rebalancing */
export interface StopRebalancingEvent {
  basketId: number;
  /** solana.PublicKey */
  mint: string;
  components: BasketComponent[];
  timestamp: number;
}

/** RedeemBasketTokenEvent represents the event of redeeming basket tokens */
export interface RedeemBasketTokenEvent {
  basketId: number;
  /** solana.PublicKey */
  user: string;
  /** solana.PublicKey */
  basketMint: string;
  amount: number;
}

/** MintBasketTokenEvent represents the event of minting basket tokens */
export interface MintBasketTokenEvent {
  basketId: number;
  /** solana.PublicKey */
  user: string;
  /** solana.PublicKey */
  basketMint: string;
  amount: number;
}

/** TransferBasketEvent represents the event of transferring basket tokens */
export interface TransferBasketEvent {
  /** solana.PublicKey */
  basketMint: string;
  /** solana.PublicKey */
  from: string;
  /** solana.PublicKey */
  to: string;
  amount: number;
}

function createBaseBasketComponent(): BasketComponent {
  return { mint: "", ratio: "" };
}

export const BasketComponent = {
  encode(message: BasketComponent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.ratio !== "") {
      writer.uint32(18).string(message.ratio);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasketComponent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ratio = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketComponent {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      ratio: isSet(object.ratio) ? globalThis.String(object.ratio) : "",
    };
  },

  toJSON(message: BasketComponent): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.ratio !== undefined) {
      obj.ratio = message.ratio;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketComponent>, I>>(base?: I): BasketComponent {
    return BasketComponent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketComponent>, I>>(object: I): BasketComponent {
    const message = createBaseBasketComponent();
    message.mint = object.mint ?? "";
    message.ratio = object.ratio ?? "";
    return message;
  },
};

function createBaseCreateBasketEvent(): CreateBasketEvent {
  return { basketId: 0, name: "", symbol: "", uri: "", creator: "", mint: "", components: [] };
}

export const CreateBasketEvent = {
  encode(message: CreateBasketEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketId !== 0) {
      writer.uint32(8).uint64(message.basketId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.uri !== "") {
      writer.uint32(34).string(message.uri);
    }
    if (message.creator !== "") {
      writer.uint32(42).string(message.creator);
    }
    if (message.mint !== "") {
      writer.uint32(50).string(message.mint);
    }
    for (const v of message.components) {
      BasketComponent.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateBasketEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBasketEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.basketId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.components.push(BasketComponent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBasketEvent {
    return {
      basketId: isSet(object.basketId) ? globalThis.Number(object.basketId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => BasketComponent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateBasketEvent): unknown {
    const obj: any = {};
    if (message.basketId !== undefined) {
      obj.basketId = Math.round(message.basketId);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.creator !== undefined) {
      obj.creator = message.creator;
    }
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => BasketComponent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBasketEvent>, I>>(base?: I): CreateBasketEvent {
    return CreateBasketEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBasketEvent>, I>>(object: I): CreateBasketEvent {
    const message = createBaseCreateBasketEvent();
    message.basketId = object.basketId ?? 0;
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.uri = object.uri ?? "";
    message.creator = object.creator ?? "";
    message.mint = object.mint ?? "";
    message.components = object.components?.map((e) => BasketComponent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStartRebalancingEvent(): StartRebalancingEvent {
  return { basketId: 0, mint: "", timestamp: 0 };
}

export const StartRebalancingEvent = {
  encode(message: StartRebalancingEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketId !== 0) {
      writer.uint32(8).uint64(message.basketId);
    }
    if (message.mint !== "") {
      writer.uint32(18).string(message.mint);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartRebalancingEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRebalancingEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.basketId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartRebalancingEvent {
    return {
      basketId: isSet(object.basketId) ? globalThis.Number(object.basketId) : 0,
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: StartRebalancingEvent): unknown {
    const obj: any = {};
    if (message.basketId !== undefined) {
      obj.basketId = Math.round(message.basketId);
    }
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartRebalancingEvent>, I>>(base?: I): StartRebalancingEvent {
    return StartRebalancingEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartRebalancingEvent>, I>>(object: I): StartRebalancingEvent {
    const message = createBaseStartRebalancingEvent();
    message.basketId = object.basketId ?? 0;
    message.mint = object.mint ?? "";
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseStopRebalancingEvent(): StopRebalancingEvent {
  return { basketId: 0, mint: "", components: [], timestamp: 0 };
}

export const StopRebalancingEvent = {
  encode(message: StopRebalancingEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketId !== 0) {
      writer.uint32(8).uint64(message.basketId);
    }
    if (message.mint !== "") {
      writer.uint32(18).string(message.mint);
    }
    for (const v of message.components) {
      BasketComponent.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StopRebalancingEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopRebalancingEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.basketId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.components.push(BasketComponent.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopRebalancingEvent {
    return {
      basketId: isSet(object.basketId) ? globalThis.Number(object.basketId) : 0,
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => BasketComponent.fromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: StopRebalancingEvent): unknown {
    const obj: any = {};
    if (message.basketId !== undefined) {
      obj.basketId = Math.round(message.basketId);
    }
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => BasketComponent.toJSON(e));
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StopRebalancingEvent>, I>>(base?: I): StopRebalancingEvent {
    return StopRebalancingEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopRebalancingEvent>, I>>(object: I): StopRebalancingEvent {
    const message = createBaseStopRebalancingEvent();
    message.basketId = object.basketId ?? 0;
    message.mint = object.mint ?? "";
    message.components = object.components?.map((e) => BasketComponent.fromPartial(e)) || [];
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseRedeemBasketTokenEvent(): RedeemBasketTokenEvent {
  return { basketId: 0, user: "", basketMint: "", amount: 0 };
}

export const RedeemBasketTokenEvent = {
  encode(message: RedeemBasketTokenEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketId !== 0) {
      writer.uint32(8).uint64(message.basketId);
    }
    if (message.user !== "") {
      writer.uint32(18).string(message.user);
    }
    if (message.basketMint !== "") {
      writer.uint32(26).string(message.basketMint);
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RedeemBasketTokenEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedeemBasketTokenEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.basketId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.basketMint = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedeemBasketTokenEvent {
    return {
      basketId: isSet(object.basketId) ? globalThis.Number(object.basketId) : 0,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      basketMint: isSet(object.basketMint) ? globalThis.String(object.basketMint) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: RedeemBasketTokenEvent): unknown {
    const obj: any = {};
    if (message.basketId !== undefined) {
      obj.basketId = Math.round(message.basketId);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.basketMint !== undefined) {
      obj.basketMint = message.basketMint;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedeemBasketTokenEvent>, I>>(base?: I): RedeemBasketTokenEvent {
    return RedeemBasketTokenEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedeemBasketTokenEvent>, I>>(object: I): RedeemBasketTokenEvent {
    const message = createBaseRedeemBasketTokenEvent();
    message.basketId = object.basketId ?? 0;
    message.user = object.user ?? "";
    message.basketMint = object.basketMint ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseMintBasketTokenEvent(): MintBasketTokenEvent {
  return { basketId: 0, user: "", basketMint: "", amount: 0 };
}

export const MintBasketTokenEvent = {
  encode(message: MintBasketTokenEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketId !== 0) {
      writer.uint32(8).uint64(message.basketId);
    }
    if (message.user !== "") {
      writer.uint32(18).string(message.user);
    }
    if (message.basketMint !== "") {
      writer.uint32(26).string(message.basketMint);
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MintBasketTokenEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintBasketTokenEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.basketId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.basketMint = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintBasketTokenEvent {
    return {
      basketId: isSet(object.basketId) ? globalThis.Number(object.basketId) : 0,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      basketMint: isSet(object.basketMint) ? globalThis.String(object.basketMint) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: MintBasketTokenEvent): unknown {
    const obj: any = {};
    if (message.basketId !== undefined) {
      obj.basketId = Math.round(message.basketId);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.basketMint !== undefined) {
      obj.basketMint = message.basketMint;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MintBasketTokenEvent>, I>>(base?: I): MintBasketTokenEvent {
    return MintBasketTokenEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MintBasketTokenEvent>, I>>(object: I): MintBasketTokenEvent {
    const message = createBaseMintBasketTokenEvent();
    message.basketId = object.basketId ?? 0;
    message.user = object.user ?? "";
    message.basketMint = object.basketMint ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseTransferBasketEvent(): TransferBasketEvent {
  return { basketMint: "", from: "", to: "", amount: 0 };
}

export const TransferBasketEvent = {
  encode(message: TransferBasketEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketMint !== "") {
      writer.uint32(10).string(message.basketMint);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(26).string(message.to);
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransferBasketEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferBasketEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketMint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferBasketEvent {
    return {
      basketMint: isSet(object.basketMint) ? globalThis.String(object.basketMint) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: TransferBasketEvent): unknown {
    const obj: any = {};
    if (message.basketMint !== undefined) {
      obj.basketMint = message.basketMint;
    }
    if (message.from !== undefined) {
      obj.from = message.from;
    }
    if (message.to !== undefined) {
      obj.to = message.to;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferBasketEvent>, I>>(base?: I): TransferBasketEvent {
    return TransferBasketEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferBasketEvent>, I>>(object: I): TransferBasketEvent {
    const message = createBaseTransferBasketEvent();
    message.basketMint = object.basketMint ?? "";
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
