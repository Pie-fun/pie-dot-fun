// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: pie-dot-fun/v1/basket-token-market.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import {
  Currency,
  currencyFromJSON,
  currencyToJSON,
  Money,
  Percentage,
  PriceChangesByPeriod,
  Quantity,
} from "./common";

export const protobufPackage = "piedotfun.v1";

export enum TickInterval {
  INTERVAL_UNSPECIFIED = 0,
  /** @deprecated */
  INTERVAL_1_SECOND = 1,
  INTERVAL_1_MINUTE = 2,
  INTERVAL_15_MINUTES = 3,
  INTERVAL_1_HOUR = 4,
  INTERVAL_4_HOUR = 5,
  INTERVAL_1_DAY = 6,
}

export function tickIntervalFromJSON(object: any): TickInterval {
  switch (object) {
    case 0:
    case "INTERVAL_UNSPECIFIED":
      return TickInterval.INTERVAL_UNSPECIFIED;
    case 1:
    case "INTERVAL_1_SECOND":
      return TickInterval.INTERVAL_1_SECOND;
    case 2:
    case "INTERVAL_1_MINUTE":
      return TickInterval.INTERVAL_1_MINUTE;
    case 3:
    case "INTERVAL_15_MINUTES":
      return TickInterval.INTERVAL_15_MINUTES;
    case 4:
    case "INTERVAL_1_HOUR":
      return TickInterval.INTERVAL_1_HOUR;
    case 5:
    case "INTERVAL_4_HOUR":
      return TickInterval.INTERVAL_4_HOUR;
    case 6:
    case "INTERVAL_1_DAY":
      return TickInterval.INTERVAL_1_DAY;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TickInterval");
  }
}

export function tickIntervalToJSON(object: TickInterval): string {
  switch (object) {
    case TickInterval.INTERVAL_UNSPECIFIED:
      return "INTERVAL_UNSPECIFIED";
    case TickInterval.INTERVAL_1_SECOND:
      return "INTERVAL_1_SECOND";
    case TickInterval.INTERVAL_1_MINUTE:
      return "INTERVAL_1_MINUTE";
    case TickInterval.INTERVAL_15_MINUTES:
      return "INTERVAL_15_MINUTES";
    case TickInterval.INTERVAL_1_HOUR:
      return "INTERVAL_1_HOUR";
    case TickInterval.INTERVAL_4_HOUR:
      return "INTERVAL_4_HOUR";
    case TickInterval.INTERVAL_1_DAY:
      return "INTERVAL_1_DAY";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TickInterval");
  }
}

/** BasketTokenMarket contains the market data for a basket token. */
export interface BasketTokenMarket {
  name: string;
  basketToken: string;
  /**
   * Native token symbol of the chain the basket-token belongs to.
   * Not dollar(USDT, USDC),
   * and the prices and market cap fields will display dollar values together.
   */
  nativeCurrency: Currency;
  /** @deprecated */
  values: { [key: string]: Money };
  /**
   * Key is the currency enum string,
   * value is the market cap with the currency.
   *
   * @deprecated
   */
  marketCaps: { [key: string]: Money };
  /**
   * Key is the currency enum string,
   * value is the INAV changes with the currency.
   * {
   *   "CURRENCY_USDC": {
   *     "PRICE_CHANGE_PERIOD_1_HOUR": {
   *       "nominal_value": {
   *         "currency": "CURRENCY_USDC",
   *         "amount": 0.0001
   *       },
   *       "percentage_change": {
   *         "value": 0.0001
   *       },
   *       "period": "PRICE_CHANGE_PERIOD_1_HOUR"
   *     },
   *     "CURRENTCY_SOL": { ... }
   * }
   * Support Periods
   * * PRICE_CHANGE_PERIOD_1_HOUR
   * * PRICE_CHANGE_PERIOD_24_HOUR
   * * PRICE_CHANGE_PERIOD_7_DAY
   * * PRICE_CHANGE_PERIOD_30_DAY
   * * PRICE_CHANGE_PERIOD_ALL_TIME
   *
   * @deprecated
   */
  valueChanges: { [key: string]: PriceChangesByPeriod };
  /**
   * Percentage of lowest after the previous highest.
   * {(`previous highest` - `lowest` after `previous highest`) / `previous highest`} * 100
   */
  maximumDrawDown:
    | Percentage
    | undefined;
  /** Current NAV(Net Asset Value) per BasketToken. */
  value:
    | Money
    | undefined;
  /** Market cap is based on the current NAV(Net Asset Value) per BasketToken. */
  marketCap:
    | Money
    | undefined;
  /**
   * Example
   * {
   *   "PRICE_CHANGE_PERIOD_1_HOUR": {
   *       "nominal_value": {
   *           "currency": "CURRENCY_USDC",
   *           "amount": 0.0001
   *       },
   *       "percentage_change": {
   *           "value": 0.0001
   *       },
   *       "period": "PRICE_CHANGE_PERIOD_1_HOUR"
   *   },
   *   "PRICE_CHANGE_PERIOD_24_HOUR": {...},
   *   ...
   * }
   * Support Periods
   * * PRICE_CHANGE_PERIOD_1_HOUR
   * * PRICE_CHANGE_PERIOD_24_HOUR
   * * PRICE_CHANGE_PERIOD_7_DAY
   * * PRICE_CHANGE_PERIOD_30_DAY
   * * PRICE_CHANGE_PERIOD_ALL_TIME
   */
  valueChange: PriceChangesByPeriod | undefined;
}

export interface BasketTokenMarket_ValuesEntry {
  key: string;
  value: Money | undefined;
}

export interface BasketTokenMarket_MarketCapsEntry {
  key: string;
  value: Money | undefined;
}

export interface BasketTokenMarket_ValueChangesEntry {
  key: string;
  value: PriceChangesByPeriod | undefined;
}

export interface CreateBasketTokenMarketRequest {
  /** The basket token market to create. */
  basketTokenMarket:
    | BasketTokenMarket
    | undefined;
  /** display_name */
  displayName: string;
  /** Symbol */
  symbol: string;
}

export interface CustomCreateBasketTokenMarketRequest {
  /** The basket token market to create. */
  basketTokenMarket: BasketTokenMarket | undefined;
  components: CustomCreateBasketTokenMarketRequest_Component[];
  /** display_name */
  displayName: string;
  /** Symbol */
  symbol: string;
}

export interface CustomCreateBasketTokenMarketRequest_Component {
  /**
   * The name of the fungible token.
   * Format : "fungibleTokens/{chain}/{token_address}"
   */
  fungibleToken: string;
  /** Number of component token per one BasketToken. */
  quantity: Quantity | undefined;
}

export interface GetBasketTokenMarketRequest {
  /**
   * The name of the market  to retrieve.
   * Format : "basketTokens/{chain}/{token_address}/market"
   */
  basketTokenMarket: string;
  /** Display the price in this currency. Default is USD. */
  currency: Currency;
}

export interface ListBasketTokensMarketsRequest {
  /**
   * If unspecified, at most 50 books will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   */
  pageToken: string;
  /**
   * Available Sequence and Operator
   * * name
   *   * `=`
   *
   * Examples
   * * name="basketTokens/SOLANA/FZ4MT1HYJHd9GK8D5mJ9f3r7irLaDL5NxBNLjGqrLqs9/market"
   */
  filter: string;
  /**
   * One or more fields to compare and use to sort the output.
   * To specify ascending or descending order, append " asc" or " desc" to the field name. If not specified, the order is ascending.
   *
   * Reference
   * * https://google.aip.dev/132#ordering.
   *
   * Supported Fields
   * *
   *
   * Examples
   * *
   */
  orderBy: string;
  /** Display the price in this currency. Default is USD. */
  currency: Currency;
}

export interface ListBasketTokensMarketsResponse {
  basketTokenMarkets: BasketTokenMarket[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

export interface UpdateBasketTokenMarketComponentsRequest {
  /**
   * The name of the market to update.
   * Format : "basketTokens/{chain}/{token_address}/market"
   */
  basketTokenMarket: string;
  components: UpdateBasketTokenMarketComponentsRequest_Component[];
  /** The block number to update the components. */
  updateBlockNumber: number;
}

export interface UpdateBasketTokenMarketComponentsRequest_Component {
  /**
   * The name of the fungible token.
   * Format : "fungibleTokens/{chain}/{token_address}"
   */
  fungibleToken: string;
  /** Number of component token per one BasketToken. */
  quantity: Quantity | undefined;
}

export interface UpdateBasketTokenMarketComponentsResponse {
}

export interface ListBasketTokenTicksRequest {
  /** Format : "basketTokens/{chain}/{token_address}" */
  parent: string;
  /** If not set time, the current time will be used. */
  startTime?: string | undefined;
  endTime?:
    | string
    | undefined;
  /** default size: 200. Max size: 1000 */
  size?:
    | number
    | undefined;
  /** Default is USD. */
  currency: Currency;
  interval: TickInterval;
}

export interface ListBasketTokenTicksResponse {
  ticks: Tick[];
  currency: Currency;
}

export interface Tick {
  openTime: string | undefined;
  open: number;
  high: number;
  low: number;
  close: number;
}

function createBaseBasketTokenMarket(): BasketTokenMarket {
  return {
    name: "",
    basketToken: "",
    nativeCurrency: 0,
    values: {},
    marketCaps: {},
    valueChanges: {},
    maximumDrawDown: undefined,
    value: undefined,
    marketCap: undefined,
    valueChange: undefined,
  };
}

export const BasketTokenMarket = {
  encode(message: BasketTokenMarket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.basketToken !== "") {
      writer.uint32(18).string(message.basketToken);
    }
    if (message.nativeCurrency !== 0) {
      writer.uint32(24).int32(message.nativeCurrency);
    }
    Object.entries(message.values).forEach(([key, value]) => {
      BasketTokenMarket_ValuesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    Object.entries(message.marketCaps).forEach(([key, value]) => {
      BasketTokenMarket_MarketCapsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    Object.entries(message.valueChanges).forEach(([key, value]) => {
      BasketTokenMarket_ValueChangesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    if (message.maximumDrawDown !== undefined) {
      Percentage.encode(message.maximumDrawDown, writer.uint32(66).fork()).ldelim();
    }
    if (message.value !== undefined) {
      Money.encode(message.value, writer.uint32(74).fork()).ldelim();
    }
    if (message.marketCap !== undefined) {
      Money.encode(message.marketCap, writer.uint32(82).fork()).ldelim();
    }
    if (message.valueChange !== undefined) {
      PriceChangesByPeriod.encode(message.valueChange, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasketTokenMarket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketTokenMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.basketToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nativeCurrency = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = BasketTokenMarket_ValuesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.values[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = BasketTokenMarket_MarketCapsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.marketCaps[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = BasketTokenMarket_ValueChangesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.valueChanges[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.maximumDrawDown = Percentage.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.value = Money.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.marketCap = Money.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.valueChange = PriceChangesByPeriod.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketTokenMarket {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      basketToken: isSet(object.basketToken) ? globalThis.String(object.basketToken) : "",
      nativeCurrency: isSet(object.nativeCurrency) ? currencyFromJSON(object.nativeCurrency) : 0,
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: Money }>((acc, [key, value]) => {
          acc[key] = Money.fromJSON(value);
          return acc;
        }, {})
        : {},
      marketCaps: isObject(object.marketCaps)
        ? Object.entries(object.marketCaps).reduce<{ [key: string]: Money }>((acc, [key, value]) => {
          acc[key] = Money.fromJSON(value);
          return acc;
        }, {})
        : {},
      valueChanges: isObject(object.valueChanges)
        ? Object.entries(object.valueChanges).reduce<{ [key: string]: PriceChangesByPeriod }>((acc, [key, value]) => {
          acc[key] = PriceChangesByPeriod.fromJSON(value);
          return acc;
        }, {})
        : {},
      maximumDrawDown: isSet(object.maximumDrawDown) ? Percentage.fromJSON(object.maximumDrawDown) : undefined,
      value: isSet(object.value) ? Money.fromJSON(object.value) : undefined,
      marketCap: isSet(object.marketCap) ? Money.fromJSON(object.marketCap) : undefined,
      valueChange: isSet(object.valueChange) ? PriceChangesByPeriod.fromJSON(object.valueChange) : undefined,
    };
  },

  toJSON(message: BasketTokenMarket): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.basketToken !== undefined) {
      obj.basketToken = message.basketToken;
    }
    if (message.nativeCurrency !== undefined) {
      obj.nativeCurrency = currencyToJSON(message.nativeCurrency);
    }
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = Money.toJSON(v);
        });
      }
    }
    if (message.marketCaps) {
      const entries = Object.entries(message.marketCaps);
      if (entries.length > 0) {
        obj.marketCaps = {};
        entries.forEach(([k, v]) => {
          obj.marketCaps[k] = Money.toJSON(v);
        });
      }
    }
    if (message.valueChanges) {
      const entries = Object.entries(message.valueChanges);
      if (entries.length > 0) {
        obj.valueChanges = {};
        entries.forEach(([k, v]) => {
          obj.valueChanges[k] = PriceChangesByPeriod.toJSON(v);
        });
      }
    }
    if (message.maximumDrawDown !== undefined) {
      obj.maximumDrawDown = Percentage.toJSON(message.maximumDrawDown);
    }
    if (message.value !== undefined) {
      obj.value = Money.toJSON(message.value);
    }
    if (message.marketCap !== undefined) {
      obj.marketCap = Money.toJSON(message.marketCap);
    }
    if (message.valueChange !== undefined) {
      obj.valueChange = PriceChangesByPeriod.toJSON(message.valueChange);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketTokenMarket>, I>>(base?: I): BasketTokenMarket {
    return BasketTokenMarket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketTokenMarket>, I>>(object: I): BasketTokenMarket {
    const message = createBaseBasketTokenMarket();
    message.name = object.name ?? "";
    message.basketToken = object.basketToken ?? "";
    message.nativeCurrency = object.nativeCurrency ?? 0;
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: Money }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Money.fromPartial(value);
      }
      return acc;
    }, {});
    message.marketCaps = Object.entries(object.marketCaps ?? {}).reduce<{ [key: string]: Money }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Money.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.valueChanges = Object.entries(object.valueChanges ?? {}).reduce<{ [key: string]: PriceChangesByPeriod }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = PriceChangesByPeriod.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.maximumDrawDown = (object.maximumDrawDown !== undefined && object.maximumDrawDown !== null)
      ? Percentage.fromPartial(object.maximumDrawDown)
      : undefined;
    message.value = (object.value !== undefined && object.value !== null) ? Money.fromPartial(object.value) : undefined;
    message.marketCap = (object.marketCap !== undefined && object.marketCap !== null)
      ? Money.fromPartial(object.marketCap)
      : undefined;
    message.valueChange = (object.valueChange !== undefined && object.valueChange !== null)
      ? PriceChangesByPeriod.fromPartial(object.valueChange)
      : undefined;
    return message;
  },
};

function createBaseBasketTokenMarket_ValuesEntry(): BasketTokenMarket_ValuesEntry {
  return { key: "", value: undefined };
}

export const BasketTokenMarket_ValuesEntry = {
  encode(message: BasketTokenMarket_ValuesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Money.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasketTokenMarket_ValuesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketTokenMarket_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketTokenMarket_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Money.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BasketTokenMarket_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Money.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketTokenMarket_ValuesEntry>, I>>(base?: I): BasketTokenMarket_ValuesEntry {
    return BasketTokenMarket_ValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketTokenMarket_ValuesEntry>, I>>(
    object: I,
  ): BasketTokenMarket_ValuesEntry {
    const message = createBaseBasketTokenMarket_ValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Money.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseBasketTokenMarket_MarketCapsEntry(): BasketTokenMarket_MarketCapsEntry {
  return { key: "", value: undefined };
}

export const BasketTokenMarket_MarketCapsEntry = {
  encode(message: BasketTokenMarket_MarketCapsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Money.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasketTokenMarket_MarketCapsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketTokenMarket_MarketCapsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketTokenMarket_MarketCapsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Money.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BasketTokenMarket_MarketCapsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Money.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketTokenMarket_MarketCapsEntry>, I>>(
    base?: I,
  ): BasketTokenMarket_MarketCapsEntry {
    return BasketTokenMarket_MarketCapsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketTokenMarket_MarketCapsEntry>, I>>(
    object: I,
  ): BasketTokenMarket_MarketCapsEntry {
    const message = createBaseBasketTokenMarket_MarketCapsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Money.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseBasketTokenMarket_ValueChangesEntry(): BasketTokenMarket_ValueChangesEntry {
  return { key: "", value: undefined };
}

export const BasketTokenMarket_ValueChangesEntry = {
  encode(message: BasketTokenMarket_ValueChangesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      PriceChangesByPeriod.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasketTokenMarket_ValueChangesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketTokenMarket_ValueChangesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = PriceChangesByPeriod.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketTokenMarket_ValueChangesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? PriceChangesByPeriod.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BasketTokenMarket_ValueChangesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = PriceChangesByPeriod.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketTokenMarket_ValueChangesEntry>, I>>(
    base?: I,
  ): BasketTokenMarket_ValueChangesEntry {
    return BasketTokenMarket_ValueChangesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketTokenMarket_ValueChangesEntry>, I>>(
    object: I,
  ): BasketTokenMarket_ValueChangesEntry {
    const message = createBaseBasketTokenMarket_ValueChangesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? PriceChangesByPeriod.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCreateBasketTokenMarketRequest(): CreateBasketTokenMarketRequest {
  return { basketTokenMarket: undefined, displayName: "", symbol: "" };
}

export const CreateBasketTokenMarketRequest = {
  encode(message: CreateBasketTokenMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketTokenMarket !== undefined) {
      BasketTokenMarket.encode(message.basketTokenMarket, writer.uint32(10).fork()).ldelim();
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateBasketTokenMarketRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBasketTokenMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketTokenMarket = BasketTokenMarket.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBasketTokenMarketRequest {
    return {
      basketTokenMarket: isSet(object.basketTokenMarket)
        ? BasketTokenMarket.fromJSON(object.basketTokenMarket)
        : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
    };
  },

  toJSON(message: CreateBasketTokenMarketRequest): unknown {
    const obj: any = {};
    if (message.basketTokenMarket !== undefined) {
      obj.basketTokenMarket = BasketTokenMarket.toJSON(message.basketTokenMarket);
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBasketTokenMarketRequest>, I>>(base?: I): CreateBasketTokenMarketRequest {
    return CreateBasketTokenMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBasketTokenMarketRequest>, I>>(
    object: I,
  ): CreateBasketTokenMarketRequest {
    const message = createBaseCreateBasketTokenMarketRequest();
    message.basketTokenMarket = (object.basketTokenMarket !== undefined && object.basketTokenMarket !== null)
      ? BasketTokenMarket.fromPartial(object.basketTokenMarket)
      : undefined;
    message.displayName = object.displayName ?? "";
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseCustomCreateBasketTokenMarketRequest(): CustomCreateBasketTokenMarketRequest {
  return { basketTokenMarket: undefined, components: [], displayName: "", symbol: "" };
}

export const CustomCreateBasketTokenMarketRequest = {
  encode(message: CustomCreateBasketTokenMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketTokenMarket !== undefined) {
      BasketTokenMarket.encode(message.basketTokenMarket, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.components) {
      CustomCreateBasketTokenMarketRequest_Component.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CustomCreateBasketTokenMarketRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomCreateBasketTokenMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketTokenMarket = BasketTokenMarket.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.components.push(CustomCreateBasketTokenMarketRequest_Component.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomCreateBasketTokenMarketRequest {
    return {
      basketTokenMarket: isSet(object.basketTokenMarket)
        ? BasketTokenMarket.fromJSON(object.basketTokenMarket)
        : undefined,
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => CustomCreateBasketTokenMarketRequest_Component.fromJSON(e))
        : [],
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
    };
  },

  toJSON(message: CustomCreateBasketTokenMarketRequest): unknown {
    const obj: any = {};
    if (message.basketTokenMarket !== undefined) {
      obj.basketTokenMarket = BasketTokenMarket.toJSON(message.basketTokenMarket);
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => CustomCreateBasketTokenMarketRequest_Component.toJSON(e));
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomCreateBasketTokenMarketRequest>, I>>(
    base?: I,
  ): CustomCreateBasketTokenMarketRequest {
    return CustomCreateBasketTokenMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomCreateBasketTokenMarketRequest>, I>>(
    object: I,
  ): CustomCreateBasketTokenMarketRequest {
    const message = createBaseCustomCreateBasketTokenMarketRequest();
    message.basketTokenMarket = (object.basketTokenMarket !== undefined && object.basketTokenMarket !== null)
      ? BasketTokenMarket.fromPartial(object.basketTokenMarket)
      : undefined;
    message.components = object.components?.map((e) => CustomCreateBasketTokenMarketRequest_Component.fromPartial(e)) ||
      [];
    message.displayName = object.displayName ?? "";
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseCustomCreateBasketTokenMarketRequest_Component(): CustomCreateBasketTokenMarketRequest_Component {
  return { fungibleToken: "", quantity: undefined };
}

export const CustomCreateBasketTokenMarketRequest_Component = {
  encode(
    message: CustomCreateBasketTokenMarketRequest_Component,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fungibleToken !== "") {
      writer.uint32(10).string(message.fungibleToken);
    }
    if (message.quantity !== undefined) {
      Quantity.encode(message.quantity, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CustomCreateBasketTokenMarketRequest_Component {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomCreateBasketTokenMarketRequest_Component();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fungibleToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quantity = Quantity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomCreateBasketTokenMarketRequest_Component {
    return {
      fungibleToken: isSet(object.fungibleToken) ? globalThis.String(object.fungibleToken) : "",
      quantity: isSet(object.quantity) ? Quantity.fromJSON(object.quantity) : undefined,
    };
  },

  toJSON(message: CustomCreateBasketTokenMarketRequest_Component): unknown {
    const obj: any = {};
    if (message.fungibleToken !== undefined) {
      obj.fungibleToken = message.fungibleToken;
    }
    if (message.quantity !== undefined) {
      obj.quantity = Quantity.toJSON(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomCreateBasketTokenMarketRequest_Component>, I>>(
    base?: I,
  ): CustomCreateBasketTokenMarketRequest_Component {
    return CustomCreateBasketTokenMarketRequest_Component.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomCreateBasketTokenMarketRequest_Component>, I>>(
    object: I,
  ): CustomCreateBasketTokenMarketRequest_Component {
    const message = createBaseCustomCreateBasketTokenMarketRequest_Component();
    message.fungibleToken = object.fungibleToken ?? "";
    message.quantity = (object.quantity !== undefined && object.quantity !== null)
      ? Quantity.fromPartial(object.quantity)
      : undefined;
    return message;
  },
};

function createBaseGetBasketTokenMarketRequest(): GetBasketTokenMarketRequest {
  return { basketTokenMarket: "", currency: 0 };
}

export const GetBasketTokenMarketRequest = {
  encode(message: GetBasketTokenMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketTokenMarket !== "") {
      writer.uint32(10).string(message.basketTokenMarket);
    }
    if (message.currency !== 0) {
      writer.uint32(16).int32(message.currency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBasketTokenMarketRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketTokenMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketTokenMarket = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketTokenMarketRequest {
    return {
      basketTokenMarket: isSet(object.basketTokenMarket) ? globalThis.String(object.basketTokenMarket) : "",
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : 0,
    };
  },

  toJSON(message: GetBasketTokenMarketRequest): unknown {
    const obj: any = {};
    if (message.basketTokenMarket !== undefined) {
      obj.basketTokenMarket = message.basketTokenMarket;
    }
    if (message.currency !== undefined) {
      obj.currency = currencyToJSON(message.currency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketTokenMarketRequest>, I>>(base?: I): GetBasketTokenMarketRequest {
    return GetBasketTokenMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketTokenMarketRequest>, I>>(object: I): GetBasketTokenMarketRequest {
    const message = createBaseGetBasketTokenMarketRequest();
    message.basketTokenMarket = object.basketTokenMarket ?? "";
    message.currency = object.currency ?? 0;
    return message;
  },
};

function createBaseListBasketTokensMarketsRequest(): ListBasketTokensMarketsRequest {
  return { pageSize: 0, pageToken: "", filter: "", orderBy: "", currency: 0 };
}

export const ListBasketTokensMarketsRequest = {
  encode(message: ListBasketTokensMarketsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    if (message.currency !== 0) {
      writer.uint32(40).int32(message.currency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBasketTokensMarketsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBasketTokensMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBasketTokensMarketsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : 0,
    };
  },

  toJSON(message: ListBasketTokensMarketsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    if (message.orderBy !== undefined) {
      obj.orderBy = message.orderBy;
    }
    if (message.currency !== undefined) {
      obj.currency = currencyToJSON(message.currency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBasketTokensMarketsRequest>, I>>(base?: I): ListBasketTokensMarketsRequest {
    return ListBasketTokensMarketsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBasketTokensMarketsRequest>, I>>(
    object: I,
  ): ListBasketTokensMarketsRequest {
    const message = createBaseListBasketTokensMarketsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.currency = object.currency ?? 0;
    return message;
  },
};

function createBaseListBasketTokensMarketsResponse(): ListBasketTokensMarketsResponse {
  return { basketTokenMarkets: [], nextPageToken: "" };
}

export const ListBasketTokensMarketsResponse = {
  encode(message: ListBasketTokensMarketsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.basketTokenMarkets) {
      BasketTokenMarket.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBasketTokensMarketsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBasketTokensMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketTokenMarkets.push(BasketTokenMarket.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBasketTokensMarketsResponse {
    return {
      basketTokenMarkets: globalThis.Array.isArray(object?.basketTokenMarkets)
        ? object.basketTokenMarkets.map((e: any) => BasketTokenMarket.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListBasketTokensMarketsResponse): unknown {
    const obj: any = {};
    if (message.basketTokenMarkets?.length) {
      obj.basketTokenMarkets = message.basketTokenMarkets.map((e) => BasketTokenMarket.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBasketTokensMarketsResponse>, I>>(base?: I): ListBasketTokensMarketsResponse {
    return ListBasketTokensMarketsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBasketTokensMarketsResponse>, I>>(
    object: I,
  ): ListBasketTokensMarketsResponse {
    const message = createBaseListBasketTokensMarketsResponse();
    message.basketTokenMarkets = object.basketTokenMarkets?.map((e) => BasketTokenMarket.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateBasketTokenMarketComponentsRequest(): UpdateBasketTokenMarketComponentsRequest {
  return { basketTokenMarket: "", components: [], updateBlockNumber: 0 };
}

export const UpdateBasketTokenMarketComponentsRequest = {
  encode(message: UpdateBasketTokenMarketComponentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketTokenMarket !== "") {
      writer.uint32(10).string(message.basketTokenMarket);
    }
    for (const v of message.components) {
      UpdateBasketTokenMarketComponentsRequest_Component.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.updateBlockNumber !== 0) {
      writer.uint32(24).uint64(message.updateBlockNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateBasketTokenMarketComponentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBasketTokenMarketComponentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketTokenMarket = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.components.push(UpdateBasketTokenMarketComponentsRequest_Component.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.updateBlockNumber = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBasketTokenMarketComponentsRequest {
    return {
      basketTokenMarket: isSet(object.basketTokenMarket) ? globalThis.String(object.basketTokenMarket) : "",
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => UpdateBasketTokenMarketComponentsRequest_Component.fromJSON(e))
        : [],
      updateBlockNumber: isSet(object.updateBlockNumber) ? globalThis.Number(object.updateBlockNumber) : 0,
    };
  },

  toJSON(message: UpdateBasketTokenMarketComponentsRequest): unknown {
    const obj: any = {};
    if (message.basketTokenMarket !== undefined) {
      obj.basketTokenMarket = message.basketTokenMarket;
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => UpdateBasketTokenMarketComponentsRequest_Component.toJSON(e));
    }
    if (message.updateBlockNumber !== undefined) {
      obj.updateBlockNumber = Math.round(message.updateBlockNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateBasketTokenMarketComponentsRequest>, I>>(
    base?: I,
  ): UpdateBasketTokenMarketComponentsRequest {
    return UpdateBasketTokenMarketComponentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateBasketTokenMarketComponentsRequest>, I>>(
    object: I,
  ): UpdateBasketTokenMarketComponentsRequest {
    const message = createBaseUpdateBasketTokenMarketComponentsRequest();
    message.basketTokenMarket = object.basketTokenMarket ?? "";
    message.components =
      object.components?.map((e) => UpdateBasketTokenMarketComponentsRequest_Component.fromPartial(e)) || [];
    message.updateBlockNumber = object.updateBlockNumber ?? 0;
    return message;
  },
};

function createBaseUpdateBasketTokenMarketComponentsRequest_Component(): UpdateBasketTokenMarketComponentsRequest_Component {
  return { fungibleToken: "", quantity: undefined };
}

export const UpdateBasketTokenMarketComponentsRequest_Component = {
  encode(
    message: UpdateBasketTokenMarketComponentsRequest_Component,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fungibleToken !== "") {
      writer.uint32(10).string(message.fungibleToken);
    }
    if (message.quantity !== undefined) {
      Quantity.encode(message.quantity, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateBasketTokenMarketComponentsRequest_Component {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBasketTokenMarketComponentsRequest_Component();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fungibleToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quantity = Quantity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBasketTokenMarketComponentsRequest_Component {
    return {
      fungibleToken: isSet(object.fungibleToken) ? globalThis.String(object.fungibleToken) : "",
      quantity: isSet(object.quantity) ? Quantity.fromJSON(object.quantity) : undefined,
    };
  },

  toJSON(message: UpdateBasketTokenMarketComponentsRequest_Component): unknown {
    const obj: any = {};
    if (message.fungibleToken !== undefined) {
      obj.fungibleToken = message.fungibleToken;
    }
    if (message.quantity !== undefined) {
      obj.quantity = Quantity.toJSON(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateBasketTokenMarketComponentsRequest_Component>, I>>(
    base?: I,
  ): UpdateBasketTokenMarketComponentsRequest_Component {
    return UpdateBasketTokenMarketComponentsRequest_Component.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateBasketTokenMarketComponentsRequest_Component>, I>>(
    object: I,
  ): UpdateBasketTokenMarketComponentsRequest_Component {
    const message = createBaseUpdateBasketTokenMarketComponentsRequest_Component();
    message.fungibleToken = object.fungibleToken ?? "";
    message.quantity = (object.quantity !== undefined && object.quantity !== null)
      ? Quantity.fromPartial(object.quantity)
      : undefined;
    return message;
  },
};

function createBaseUpdateBasketTokenMarketComponentsResponse(): UpdateBasketTokenMarketComponentsResponse {
  return {};
}

export const UpdateBasketTokenMarketComponentsResponse = {
  encode(_: UpdateBasketTokenMarketComponentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateBasketTokenMarketComponentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBasketTokenMarketComponentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateBasketTokenMarketComponentsResponse {
    return {};
  },

  toJSON(_: UpdateBasketTokenMarketComponentsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateBasketTokenMarketComponentsResponse>, I>>(
    base?: I,
  ): UpdateBasketTokenMarketComponentsResponse {
    return UpdateBasketTokenMarketComponentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateBasketTokenMarketComponentsResponse>, I>>(
    _: I,
  ): UpdateBasketTokenMarketComponentsResponse {
    const message = createBaseUpdateBasketTokenMarketComponentsResponse();
    return message;
  },
};

function createBaseListBasketTokenTicksRequest(): ListBasketTokenTicksRequest {
  return { parent: "", startTime: undefined, endTime: undefined, size: undefined, currency: 0, interval: 0 };
}

export const ListBasketTokenTicksRequest = {
  encode(message: ListBasketTokenTicksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).ldelim();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).ldelim();
    }
    if (message.size !== undefined) {
      writer.uint32(32).int32(message.size);
    }
    if (message.currency !== 0) {
      writer.uint32(40).int32(message.currency);
    }
    if (message.interval !== 0) {
      writer.uint32(48).int32(message.interval);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBasketTokenTicksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBasketTokenTicksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.size = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.interval = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBasketTokenTicksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : undefined,
      size: isSet(object.size) ? globalThis.Number(object.size) : undefined,
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : 0,
      interval: isSet(object.interval) ? tickIntervalFromJSON(object.interval) : 0,
    };
  },

  toJSON(message: ListBasketTokenTicksRequest): unknown {
    const obj: any = {};
    if (message.parent !== undefined) {
      obj.parent = message.parent;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime;
    }
    if (message.size !== undefined) {
      obj.size = Math.round(message.size);
    }
    if (message.currency !== undefined) {
      obj.currency = currencyToJSON(message.currency);
    }
    if (message.interval !== undefined) {
      obj.interval = tickIntervalToJSON(message.interval);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBasketTokenTicksRequest>, I>>(base?: I): ListBasketTokenTicksRequest {
    return ListBasketTokenTicksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBasketTokenTicksRequest>, I>>(object: I): ListBasketTokenTicksRequest {
    const message = createBaseListBasketTokenTicksRequest();
    message.parent = object.parent ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.size = object.size ?? undefined;
    message.currency = object.currency ?? 0;
    message.interval = object.interval ?? 0;
    return message;
  },
};

function createBaseListBasketTokenTicksResponse(): ListBasketTokenTicksResponse {
  return { ticks: [], currency: 0 };
}

export const ListBasketTokenTicksResponse = {
  encode(message: ListBasketTokenTicksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ticks) {
      Tick.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.currency !== 0) {
      writer.uint32(16).int32(message.currency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBasketTokenTicksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBasketTokenTicksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ticks.push(Tick.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBasketTokenTicksResponse {
    return {
      ticks: globalThis.Array.isArray(object?.ticks) ? object.ticks.map((e: any) => Tick.fromJSON(e)) : [],
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : 0,
    };
  },

  toJSON(message: ListBasketTokenTicksResponse): unknown {
    const obj: any = {};
    if (message.ticks?.length) {
      obj.ticks = message.ticks.map((e) => Tick.toJSON(e));
    }
    if (message.currency !== undefined) {
      obj.currency = currencyToJSON(message.currency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBasketTokenTicksResponse>, I>>(base?: I): ListBasketTokenTicksResponse {
    return ListBasketTokenTicksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBasketTokenTicksResponse>, I>>(object: I): ListBasketTokenTicksResponse {
    const message = createBaseListBasketTokenTicksResponse();
    message.ticks = object.ticks?.map((e) => Tick.fromPartial(e)) || [];
    message.currency = object.currency ?? 0;
    return message;
  },
};

function createBaseTick(): Tick {
  return { openTime: undefined, open: 0, high: 0, low: 0, close: 0 };
}

export const Tick = {
  encode(message: Tick, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.openTime !== undefined) {
      Timestamp.encode(toTimestamp(message.openTime), writer.uint32(10).fork()).ldelim();
    }
    if (message.open !== 0) {
      writer.uint32(17).double(message.open);
    }
    if (message.high !== 0) {
      writer.uint32(25).double(message.high);
    }
    if (message.low !== 0) {
      writer.uint32(33).double(message.low);
    }
    if (message.close !== 0) {
      writer.uint32(41).double(message.close);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Tick {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.openTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.open = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.high = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.low = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.close = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tick {
    return {
      openTime: isSet(object.openTime) ? globalThis.String(object.openTime) : undefined,
      open: isSet(object.open) ? globalThis.Number(object.open) : 0,
      high: isSet(object.high) ? globalThis.Number(object.high) : 0,
      low: isSet(object.low) ? globalThis.Number(object.low) : 0,
      close: isSet(object.close) ? globalThis.Number(object.close) : 0,
    };
  },

  toJSON(message: Tick): unknown {
    const obj: any = {};
    if (message.openTime !== undefined) {
      obj.openTime = message.openTime;
    }
    if (message.open !== undefined) {
      obj.open = message.open;
    }
    if (message.high !== undefined) {
      obj.high = message.high;
    }
    if (message.low !== undefined) {
      obj.low = message.low;
    }
    if (message.close !== undefined) {
      obj.close = message.close;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tick>, I>>(base?: I): Tick {
    return Tick.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tick>, I>>(object: I): Tick {
    const message = createBaseTick();
    message.openTime = object.openTime ?? undefined;
    message.open = object.open ?? 0;
    message.high = object.high ?? 0;
    message.low = object.low ?? 0;
    message.close = object.close ?? 0;
    return message;
  },
};

/** BasketTokenMarketService contains the function to interact with the Market of the spacebar */
export interface BasketTokenMarketService {
  /**
   * CreateBasketTokenMarket
   * private
   */
  CreateBasketTokenMarket(request: CreateBasketTokenMarketRequest): Promise<BasketTokenMarket>;
  /**
   * CustomCreateBasketTokenMarket
   * Create with components.
   * private
   */
  CustomCreateBasketTokenMarket(request: CustomCreateBasketTokenMarketRequest): Promise<BasketTokenMarket>;
  /** GetBasketTokenMarket returns the market for the given basket token. */
  GetBasketTokenMarket(request: GetBasketTokenMarketRequest): Promise<BasketTokenMarket>;
  /** ListBasketTokenMarkets returns the list of markets for the given basket tokens. */
  ListBasketTokenMarkets(request: ListBasketTokensMarketsRequest): Promise<ListBasketTokensMarketsResponse>;
  /**
   * UpdateBasketTokenMarketComponents
   * private
   */
  UpdateBasketTokenMarketComponents(
    request: UpdateBasketTokenMarketComponentsRequest,
  ): Promise<UpdateBasketTokenMarketComponentsResponse>;
  /** ListBasketTokenTicks returns the list of Ticks for the given basket tokens. */
  ListBasketTokenTicks(request: ListBasketTokenTicksRequest): Promise<ListBasketTokenTicksResponse>;
}

export const BasketTokenMarketServiceServiceName = "piedotfun.v1.BasketTokenMarketService";
export class BasketTokenMarketServiceClientImpl implements BasketTokenMarketService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || BasketTokenMarketServiceServiceName;
    this.rpc = rpc;
    this.CreateBasketTokenMarket = this.CreateBasketTokenMarket.bind(this);
    this.CustomCreateBasketTokenMarket = this.CustomCreateBasketTokenMarket.bind(this);
    this.GetBasketTokenMarket = this.GetBasketTokenMarket.bind(this);
    this.ListBasketTokenMarkets = this.ListBasketTokenMarkets.bind(this);
    this.UpdateBasketTokenMarketComponents = this.UpdateBasketTokenMarketComponents.bind(this);
    this.ListBasketTokenTicks = this.ListBasketTokenTicks.bind(this);
  }
  CreateBasketTokenMarket(request: CreateBasketTokenMarketRequest): Promise<BasketTokenMarket> {
    const data = CreateBasketTokenMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateBasketTokenMarket", data);
    return promise.then((data) => BasketTokenMarket.decode(_m0.Reader.create(data)));
  }

  CustomCreateBasketTokenMarket(request: CustomCreateBasketTokenMarketRequest): Promise<BasketTokenMarket> {
    const data = CustomCreateBasketTokenMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CustomCreateBasketTokenMarket", data);
    return promise.then((data) => BasketTokenMarket.decode(_m0.Reader.create(data)));
  }

  GetBasketTokenMarket(request: GetBasketTokenMarketRequest): Promise<BasketTokenMarket> {
    const data = GetBasketTokenMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBasketTokenMarket", data);
    return promise.then((data) => BasketTokenMarket.decode(_m0.Reader.create(data)));
  }

  ListBasketTokenMarkets(request: ListBasketTokensMarketsRequest): Promise<ListBasketTokensMarketsResponse> {
    const data = ListBasketTokensMarketsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListBasketTokenMarkets", data);
    return promise.then((data) => ListBasketTokensMarketsResponse.decode(_m0.Reader.create(data)));
  }

  UpdateBasketTokenMarketComponents(
    request: UpdateBasketTokenMarketComponentsRequest,
  ): Promise<UpdateBasketTokenMarketComponentsResponse> {
    const data = UpdateBasketTokenMarketComponentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateBasketTokenMarketComponents", data);
    return promise.then((data) => UpdateBasketTokenMarketComponentsResponse.decode(_m0.Reader.create(data)));
  }

  ListBasketTokenTicks(request: ListBasketTokenTicksRequest): Promise<ListBasketTokenTicksResponse> {
    const data = ListBasketTokenTicksRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListBasketTokenTicks", data);
    return promise.then((data) => ListBasketTokenTicksResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(dateStr: string): Timestamp {
  const date = new globalThis.Date(dateStr);
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): string {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis).toISOString();
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
