// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: pie-dot-fun/v1/pie-program.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Empty } from "../../google/protobuf/empty";

export const protobufPackage = "piedotfun.v1";

export enum PoolType {
  POOL_TYPE_UNSPECIFIED = 0,
  AMM = 1,
  CLMM = 2,
  CPMM = 3,
}

export function poolTypeFromJSON(object: any): PoolType {
  switch (object) {
    case 0:
    case "POOL_TYPE_UNSPECIFIED":
      return PoolType.POOL_TYPE_UNSPECIFIED;
    case 1:
    case "AMM":
      return PoolType.AMM;
    case 2:
    case "CLMM":
      return PoolType.CLMM;
    case 3:
    case "CPMM":
      return PoolType.CPMM;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PoolType");
  }
}

export function poolTypeToJSON(object: PoolType): string {
  switch (object) {
    case PoolType.POOL_TYPE_UNSPECIFIED:
      return "POOL_TYPE_UNSPECIFIED";
    case PoolType.AMM:
      return "AMM";
    case PoolType.CLMM:
      return "CLMM";
    case PoolType.CPMM:
      return "CPMM";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum PoolType");
  }
}

export enum BaseType {
  BASE_TYPE_UNSPECIFIED = 0,
  BASE_IN = 1,
  BASE_OUT = 2,
}

export function baseTypeFromJSON(object: any): BaseType {
  switch (object) {
    case 0:
    case "BASE_TYPE_UNSPECIFIED":
      return BaseType.BASE_TYPE_UNSPECIFIED;
    case 1:
    case "BASE_IN":
      return BaseType.BASE_IN;
    case 2:
    case "BASE_OUT":
      return BaseType.BASE_OUT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BaseType");
  }
}

export function baseTypeToJSON(object: BaseType): string {
  switch (object) {
    case BaseType.BASE_TYPE_UNSPECIFIED:
      return "BASE_TYPE_UNSPECIFIED";
    case BaseType.BASE_IN:
      return "BASE_IN";
    case BaseType.BASE_OUT:
      return "BASE_OUT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BaseType");
  }
}

export interface GetBasketVaultRequest {
  mint: string;
}

export interface GetBasketVaultResponse {
  vault: BasketVaultElement[];
}

export interface BasketVaultElement {
  mint: string;
  balance: number;
}

export interface RebalanceAction {
  inputMint: string;
  outputMint: string;
  baseType: BaseType;
  /**
   * Raw amount of the mint that `base_type` references.
   * BASE_IN: amount of `input_mint`
   * BASE_OUT: amount of `output_mint`
   */
  amount: string;
  /**
   * Threshold for the other amount
   * BASE_IN: Minimum amount of `output_mint` token to be received
   * BASE_OUT: Maximum amount of `input_mint` token to be spent
   */
  otherAmountThreshold?: string | undefined;
}

export interface SerializedTxBundle {
  serializedTxs: string[];
}

export interface BuildRebalanceTxRequest {
  basketMint: string;
  slippagePercentage: number;
  actions: RebalanceAction[];
}

export interface BuySwapData {
  mint: string;
  amountIn: string;
  maxAmountIn: string;
  amountOut: string;
}

export interface BuildMintTxRequest {
  basketMint: string;
  mintAmount: string;
  inputAmount: string;
  ownerAddress: string;
  buySwapData: BuySwapData[];
  /**
   * percentage
   * If null, value is set to 10(%)
   */
  maxSlippage?: number | undefined;
}

export interface BuildRedeemTxRequest {
  basketMint: string;
  amount: string;
  ownerAddress: string;
  /**
   * percentage
   * If null, value is set to 10(%)
   */
  maxSlippage?: number | undefined;
}

export interface GetBasketConfigByIDRequest {
  basketId: string;
}

export interface GetBasketMintByIDRequest {
  basketId: string;
}

export interface GetBasketMintByIDResponse {
  mint: string;
}

export interface CommandCreateBasketRequest {
}

export interface GetBasketRequest {
  mint: string;
}

export interface BatchCreateTokenPoolsRequest {
  tokenPools: TokenPool[];
}

export interface BatchCreateTokenPoolsResponse {
  tokenPools: TokenPool[];
}

export interface TxResponse {
  tx: string;
}

export interface Basket {
  mint: string;
  basketId: number;
  name: string;
  symbol: string;
  uri: string;
  components: BasketComponent[];
}

export interface TokenPool {
  mint: string;
  poolType: PoolType;
  poolId: string;
  lookupTable: string;
}

export interface ProgramState {
  bump: number;
  admin: string;
  platformFeeWallet: string;
  basketCounter: string;
  rebalanceMarginLamports: string;
  creatorFeePercentage: string;
  platformFeePercentage: string;
  enableCreator: boolean;
  isInitialized: boolean;
}

export interface BasketConfig {
  bump: number;
  id: number;
  creator: string;
  rebalancer: string;
  mint: string;
  isRebalancing: boolean;
  components: BasketComponent[];
}

export interface BasketComponent {
  mint: string;
  /** In system raw amount */
  quantity: number;
}

function createBaseGetBasketVaultRequest(): GetBasketVaultRequest {
  return { mint: "" };
}

export const GetBasketVaultRequest = {
  encode(message: GetBasketVaultRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBasketVaultRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketVaultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketVaultRequest {
    return { mint: isSet(object.mint) ? globalThis.String(object.mint) : "" };
  },

  toJSON(message: GetBasketVaultRequest): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketVaultRequest>, I>>(base?: I): GetBasketVaultRequest {
    return GetBasketVaultRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketVaultRequest>, I>>(object: I): GetBasketVaultRequest {
    const message = createBaseGetBasketVaultRequest();
    message.mint = object.mint ?? "";
    return message;
  },
};

function createBaseGetBasketVaultResponse(): GetBasketVaultResponse {
  return { vault: [] };
}

export const GetBasketVaultResponse = {
  encode(message: GetBasketVaultResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.vault) {
      BasketVaultElement.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBasketVaultResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketVaultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vault.push(BasketVaultElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketVaultResponse {
    return {
      vault: globalThis.Array.isArray(object?.vault)
        ? object.vault.map((e: any) => BasketVaultElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetBasketVaultResponse): unknown {
    const obj: any = {};
    if (message.vault?.length) {
      obj.vault = message.vault.map((e) => BasketVaultElement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketVaultResponse>, I>>(base?: I): GetBasketVaultResponse {
    return GetBasketVaultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketVaultResponse>, I>>(object: I): GetBasketVaultResponse {
    const message = createBaseGetBasketVaultResponse();
    message.vault = object.vault?.map((e) => BasketVaultElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBasketVaultElement(): BasketVaultElement {
  return { mint: "", balance: 0 };
}

export const BasketVaultElement = {
  encode(message: BasketVaultElement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.balance !== 0) {
      writer.uint32(16).uint64(message.balance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasketVaultElement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketVaultElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.balance = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketVaultElement {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
    };
  },

  toJSON(message: BasketVaultElement): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.balance !== undefined) {
      obj.balance = Math.round(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketVaultElement>, I>>(base?: I): BasketVaultElement {
    return BasketVaultElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketVaultElement>, I>>(object: I): BasketVaultElement {
    const message = createBaseBasketVaultElement();
    message.mint = object.mint ?? "";
    message.balance = object.balance ?? 0;
    return message;
  },
};

function createBaseRebalanceAction(): RebalanceAction {
  return { inputMint: "", outputMint: "", baseType: 0, amount: "", otherAmountThreshold: undefined };
}

export const RebalanceAction = {
  encode(message: RebalanceAction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inputMint !== "") {
      writer.uint32(10).string(message.inputMint);
    }
    if (message.outputMint !== "") {
      writer.uint32(18).string(message.outputMint);
    }
    if (message.baseType !== 0) {
      writer.uint32(24).int32(message.baseType);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.otherAmountThreshold !== undefined) {
      writer.uint32(42).string(message.otherAmountThreshold);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebalanceAction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebalanceAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputMint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputMint = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.baseType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.otherAmountThreshold = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RebalanceAction {
    return {
      inputMint: isSet(object.inputMint) ? globalThis.String(object.inputMint) : "",
      outputMint: isSet(object.outputMint) ? globalThis.String(object.outputMint) : "",
      baseType: isSet(object.baseType) ? baseTypeFromJSON(object.baseType) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      otherAmountThreshold: isSet(object.otherAmountThreshold)
        ? globalThis.String(object.otherAmountThreshold)
        : undefined,
    };
  },

  toJSON(message: RebalanceAction): unknown {
    const obj: any = {};
    if (message.inputMint !== undefined) {
      obj.inputMint = message.inputMint;
    }
    if (message.outputMint !== undefined) {
      obj.outputMint = message.outputMint;
    }
    if (message.baseType !== undefined) {
      obj.baseType = baseTypeToJSON(message.baseType);
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.otherAmountThreshold !== undefined) {
      obj.otherAmountThreshold = message.otherAmountThreshold;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RebalanceAction>, I>>(base?: I): RebalanceAction {
    return RebalanceAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RebalanceAction>, I>>(object: I): RebalanceAction {
    const message = createBaseRebalanceAction();
    message.inputMint = object.inputMint ?? "";
    message.outputMint = object.outputMint ?? "";
    message.baseType = object.baseType ?? 0;
    message.amount = object.amount ?? "";
    message.otherAmountThreshold = object.otherAmountThreshold ?? undefined;
    return message;
  },
};

function createBaseSerializedTxBundle(): SerializedTxBundle {
  return { serializedTxs: [] };
}

export const SerializedTxBundle = {
  encode(message: SerializedTxBundle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.serializedTxs) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SerializedTxBundle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSerializedTxBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serializedTxs.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SerializedTxBundle {
    return {
      serializedTxs: globalThis.Array.isArray(object?.serializedTxs)
        ? object.serializedTxs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SerializedTxBundle): unknown {
    const obj: any = {};
    if (message.serializedTxs?.length) {
      obj.serializedTxs = message.serializedTxs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SerializedTxBundle>, I>>(base?: I): SerializedTxBundle {
    return SerializedTxBundle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SerializedTxBundle>, I>>(object: I): SerializedTxBundle {
    const message = createBaseSerializedTxBundle();
    message.serializedTxs = object.serializedTxs?.map((e) => e) || [];
    return message;
  },
};

function createBaseBuildRebalanceTxRequest(): BuildRebalanceTxRequest {
  return { basketMint: "", slippagePercentage: 0, actions: [] };
}

export const BuildRebalanceTxRequest = {
  encode(message: BuildRebalanceTxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketMint !== "") {
      writer.uint32(10).string(message.basketMint);
    }
    if (message.slippagePercentage !== 0) {
      writer.uint32(17).double(message.slippagePercentage);
    }
    for (const v of message.actions) {
      RebalanceAction.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildRebalanceTxRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildRebalanceTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketMint = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.slippagePercentage = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actions.push(RebalanceAction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildRebalanceTxRequest {
    return {
      basketMint: isSet(object.basketMint) ? globalThis.String(object.basketMint) : "",
      slippagePercentage: isSet(object.slippagePercentage) ? globalThis.Number(object.slippagePercentage) : 0,
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => RebalanceAction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BuildRebalanceTxRequest): unknown {
    const obj: any = {};
    if (message.basketMint !== undefined) {
      obj.basketMint = message.basketMint;
    }
    if (message.slippagePercentage !== undefined) {
      obj.slippagePercentage = message.slippagePercentage;
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => RebalanceAction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildRebalanceTxRequest>, I>>(base?: I): BuildRebalanceTxRequest {
    return BuildRebalanceTxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildRebalanceTxRequest>, I>>(object: I): BuildRebalanceTxRequest {
    const message = createBaseBuildRebalanceTxRequest();
    message.basketMint = object.basketMint ?? "";
    message.slippagePercentage = object.slippagePercentage ?? 0;
    message.actions = object.actions?.map((e) => RebalanceAction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBuySwapData(): BuySwapData {
  return { mint: "", amountIn: "", maxAmountIn: "", amountOut: "" };
}

export const BuySwapData = {
  encode(message: BuySwapData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.amountIn !== "") {
      writer.uint32(18).string(message.amountIn);
    }
    if (message.maxAmountIn !== "") {
      writer.uint32(26).string(message.maxAmountIn);
    }
    if (message.amountOut !== "") {
      writer.uint32(34).string(message.amountOut);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuySwapData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuySwapData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maxAmountIn = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amountOut = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuySwapData {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      maxAmountIn: isSet(object.maxAmountIn) ? globalThis.String(object.maxAmountIn) : "",
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
    };
  },

  toJSON(message: BuySwapData): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.amountIn !== undefined) {
      obj.amountIn = message.amountIn;
    }
    if (message.maxAmountIn !== undefined) {
      obj.maxAmountIn = message.maxAmountIn;
    }
    if (message.amountOut !== undefined) {
      obj.amountOut = message.amountOut;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuySwapData>, I>>(base?: I): BuySwapData {
    return BuySwapData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuySwapData>, I>>(object: I): BuySwapData {
    const message = createBaseBuySwapData();
    message.mint = object.mint ?? "";
    message.amountIn = object.amountIn ?? "";
    message.maxAmountIn = object.maxAmountIn ?? "";
    message.amountOut = object.amountOut ?? "";
    return message;
  },
};

function createBaseBuildMintTxRequest(): BuildMintTxRequest {
  return { basketMint: "", mintAmount: "", inputAmount: "", ownerAddress: "", buySwapData: [], maxSlippage: undefined };
}

export const BuildMintTxRequest = {
  encode(message: BuildMintTxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketMint !== "") {
      writer.uint32(10).string(message.basketMint);
    }
    if (message.mintAmount !== "") {
      writer.uint32(18).string(message.mintAmount);
    }
    if (message.inputAmount !== "") {
      writer.uint32(26).string(message.inputAmount);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(34).string(message.ownerAddress);
    }
    for (const v of message.buySwapData) {
      BuySwapData.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.maxSlippage !== undefined) {
      writer.uint32(48).uint64(message.maxSlippage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildMintTxRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMintTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketMint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mintAmount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inputAmount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.buySwapData.push(BuySwapData.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.maxSlippage = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMintTxRequest {
    return {
      basketMint: isSet(object.basketMint) ? globalThis.String(object.basketMint) : "",
      mintAmount: isSet(object.mintAmount) ? globalThis.String(object.mintAmount) : "",
      inputAmount: isSet(object.inputAmount) ? globalThis.String(object.inputAmount) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      buySwapData: globalThis.Array.isArray(object?.buySwapData)
        ? object.buySwapData.map((e: any) => BuySwapData.fromJSON(e))
        : [],
      maxSlippage: isSet(object.maxSlippage) ? globalThis.Number(object.maxSlippage) : undefined,
    };
  },

  toJSON(message: BuildMintTxRequest): unknown {
    const obj: any = {};
    if (message.basketMint !== undefined) {
      obj.basketMint = message.basketMint;
    }
    if (message.mintAmount !== undefined) {
      obj.mintAmount = message.mintAmount;
    }
    if (message.inputAmount !== undefined) {
      obj.inputAmount = message.inputAmount;
    }
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.buySwapData?.length) {
      obj.buySwapData = message.buySwapData.map((e) => BuySwapData.toJSON(e));
    }
    if (message.maxSlippage !== undefined) {
      obj.maxSlippage = Math.round(message.maxSlippage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMintTxRequest>, I>>(base?: I): BuildMintTxRequest {
    return BuildMintTxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMintTxRequest>, I>>(object: I): BuildMintTxRequest {
    const message = createBaseBuildMintTxRequest();
    message.basketMint = object.basketMint ?? "";
    message.mintAmount = object.mintAmount ?? "";
    message.inputAmount = object.inputAmount ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.buySwapData = object.buySwapData?.map((e) => BuySwapData.fromPartial(e)) || [];
    message.maxSlippage = object.maxSlippage ?? undefined;
    return message;
  },
};

function createBaseBuildRedeemTxRequest(): BuildRedeemTxRequest {
  return { basketMint: "", amount: "", ownerAddress: "", maxSlippage: undefined };
}

export const BuildRedeemTxRequest = {
  encode(message: BuildRedeemTxRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketMint !== "") {
      writer.uint32(10).string(message.basketMint);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.ownerAddress !== "") {
      writer.uint32(26).string(message.ownerAddress);
    }
    if (message.maxSlippage !== undefined) {
      writer.uint32(32).uint64(message.maxSlippage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildRedeemTxRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildRedeemTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketMint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxSlippage = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildRedeemTxRequest {
    return {
      basketMint: isSet(object.basketMint) ? globalThis.String(object.basketMint) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      ownerAddress: isSet(object.ownerAddress) ? globalThis.String(object.ownerAddress) : "",
      maxSlippage: isSet(object.maxSlippage) ? globalThis.Number(object.maxSlippage) : undefined,
    };
  },

  toJSON(message: BuildRedeemTxRequest): unknown {
    const obj: any = {};
    if (message.basketMint !== undefined) {
      obj.basketMint = message.basketMint;
    }
    if (message.amount !== undefined) {
      obj.amount = message.amount;
    }
    if (message.ownerAddress !== undefined) {
      obj.ownerAddress = message.ownerAddress;
    }
    if (message.maxSlippage !== undefined) {
      obj.maxSlippage = Math.round(message.maxSlippage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildRedeemTxRequest>, I>>(base?: I): BuildRedeemTxRequest {
    return BuildRedeemTxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildRedeemTxRequest>, I>>(object: I): BuildRedeemTxRequest {
    const message = createBaseBuildRedeemTxRequest();
    message.basketMint = object.basketMint ?? "";
    message.amount = object.amount ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.maxSlippage = object.maxSlippage ?? undefined;
    return message;
  },
};

function createBaseGetBasketConfigByIDRequest(): GetBasketConfigByIDRequest {
  return { basketId: "" };
}

export const GetBasketConfigByIDRequest = {
  encode(message: GetBasketConfigByIDRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketId !== "") {
      writer.uint32(10).string(message.basketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBasketConfigByIDRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketConfigByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketConfigByIDRequest {
    return { basketId: isSet(object.basketId) ? globalThis.String(object.basketId) : "" };
  },

  toJSON(message: GetBasketConfigByIDRequest): unknown {
    const obj: any = {};
    if (message.basketId !== undefined) {
      obj.basketId = message.basketId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketConfigByIDRequest>, I>>(base?: I): GetBasketConfigByIDRequest {
    return GetBasketConfigByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketConfigByIDRequest>, I>>(object: I): GetBasketConfigByIDRequest {
    const message = createBaseGetBasketConfigByIDRequest();
    message.basketId = object.basketId ?? "";
    return message;
  },
};

function createBaseGetBasketMintByIDRequest(): GetBasketMintByIDRequest {
  return { basketId: "" };
}

export const GetBasketMintByIDRequest = {
  encode(message: GetBasketMintByIDRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.basketId !== "") {
      writer.uint32(10).string(message.basketId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBasketMintByIDRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketMintByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basketId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketMintByIDRequest {
    return { basketId: isSet(object.basketId) ? globalThis.String(object.basketId) : "" };
  },

  toJSON(message: GetBasketMintByIDRequest): unknown {
    const obj: any = {};
    if (message.basketId !== undefined) {
      obj.basketId = message.basketId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketMintByIDRequest>, I>>(base?: I): GetBasketMintByIDRequest {
    return GetBasketMintByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketMintByIDRequest>, I>>(object: I): GetBasketMintByIDRequest {
    const message = createBaseGetBasketMintByIDRequest();
    message.basketId = object.basketId ?? "";
    return message;
  },
};

function createBaseGetBasketMintByIDResponse(): GetBasketMintByIDResponse {
  return { mint: "" };
}

export const GetBasketMintByIDResponse = {
  encode(message: GetBasketMintByIDResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBasketMintByIDResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketMintByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketMintByIDResponse {
    return { mint: isSet(object.mint) ? globalThis.String(object.mint) : "" };
  },

  toJSON(message: GetBasketMintByIDResponse): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketMintByIDResponse>, I>>(base?: I): GetBasketMintByIDResponse {
    return GetBasketMintByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketMintByIDResponse>, I>>(object: I): GetBasketMintByIDResponse {
    const message = createBaseGetBasketMintByIDResponse();
    message.mint = object.mint ?? "";
    return message;
  },
};

function createBaseCommandCreateBasketRequest(): CommandCreateBasketRequest {
  return {};
}

export const CommandCreateBasketRequest = {
  encode(_: CommandCreateBasketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CommandCreateBasketRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandCreateBasketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CommandCreateBasketRequest {
    return {};
  },

  toJSON(_: CommandCreateBasketRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandCreateBasketRequest>, I>>(base?: I): CommandCreateBasketRequest {
    return CommandCreateBasketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandCreateBasketRequest>, I>>(_: I): CommandCreateBasketRequest {
    const message = createBaseCommandCreateBasketRequest();
    return message;
  },
};

function createBaseGetBasketRequest(): GetBasketRequest {
  return { mint: "" };
}

export const GetBasketRequest = {
  encode(message: GetBasketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBasketRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBasketRequest {
    return { mint: isSet(object.mint) ? globalThis.String(object.mint) : "" };
  },

  toJSON(message: GetBasketRequest): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBasketRequest>, I>>(base?: I): GetBasketRequest {
    return GetBasketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBasketRequest>, I>>(object: I): GetBasketRequest {
    const message = createBaseGetBasketRequest();
    message.mint = object.mint ?? "";
    return message;
  },
};

function createBaseBatchCreateTokenPoolsRequest(): BatchCreateTokenPoolsRequest {
  return { tokenPools: [] };
}

export const BatchCreateTokenPoolsRequest = {
  encode(message: BatchCreateTokenPoolsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tokenPools) {
      TokenPool.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchCreateTokenPoolsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateTokenPoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenPools.push(TokenPool.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateTokenPoolsRequest {
    return {
      tokenPools: globalThis.Array.isArray(object?.tokenPools)
        ? object.tokenPools.map((e: any) => TokenPool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateTokenPoolsRequest): unknown {
    const obj: any = {};
    if (message.tokenPools?.length) {
      obj.tokenPools = message.tokenPools.map((e) => TokenPool.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchCreateTokenPoolsRequest>, I>>(base?: I): BatchCreateTokenPoolsRequest {
    return BatchCreateTokenPoolsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchCreateTokenPoolsRequest>, I>>(object: I): BatchCreateTokenPoolsRequest {
    const message = createBaseBatchCreateTokenPoolsRequest();
    message.tokenPools = object.tokenPools?.map((e) => TokenPool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchCreateTokenPoolsResponse(): BatchCreateTokenPoolsResponse {
  return { tokenPools: [] };
}

export const BatchCreateTokenPoolsResponse = {
  encode(message: BatchCreateTokenPoolsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tokenPools) {
      TokenPool.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchCreateTokenPoolsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateTokenPoolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenPools.push(TokenPool.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateTokenPoolsResponse {
    return {
      tokenPools: globalThis.Array.isArray(object?.tokenPools)
        ? object.tokenPools.map((e: any) => TokenPool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateTokenPoolsResponse): unknown {
    const obj: any = {};
    if (message.tokenPools?.length) {
      obj.tokenPools = message.tokenPools.map((e) => TokenPool.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchCreateTokenPoolsResponse>, I>>(base?: I): BatchCreateTokenPoolsResponse {
    return BatchCreateTokenPoolsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchCreateTokenPoolsResponse>, I>>(
    object: I,
  ): BatchCreateTokenPoolsResponse {
    const message = createBaseBatchCreateTokenPoolsResponse();
    message.tokenPools = object.tokenPools?.map((e) => TokenPool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTxResponse(): TxResponse {
  return { tx: "" };
}

export const TxResponse = {
  encode(message: TxResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx !== "") {
      writer.uint32(10).string(message.tx);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TxResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tx = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TxResponse {
    return { tx: isSet(object.tx) ? globalThis.String(object.tx) : "" };
  },

  toJSON(message: TxResponse): unknown {
    const obj: any = {};
    if (message.tx !== undefined) {
      obj.tx = message.tx;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TxResponse>, I>>(base?: I): TxResponse {
    return TxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TxResponse>, I>>(object: I): TxResponse {
    const message = createBaseTxResponse();
    message.tx = object.tx ?? "";
    return message;
  },
};

function createBaseBasket(): Basket {
  return { mint: "", basketId: 0, name: "", symbol: "", uri: "", components: [] };
}

export const Basket = {
  encode(message: Basket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.basketId !== 0) {
      writer.uint32(16).uint64(message.basketId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.uri !== "") {
      writer.uint32(42).string(message.uri);
    }
    for (const v of message.components) {
      BasketComponent.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Basket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.basketId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.components.push(BasketComponent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Basket {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      basketId: isSet(object.basketId) ? globalThis.Number(object.basketId) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => BasketComponent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Basket): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.basketId !== undefined) {
      obj.basketId = Math.round(message.basketId);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => BasketComponent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Basket>, I>>(base?: I): Basket {
    return Basket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Basket>, I>>(object: I): Basket {
    const message = createBaseBasket();
    message.mint = object.mint ?? "";
    message.basketId = object.basketId ?? 0;
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.uri = object.uri ?? "";
    message.components = object.components?.map((e) => BasketComponent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenPool(): TokenPool {
  return { mint: "", poolType: 0, poolId: "", lookupTable: "" };
}

export const TokenPool = {
  encode(message: TokenPool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.poolType !== 0) {
      writer.uint32(16).int32(message.poolType);
    }
    if (message.poolId !== "") {
      writer.uint32(26).string(message.poolId);
    }
    if (message.lookupTable !== "") {
      writer.uint32(34).string(message.lookupTable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenPool {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.poolType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.poolId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lookupTable = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenPool {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      poolType: isSet(object.poolType) ? poolTypeFromJSON(object.poolType) : 0,
      poolId: isSet(object.poolId) ? globalThis.String(object.poolId) : "",
      lookupTable: isSet(object.lookupTable) ? globalThis.String(object.lookupTable) : "",
    };
  },

  toJSON(message: TokenPool): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.poolType !== undefined) {
      obj.poolType = poolTypeToJSON(message.poolType);
    }
    if (message.poolId !== undefined) {
      obj.poolId = message.poolId;
    }
    if (message.lookupTable !== undefined) {
      obj.lookupTable = message.lookupTable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenPool>, I>>(base?: I): TokenPool {
    return TokenPool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenPool>, I>>(object: I): TokenPool {
    const message = createBaseTokenPool();
    message.mint = object.mint ?? "";
    message.poolType = object.poolType ?? 0;
    message.poolId = object.poolId ?? "";
    message.lookupTable = object.lookupTable ?? "";
    return message;
  },
};

function createBaseProgramState(): ProgramState {
  return {
    bump: 0,
    admin: "",
    platformFeeWallet: "",
    basketCounter: "",
    rebalanceMarginLamports: "",
    creatorFeePercentage: "",
    platformFeePercentage: "",
    enableCreator: false,
    isInitialized: false,
  };
}

export const ProgramState = {
  encode(message: ProgramState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bump !== 0) {
      writer.uint32(8).uint32(message.bump);
    }
    if (message.admin !== "") {
      writer.uint32(18).string(message.admin);
    }
    if (message.platformFeeWallet !== "") {
      writer.uint32(26).string(message.platformFeeWallet);
    }
    if (message.basketCounter !== "") {
      writer.uint32(34).string(message.basketCounter);
    }
    if (message.rebalanceMarginLamports !== "") {
      writer.uint32(42).string(message.rebalanceMarginLamports);
    }
    if (message.creatorFeePercentage !== "") {
      writer.uint32(50).string(message.creatorFeePercentage);
    }
    if (message.platformFeePercentage !== "") {
      writer.uint32(58).string(message.platformFeePercentage);
    }
    if (message.enableCreator !== false) {
      writer.uint32(64).bool(message.enableCreator);
    }
    if (message.isInitialized !== false) {
      writer.uint32(72).bool(message.isInitialized);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProgramState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgramState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.bump = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.admin = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.platformFeeWallet = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.basketCounter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rebalanceMarginLamports = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.creatorFeePercentage = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.platformFeePercentage = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.enableCreator = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isInitialized = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgramState {
    return {
      bump: isSet(object.bump) ? globalThis.Number(object.bump) : 0,
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      platformFeeWallet: isSet(object.platformFeeWallet) ? globalThis.String(object.platformFeeWallet) : "",
      basketCounter: isSet(object.basketCounter) ? globalThis.String(object.basketCounter) : "",
      rebalanceMarginLamports: isSet(object.rebalanceMarginLamports)
        ? globalThis.String(object.rebalanceMarginLamports)
        : "",
      creatorFeePercentage: isSet(object.creatorFeePercentage) ? globalThis.String(object.creatorFeePercentage) : "",
      platformFeePercentage: isSet(object.platformFeePercentage) ? globalThis.String(object.platformFeePercentage) : "",
      enableCreator: isSet(object.enableCreator) ? globalThis.Boolean(object.enableCreator) : false,
      isInitialized: isSet(object.isInitialized) ? globalThis.Boolean(object.isInitialized) : false,
    };
  },

  toJSON(message: ProgramState): unknown {
    const obj: any = {};
    if (message.bump !== undefined) {
      obj.bump = Math.round(message.bump);
    }
    if (message.admin !== undefined) {
      obj.admin = message.admin;
    }
    if (message.platformFeeWallet !== undefined) {
      obj.platformFeeWallet = message.platformFeeWallet;
    }
    if (message.basketCounter !== undefined) {
      obj.basketCounter = message.basketCounter;
    }
    if (message.rebalanceMarginLamports !== undefined) {
      obj.rebalanceMarginLamports = message.rebalanceMarginLamports;
    }
    if (message.creatorFeePercentage !== undefined) {
      obj.creatorFeePercentage = message.creatorFeePercentage;
    }
    if (message.platformFeePercentage !== undefined) {
      obj.platformFeePercentage = message.platformFeePercentage;
    }
    if (message.enableCreator !== undefined) {
      obj.enableCreator = message.enableCreator;
    }
    if (message.isInitialized !== undefined) {
      obj.isInitialized = message.isInitialized;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgramState>, I>>(base?: I): ProgramState {
    return ProgramState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgramState>, I>>(object: I): ProgramState {
    const message = createBaseProgramState();
    message.bump = object.bump ?? 0;
    message.admin = object.admin ?? "";
    message.platformFeeWallet = object.platformFeeWallet ?? "";
    message.basketCounter = object.basketCounter ?? "";
    message.rebalanceMarginLamports = object.rebalanceMarginLamports ?? "";
    message.creatorFeePercentage = object.creatorFeePercentage ?? "";
    message.platformFeePercentage = object.platformFeePercentage ?? "";
    message.enableCreator = object.enableCreator ?? false;
    message.isInitialized = object.isInitialized ?? false;
    return message;
  },
};

function createBaseBasketConfig(): BasketConfig {
  return { bump: 0, id: 0, creator: "", rebalancer: "", mint: "", isRebalancing: false, components: [] };
}

export const BasketConfig = {
  encode(message: BasketConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bump !== 0) {
      writer.uint32(8).uint32(message.bump);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    if (message.creator !== "") {
      writer.uint32(26).string(message.creator);
    }
    if (message.rebalancer !== "") {
      writer.uint32(34).string(message.rebalancer);
    }
    if (message.mint !== "") {
      writer.uint32(42).string(message.mint);
    }
    if (message.isRebalancing !== false) {
      writer.uint32(48).bool(message.isRebalancing);
    }
    for (const v of message.components) {
      BasketComponent.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasketConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.bump = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rebalancer = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isRebalancing = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.components.push(BasketComponent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketConfig {
    return {
      bump: isSet(object.bump) ? globalThis.Number(object.bump) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      rebalancer: isSet(object.rebalancer) ? globalThis.String(object.rebalancer) : "",
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      isRebalancing: isSet(object.isRebalancing) ? globalThis.Boolean(object.isRebalancing) : false,
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => BasketComponent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BasketConfig): unknown {
    const obj: any = {};
    if (message.bump !== undefined) {
      obj.bump = Math.round(message.bump);
    }
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.creator !== undefined) {
      obj.creator = message.creator;
    }
    if (message.rebalancer !== undefined) {
      obj.rebalancer = message.rebalancer;
    }
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.isRebalancing !== undefined) {
      obj.isRebalancing = message.isRebalancing;
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => BasketComponent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketConfig>, I>>(base?: I): BasketConfig {
    return BasketConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketConfig>, I>>(object: I): BasketConfig {
    const message = createBaseBasketConfig();
    message.bump = object.bump ?? 0;
    message.id = object.id ?? 0;
    message.creator = object.creator ?? "";
    message.rebalancer = object.rebalancer ?? "";
    message.mint = object.mint ?? "";
    message.isRebalancing = object.isRebalancing ?? false;
    message.components = object.components?.map((e) => BasketComponent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBasketComponent(): BasketComponent {
  return { mint: "", quantity: 0 };
}

export const BasketComponent = {
  encode(message: BasketComponent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mint !== "") {
      writer.uint32(10).string(message.mint);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).uint64(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasketComponent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasketComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasketComponent {
    return {
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: BasketComponent): unknown {
    const obj: any = {};
    if (message.mint !== undefined) {
      obj.mint = message.mint;
    }
    if (message.quantity !== undefined) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasketComponent>, I>>(base?: I): BasketComponent {
    return BasketComponent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasketComponent>, I>>(object: I): BasketComponent {
    const message = createBaseBasketComponent();
    message.mint = object.mint ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

export interface PieProgramService {
  GetProgramState(request: Empty): Promise<ProgramState>;
  GetBasketConfigByID(request: GetBasketConfigByIDRequest): Promise<BasketConfig>;
  GetBasket(request: GetBasketRequest): Promise<Basket>;
  /** Get Basket Vault */
  GetBasketVault(request: GetBasketVaultRequest): Promise<GetBasketVaultResponse>;
  /** Batch Create Token Pools */
  BatchCreateTokenPools(request: BatchCreateTokenPoolsRequest): Promise<BatchCreateTokenPoolsResponse>;
  /** Build Rebalance Trasaction */
  BuildRebalanceTx(request: BuildRebalanceTxRequest): Promise<SerializedTxBundle>;
  /** Build Mint Transaction */
  BuildMintTx(request: BuildMintTxRequest): Promise<SerializedTxBundle>;
  /** Build Redeem Transaction */
  BuildRedeemTx(request: BuildRedeemTxRequest): Promise<SerializedTxBundle>;
  /** Send Create Basket Transaction to Solana */
  CommandCreateBasket(request: Basket): Promise<Basket>;
  CommandStartRebalanceBasket(request: Basket): Promise<TxResponse>;
  CommandStopRebalanceBasket(request: Basket): Promise<TxResponse>;
}

export const PieProgramServiceServiceName = "piedotfun.v1.PieProgramService";
export class PieProgramServiceClientImpl implements PieProgramService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || PieProgramServiceServiceName;
    this.rpc = rpc;
    this.GetProgramState = this.GetProgramState.bind(this);
    this.GetBasketConfigByID = this.GetBasketConfigByID.bind(this);
    this.GetBasket = this.GetBasket.bind(this);
    this.GetBasketVault = this.GetBasketVault.bind(this);
    this.BatchCreateTokenPools = this.BatchCreateTokenPools.bind(this);
    this.BuildRebalanceTx = this.BuildRebalanceTx.bind(this);
    this.BuildMintTx = this.BuildMintTx.bind(this);
    this.BuildRedeemTx = this.BuildRedeemTx.bind(this);
    this.CommandCreateBasket = this.CommandCreateBasket.bind(this);
    this.CommandStartRebalanceBasket = this.CommandStartRebalanceBasket.bind(this);
    this.CommandStopRebalanceBasket = this.CommandStopRebalanceBasket.bind(this);
  }
  GetProgramState(request: Empty): Promise<ProgramState> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProgramState", data);
    return promise.then((data) => ProgramState.decode(_m0.Reader.create(data)));
  }

  GetBasketConfigByID(request: GetBasketConfigByIDRequest): Promise<BasketConfig> {
    const data = GetBasketConfigByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBasketConfigByID", data);
    return promise.then((data) => BasketConfig.decode(_m0.Reader.create(data)));
  }

  GetBasket(request: GetBasketRequest): Promise<Basket> {
    const data = GetBasketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBasket", data);
    return promise.then((data) => Basket.decode(_m0.Reader.create(data)));
  }

  GetBasketVault(request: GetBasketVaultRequest): Promise<GetBasketVaultResponse> {
    const data = GetBasketVaultRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBasketVault", data);
    return promise.then((data) => GetBasketVaultResponse.decode(_m0.Reader.create(data)));
  }

  BatchCreateTokenPools(request: BatchCreateTokenPoolsRequest): Promise<BatchCreateTokenPoolsResponse> {
    const data = BatchCreateTokenPoolsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BatchCreateTokenPools", data);
    return promise.then((data) => BatchCreateTokenPoolsResponse.decode(_m0.Reader.create(data)));
  }

  BuildRebalanceTx(request: BuildRebalanceTxRequest): Promise<SerializedTxBundle> {
    const data = BuildRebalanceTxRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BuildRebalanceTx", data);
    return promise.then((data) => SerializedTxBundle.decode(_m0.Reader.create(data)));
  }

  BuildMintTx(request: BuildMintTxRequest): Promise<SerializedTxBundle> {
    const data = BuildMintTxRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BuildMintTx", data);
    return promise.then((data) => SerializedTxBundle.decode(_m0.Reader.create(data)));
  }

  BuildRedeemTx(request: BuildRedeemTxRequest): Promise<SerializedTxBundle> {
    const data = BuildRedeemTxRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BuildRedeemTx", data);
    return promise.then((data) => SerializedTxBundle.decode(_m0.Reader.create(data)));
  }

  CommandCreateBasket(request: Basket): Promise<Basket> {
    const data = Basket.encode(request).finish();
    const promise = this.rpc.request(this.service, "CommandCreateBasket", data);
    return promise.then((data) => Basket.decode(_m0.Reader.create(data)));
  }

  CommandStartRebalanceBasket(request: Basket): Promise<TxResponse> {
    const data = Basket.encode(request).finish();
    const promise = this.rpc.request(this.service, "CommandStartRebalanceBasket", data);
    return promise.then((data) => TxResponse.decode(_m0.Reader.create(data)));
  }

  CommandStopRebalanceBasket(request: Basket): Promise<TxResponse> {
    const data = Basket.encode(request).finish();
    const promise = this.rpc.request(this.service, "CommandStopRebalanceBasket", data);
    return promise.then((data) => TxResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
