// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               unknown
// source: pie-dot-fun/v1/fungible-token-market.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Currency, currencyFromJSON, currencyToJSON, Money, PriceChangesByPeriod } from "./common";

export const protobufPackage = "piedotfun.v1";

/** FungibleTokenMarket contains the market data for a fungible token. */
export interface FungibleTokenMarket {
  name: string;
  fungibleToken: string;
  displayName: string;
  symbol: string;
  /**
   * Native token symbol of the chain the fungible-token belongs to.
   * Not dollar(USDT, USDC),
   * and the prices and market cap fields will display dollar values together.
   */
  nativeCurrency: Currency;
  /**
   * Key is the `Currency` enum string,
   * value is the price with the `Currency`.
   *
   * @deprecated
   */
  prices: { [key: string]: Money };
  /**
   * Key is the `Currency` enum string,
   * value is the market cap with the `Currency`.
   *
   * @deprecated
   */
  marketCaps: { [key: string]: Money };
  /**
   * Key is the `Currency` enum string,
   * value is the price changes with the `Currency`.
   * {
   *   "CURRENCY_USDC": {
   *     "PRICE_CHANGE_PERIOD_1_HOUR": {
   *       "nominal_value": {
   *         "currency": "CURRENCY_USDC",
   *         "amount": 0.0001
   *       },
   *       "percentage_change": {
   *         "value": 0.0001
   *       },
   *       "period": "PRICE_CHANGE_PERIOD_1_HOUR"
   *     },
   *     "CURRENCY_SOL": { ... }
   * }
   * Support Periods
   * * PRICE_CHANGE_PERIOD_7_DAY
   *
   * @deprecated
   */
  priceChanges: { [key: string]: PriceChangesByPeriod };
  /** current price */
  price:
    | Money
    | undefined;
  /**
   * market cap
   *
   * @deprecated
   */
  marketCap:
    | Money
    | undefined;
  /**
   * Example
   * {
   *   "PRICE_CHANGE_PERIOD_7_DAY": {
   *       "nominal_value": {
   *           "currency": "CURRENCY_USDC",
   *           "amount": 0.0001
   *       },
   *       "percentage_change": {
   *           "value": 0.0001
   *       },
   *       "period": "PRICE_CHANGE_PERIOD_7_DAY"
   *   }
   *   ...
   * }
   * Support Periods
   * * PRICE_CHANGE_PERIOD_7_DAY
   */
  priceChange:
    | PriceChangesByPeriod
    | undefined;
  /**
   * Fully Diluted Valuations
   * Key is the `Currency` enum string,
   * value is the market cap with the `Currency`.
   */
  fdvs: { [key: string]: Money };
}

export interface FungibleTokenMarket_PricesEntry {
  key: string;
  value: Money | undefined;
}

export interface FungibleTokenMarket_MarketCapsEntry {
  key: string;
  value: Money | undefined;
}

export interface FungibleTokenMarket_PriceChangesEntry {
  key: string;
  value: PriceChangesByPeriod | undefined;
}

export interface FungibleTokenMarket_FdvsEntry {
  key: string;
  value: Money | undefined;
}

export interface GetFungibleTokenMarketRequest {
  /**
   * The name of the market  to retrieve.
   * Format : "fungibleTokens/{chain}/{token_address}/market"
   */
  fungibleTokenMarket: string;
  /** Display the price in this currency. Default is USD. */
  currency: Currency;
}

export interface ListFungibleTokensMarketsRequest {
  /**
   * If unspecified, at most 50 books will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * Token of the page to retrieve. If not specified, the first
   * page of results will be returned. Use the value obtained from
   * `next_page_token` in the previous response in order to request
   * the next page of results.
   */
  pageToken: string;
  /**
   * Available Sequence and Operator
   * * name
   *   * `=`
   *
   * Examples
   * * name="fungibleTokens/SOLANA/FZ4MT1HYJHd9GK8D5mJ9f3r7irLaDL5NxBNLjGqrLqs9/market"
   */
  filter: string;
  /**
   * One or more fields to compare and use to sort the output.
   * To specify ascending or descending order, append " asc" or " desc" to the field name. If not specified, the order is ascending.
   *
   * Reference
   * * https://google.aip.dev/132#ordering.
   *
   * Supported Fields
   * *
   *
   * Examples
   * *
   */
  orderBy: string;
  /** Display the price in this currency. Default is USD. */
  currency: Currency;
}

export interface ListFungibleTokensMarketsResponse {
  fungibleTokenMarkets: FungibleTokenMarket[];
  /**
   * Pagination token used to retrieve the next page of results.
   * Pass the content of this string as the `page_token` attribute of
   * the next request. `next_page_token` is not returned for the last
   * page.
   */
  nextPageToken: string;
}

function createBaseFungibleTokenMarket(): FungibleTokenMarket {
  return {
    name: "",
    fungibleToken: "",
    displayName: "",
    symbol: "",
    nativeCurrency: 0,
    prices: {},
    marketCaps: {},
    priceChanges: {},
    price: undefined,
    marketCap: undefined,
    priceChange: undefined,
    fdvs: {},
  };
}

export const FungibleTokenMarket = {
  encode(message: FungibleTokenMarket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fungibleToken !== "") {
      writer.uint32(18).string(message.fungibleToken);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.nativeCurrency !== 0) {
      writer.uint32(40).int32(message.nativeCurrency);
    }
    Object.entries(message.prices).forEach(([key, value]) => {
      FungibleTokenMarket_PricesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    Object.entries(message.marketCaps).forEach(([key, value]) => {
      FungibleTokenMarket_MarketCapsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).ldelim();
    });
    Object.entries(message.priceChanges).forEach(([key, value]) => {
      FungibleTokenMarket_PriceChangesEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).ldelim();
    });
    if (message.price !== undefined) {
      Money.encode(message.price, writer.uint32(82).fork()).ldelim();
    }
    if (message.marketCap !== undefined) {
      Money.encode(message.marketCap, writer.uint32(90).fork()).ldelim();
    }
    if (message.priceChange !== undefined) {
      PriceChangesByPeriod.encode(message.priceChange, writer.uint32(98).fork()).ldelim();
    }
    Object.entries(message.fdvs).forEach(([key, value]) => {
      FungibleTokenMarket_FdvsEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FungibleTokenMarket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFungibleTokenMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fungibleToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nativeCurrency = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = FungibleTokenMarket_PricesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.prices[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = FungibleTokenMarket_MarketCapsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.marketCaps[entry8.key] = entry8.value;
          }
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = FungibleTokenMarket_PriceChangesEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.priceChanges[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.price = Money.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.marketCap = Money.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.priceChange = PriceChangesByPeriod.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          const entry13 = FungibleTokenMarket_FdvsEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.fdvs[entry13.key] = entry13.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FungibleTokenMarket {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fungibleToken: isSet(object.fungibleToken) ? globalThis.String(object.fungibleToken) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      nativeCurrency: isSet(object.nativeCurrency) ? currencyFromJSON(object.nativeCurrency) : 0,
      prices: isObject(object.prices)
        ? Object.entries(object.prices).reduce<{ [key: string]: Money }>((acc, [key, value]) => {
          acc[key] = Money.fromJSON(value);
          return acc;
        }, {})
        : {},
      marketCaps: isObject(object.marketCaps)
        ? Object.entries(object.marketCaps).reduce<{ [key: string]: Money }>((acc, [key, value]) => {
          acc[key] = Money.fromJSON(value);
          return acc;
        }, {})
        : {},
      priceChanges: isObject(object.priceChanges)
        ? Object.entries(object.priceChanges).reduce<{ [key: string]: PriceChangesByPeriod }>((acc, [key, value]) => {
          acc[key] = PriceChangesByPeriod.fromJSON(value);
          return acc;
        }, {})
        : {},
      price: isSet(object.price) ? Money.fromJSON(object.price) : undefined,
      marketCap: isSet(object.marketCap) ? Money.fromJSON(object.marketCap) : undefined,
      priceChange: isSet(object.priceChange) ? PriceChangesByPeriod.fromJSON(object.priceChange) : undefined,
      fdvs: isObject(object.fdvs)
        ? Object.entries(object.fdvs).reduce<{ [key: string]: Money }>((acc, [key, value]) => {
          acc[key] = Money.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: FungibleTokenMarket): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.fungibleToken !== undefined) {
      obj.fungibleToken = message.fungibleToken;
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.nativeCurrency !== undefined) {
      obj.nativeCurrency = currencyToJSON(message.nativeCurrency);
    }
    if (message.prices) {
      const entries = Object.entries(message.prices);
      if (entries.length > 0) {
        obj.prices = {};
        entries.forEach(([k, v]) => {
          obj.prices[k] = Money.toJSON(v);
        });
      }
    }
    if (message.marketCaps) {
      const entries = Object.entries(message.marketCaps);
      if (entries.length > 0) {
        obj.marketCaps = {};
        entries.forEach(([k, v]) => {
          obj.marketCaps[k] = Money.toJSON(v);
        });
      }
    }
    if (message.priceChanges) {
      const entries = Object.entries(message.priceChanges);
      if (entries.length > 0) {
        obj.priceChanges = {};
        entries.forEach(([k, v]) => {
          obj.priceChanges[k] = PriceChangesByPeriod.toJSON(v);
        });
      }
    }
    if (message.price !== undefined) {
      obj.price = Money.toJSON(message.price);
    }
    if (message.marketCap !== undefined) {
      obj.marketCap = Money.toJSON(message.marketCap);
    }
    if (message.priceChange !== undefined) {
      obj.priceChange = PriceChangesByPeriod.toJSON(message.priceChange);
    }
    if (message.fdvs) {
      const entries = Object.entries(message.fdvs);
      if (entries.length > 0) {
        obj.fdvs = {};
        entries.forEach(([k, v]) => {
          obj.fdvs[k] = Money.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FungibleTokenMarket>, I>>(base?: I): FungibleTokenMarket {
    return FungibleTokenMarket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FungibleTokenMarket>, I>>(object: I): FungibleTokenMarket {
    const message = createBaseFungibleTokenMarket();
    message.name = object.name ?? "";
    message.fungibleToken = object.fungibleToken ?? "";
    message.displayName = object.displayName ?? "";
    message.symbol = object.symbol ?? "";
    message.nativeCurrency = object.nativeCurrency ?? 0;
    message.prices = Object.entries(object.prices ?? {}).reduce<{ [key: string]: Money }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Money.fromPartial(value);
      }
      return acc;
    }, {});
    message.marketCaps = Object.entries(object.marketCaps ?? {}).reduce<{ [key: string]: Money }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Money.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.priceChanges = Object.entries(object.priceChanges ?? {}).reduce<{ [key: string]: PriceChangesByPeriod }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = PriceChangesByPeriod.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.price = (object.price !== undefined && object.price !== null) ? Money.fromPartial(object.price) : undefined;
    message.marketCap = (object.marketCap !== undefined && object.marketCap !== null)
      ? Money.fromPartial(object.marketCap)
      : undefined;
    message.priceChange = (object.priceChange !== undefined && object.priceChange !== null)
      ? PriceChangesByPeriod.fromPartial(object.priceChange)
      : undefined;
    message.fdvs = Object.entries(object.fdvs ?? {}).reduce<{ [key: string]: Money }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Money.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseFungibleTokenMarket_PricesEntry(): FungibleTokenMarket_PricesEntry {
  return { key: "", value: undefined };
}

export const FungibleTokenMarket_PricesEntry = {
  encode(message: FungibleTokenMarket_PricesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Money.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FungibleTokenMarket_PricesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFungibleTokenMarket_PricesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FungibleTokenMarket_PricesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Money.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FungibleTokenMarket_PricesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Money.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FungibleTokenMarket_PricesEntry>, I>>(base?: I): FungibleTokenMarket_PricesEntry {
    return FungibleTokenMarket_PricesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FungibleTokenMarket_PricesEntry>, I>>(
    object: I,
  ): FungibleTokenMarket_PricesEntry {
    const message = createBaseFungibleTokenMarket_PricesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Money.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseFungibleTokenMarket_MarketCapsEntry(): FungibleTokenMarket_MarketCapsEntry {
  return { key: "", value: undefined };
}

export const FungibleTokenMarket_MarketCapsEntry = {
  encode(message: FungibleTokenMarket_MarketCapsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Money.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FungibleTokenMarket_MarketCapsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFungibleTokenMarket_MarketCapsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FungibleTokenMarket_MarketCapsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Money.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FungibleTokenMarket_MarketCapsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Money.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FungibleTokenMarket_MarketCapsEntry>, I>>(
    base?: I,
  ): FungibleTokenMarket_MarketCapsEntry {
    return FungibleTokenMarket_MarketCapsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FungibleTokenMarket_MarketCapsEntry>, I>>(
    object: I,
  ): FungibleTokenMarket_MarketCapsEntry {
    const message = createBaseFungibleTokenMarket_MarketCapsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Money.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseFungibleTokenMarket_PriceChangesEntry(): FungibleTokenMarket_PriceChangesEntry {
  return { key: "", value: undefined };
}

export const FungibleTokenMarket_PriceChangesEntry = {
  encode(message: FungibleTokenMarket_PriceChangesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      PriceChangesByPeriod.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FungibleTokenMarket_PriceChangesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFungibleTokenMarket_PriceChangesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = PriceChangesByPeriod.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FungibleTokenMarket_PriceChangesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? PriceChangesByPeriod.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FungibleTokenMarket_PriceChangesEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = PriceChangesByPeriod.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FungibleTokenMarket_PriceChangesEntry>, I>>(
    base?: I,
  ): FungibleTokenMarket_PriceChangesEntry {
    return FungibleTokenMarket_PriceChangesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FungibleTokenMarket_PriceChangesEntry>, I>>(
    object: I,
  ): FungibleTokenMarket_PriceChangesEntry {
    const message = createBaseFungibleTokenMarket_PriceChangesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? PriceChangesByPeriod.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFungibleTokenMarket_FdvsEntry(): FungibleTokenMarket_FdvsEntry {
  return { key: "", value: undefined };
}

export const FungibleTokenMarket_FdvsEntry = {
  encode(message: FungibleTokenMarket_FdvsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Money.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FungibleTokenMarket_FdvsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFungibleTokenMarket_FdvsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FungibleTokenMarket_FdvsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Money.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: FungibleTokenMarket_FdvsEntry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Money.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FungibleTokenMarket_FdvsEntry>, I>>(base?: I): FungibleTokenMarket_FdvsEntry {
    return FungibleTokenMarket_FdvsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FungibleTokenMarket_FdvsEntry>, I>>(
    object: I,
  ): FungibleTokenMarket_FdvsEntry {
    const message = createBaseFungibleTokenMarket_FdvsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Money.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseGetFungibleTokenMarketRequest(): GetFungibleTokenMarketRequest {
  return { fungibleTokenMarket: "", currency: 0 };
}

export const GetFungibleTokenMarketRequest = {
  encode(message: GetFungibleTokenMarketRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fungibleTokenMarket !== "") {
      writer.uint32(10).string(message.fungibleTokenMarket);
    }
    if (message.currency !== 0) {
      writer.uint32(16).int32(message.currency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetFungibleTokenMarketRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFungibleTokenMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fungibleTokenMarket = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFungibleTokenMarketRequest {
    return {
      fungibleTokenMarket: isSet(object.fungibleTokenMarket) ? globalThis.String(object.fungibleTokenMarket) : "",
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : 0,
    };
  },

  toJSON(message: GetFungibleTokenMarketRequest): unknown {
    const obj: any = {};
    if (message.fungibleTokenMarket !== undefined) {
      obj.fungibleTokenMarket = message.fungibleTokenMarket;
    }
    if (message.currency !== undefined) {
      obj.currency = currencyToJSON(message.currency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFungibleTokenMarketRequest>, I>>(base?: I): GetFungibleTokenMarketRequest {
    return GetFungibleTokenMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFungibleTokenMarketRequest>, I>>(
    object: I,
  ): GetFungibleTokenMarketRequest {
    const message = createBaseGetFungibleTokenMarketRequest();
    message.fungibleTokenMarket = object.fungibleTokenMarket ?? "";
    message.currency = object.currency ?? 0;
    return message;
  },
};

function createBaseListFungibleTokensMarketsRequest(): ListFungibleTokensMarketsRequest {
  return { pageSize: 0, pageToken: "", filter: "", orderBy: "", currency: 0 };
}

export const ListFungibleTokensMarketsRequest = {
  encode(message: ListFungibleTokensMarketsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    if (message.currency !== 0) {
      writer.uint32(40).int32(message.currency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListFungibleTokensMarketsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFungibleTokensMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFungibleTokensMarketsRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : 0,
    };
  },

  toJSON(message: ListFungibleTokensMarketsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    if (message.orderBy !== undefined) {
      obj.orderBy = message.orderBy;
    }
    if (message.currency !== undefined) {
      obj.currency = currencyToJSON(message.currency);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFungibleTokensMarketsRequest>, I>>(
    base?: I,
  ): ListFungibleTokensMarketsRequest {
    return ListFungibleTokensMarketsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFungibleTokensMarketsRequest>, I>>(
    object: I,
  ): ListFungibleTokensMarketsRequest {
    const message = createBaseListFungibleTokensMarketsRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.currency = object.currency ?? 0;
    return message;
  },
};

function createBaseListFungibleTokensMarketsResponse(): ListFungibleTokensMarketsResponse {
  return { fungibleTokenMarkets: [], nextPageToken: "" };
}

export const ListFungibleTokensMarketsResponse = {
  encode(message: ListFungibleTokensMarketsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.fungibleTokenMarkets) {
      FungibleTokenMarket.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListFungibleTokensMarketsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFungibleTokensMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fungibleTokenMarkets.push(FungibleTokenMarket.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFungibleTokensMarketsResponse {
    return {
      fungibleTokenMarkets: globalThis.Array.isArray(object?.fungibleTokenMarkets)
        ? object.fungibleTokenMarkets.map((e: any) => FungibleTokenMarket.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListFungibleTokensMarketsResponse): unknown {
    const obj: any = {};
    if (message.fungibleTokenMarkets?.length) {
      obj.fungibleTokenMarkets = message.fungibleTokenMarkets.map((e) => FungibleTokenMarket.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFungibleTokensMarketsResponse>, I>>(
    base?: I,
  ): ListFungibleTokensMarketsResponse {
    return ListFungibleTokensMarketsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFungibleTokensMarketsResponse>, I>>(
    object: I,
  ): ListFungibleTokensMarketsResponse {
    const message = createBaseListFungibleTokensMarketsResponse();
    message.fungibleTokenMarkets = object.fungibleTokenMarkets?.map((e) => FungibleTokenMarket.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/** FungibleTokenMarketService is the service for managing fungible token markets. */
export interface FungibleTokenMarketService {
  /** GetFungibleTokenMarket returns the market for the given fungible token. */
  GetFungibleTokenMarket(request: GetFungibleTokenMarketRequest): Promise<FungibleTokenMarket>;
  GetOrCreateFungibleTokenMarket(request: GetFungibleTokenMarketRequest): Promise<FungibleTokenMarket>;
  /** ListFungibleTokenMarkets returns the list of markets for the given fungible tokens. */
  ListFungibleTokenMarkets(request: ListFungibleTokensMarketsRequest): Promise<ListFungibleTokensMarketsResponse>;
}

export const FungibleTokenMarketServiceServiceName = "piedotfun.v1.FungibleTokenMarketService";
export class FungibleTokenMarketServiceClientImpl implements FungibleTokenMarketService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || FungibleTokenMarketServiceServiceName;
    this.rpc = rpc;
    this.GetFungibleTokenMarket = this.GetFungibleTokenMarket.bind(this);
    this.GetOrCreateFungibleTokenMarket = this.GetOrCreateFungibleTokenMarket.bind(this);
    this.ListFungibleTokenMarkets = this.ListFungibleTokenMarkets.bind(this);
  }
  GetFungibleTokenMarket(request: GetFungibleTokenMarketRequest): Promise<FungibleTokenMarket> {
    const data = GetFungibleTokenMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetFungibleTokenMarket", data);
    return promise.then((data) => FungibleTokenMarket.decode(_m0.Reader.create(data)));
  }

  GetOrCreateFungibleTokenMarket(request: GetFungibleTokenMarketRequest): Promise<FungibleTokenMarket> {
    const data = GetFungibleTokenMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOrCreateFungibleTokenMarket", data);
    return promise.then((data) => FungibleTokenMarket.decode(_m0.Reader.create(data)));
  }

  ListFungibleTokenMarkets(request: ListFungibleTokensMarketsRequest): Promise<ListFungibleTokensMarketsResponse> {
    const data = ListFungibleTokensMarketsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListFungibleTokenMarkets", data);
    return promise.then((data) => ListFungibleTokensMarketsResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
